[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pensamiento Computacional",
    "section": "",
    "text": "Pensamiento Computacional\nBienvenidos y bienvenidas a la cátedra de Pensamiento Computacional del Ciclo Básico Común de la Facultad de Ingeniería - UBA."
  },
  {
    "objectID": "index.html#docentes-de-la-cátedra",
    "href": "index.html#docentes-de-la-cátedra",
    "title": "Pensamiento Computacional",
    "section": "Docentes de la Cátedra",
    "text": "Docentes de la Cátedra\n\nProf. Titular: Méndez, Mariano\nBulacios, Juan Pablo\nNotari, Pablo\nRastrelli, Aldana"
  },
  {
    "objectID": "intro.html#fundamentación",
    "href": "intro.html#fundamentación",
    "title": "La Materia",
    "section": "Fundamentación",
    "text": "Fundamentación\nEl pensamiento computacional es una disciplina que ha sido definida como “el conjunto de procesos de pensamiento implicados en la formulación de problemas y sus soluciones, de manera que dichas soluciones sean representadas de una forma que puedan ser efectivamente ejecutadas por un agente de procesamiento de información”, entendiendo por esto último a un humano, una máquina o una combinación de ambos.\nReconoce antecedentes en trabajos de la Carnegie Mellon University de la década de 1960 y del Massachusetts Institute of Technology de alrededor de 1980, aunque su auge en la educación superior llegó con la primera década del siglo XXI.\nLas herramientas básicas en las que se funda el pensamiento computacional son la descomposición, la abstracción, el reconocimiento de patrones y la algoritmia. Está ampliamente aceptado que estas herramientas no sirven solamente a los profesionales de Ciencias de la Computación y de Informática, sino a cualquier persona que deba resolver problemas, con lo cual el pensamiento computacional deviene una técnica de resolución de problemas. Actualmente, los y las profesionales de la Ingeniería requieren de una capacidad analítica que les permita resolver problemas, y en ese sentido el pensamiento computacional se convierte en un soporte invaluable de esa competencia (cada vez más las ciencias de la computación y la informática constituyen una ciencia básica para todas las ingenierías).\nSi bien el pensamiento computacional no necesariamente requiere del uso de computadoras, la programación de computadoras se convierte en su complemento ideal. En primer lugar, porque permite comprobar, mediante la codificación de un algoritmo en un programa, la validez de la solución encontrada al problema, de manera sencilla y prácticamente inmediata. En segundo lugar, porque la programación incentiva la creatividad, la capacidad para la autoorganización y el trabajo en equipo. En tercer lugar, porque la programación constituye un recurso habitual del trabajo en el campo profesional de la ingeniería."
  },
  {
    "objectID": "intro.html#objetivos-generales",
    "href": "intro.html#objetivos-generales",
    "title": "La Materia",
    "section": "Objetivos Generales",
    "text": "Objetivos Generales\nEl objetivo general de la asignatura es que los/as estudiantes adquieran habilidades de resolución de problemas de ingeniería mediante el soporte de un lenguaje de programación multiparadigma."
  },
  {
    "objectID": "unidad_1.html#introducción",
    "href": "unidad_1.html#introducción",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.1 Introducción",
    "text": "1.1 Introducción\nComo en todas las disciplinas, la Ingeniería de Software y la Programación de Sistemas en general tienen un lenguaje técnico específico. La utilización de ciertos términos y el compartir de ciertos conceptos agiliza el diálogo y mejora la comprensión con los pares.\nEn este capítulo vamos a hacer una breve introducción de ciertos conceptos, ideas y modelos que van a permitirnos establecer acuerdos y manejar un lenguaje común.\n\n1.1.1 La Computadora\nUna computadora es un dispositivo físico de procesamiento de datos, con un propósito general. Todos los programas que escribiremos serán ejecutados (o corridos) en una computadora. Una computadora es capaz de procesar datos y obtener nueva información o resultados.\n\n\n1.1.2 Software y Hardware\nToda computadora funciona con software y hardware. El software es el conjunto de herramientas abstractas (programas), y se le llama componente lógica del modelo computacional. El hardware es el componente físico del dispositivo. Básicamente, el software dice qué hacer, y el hardware lo hace.\n\n\n\n\n\n\n¿Es indispensable tener una computadora para crear un algoritmo?\n\n\n\n\nLa respuesta, sorprendentemente, es no: muchos de los algoritmos que se utilizan de forma computacional hoy en día fueron diseñados varias décadas atrás. Pero la implementación de un algoritmo depende del grado de avance del hardware y la tecnología disponible.\n\n\n\n\n1.1.3 Sistema Operativo\nEl sistema operaativo es el programa encargado de administrar los recursos del sistema. Los recursos (como la memoria, por ejemplo) son disputados entre diferentes programas o procesos ejecutándose al mismo tiempo. El sistema operativo es el que decide cómo administrar y asignar los recursos disponibles.\nLos sistemas operativos más comunes el día de hoy son: Windows, Linux, iOS, Android; por ejemplo.\n\n\n1.1.4 Algoritmo\nUn algoritmo es una serie finita de pasos precisos para alcanzar un objetivo.\n\n“serie”: porque son continuados uno detrás del otro, de forma ordenada.\n“finita”: porque no pueden ser pasos infinitos, en algún momento deben terminar.\n“pasos precisos”: porque en un algoritmo se debe ser lo más específico posible.\n\n\nEjemplo Un algoritmo puede ser una receta de cocina: tiene una serie finita de pasos (son ordenados, uno detrás de otro, finitos porque en algún momento deben terminar), que son precisos (porque tienen indicaciones de cuánto agregar de cada ingrediente, cómo incorporarlo a la preparación, etc) y están orientados en alcanzar un objetivo (obtener una comida en particular).\n\n\n1.1.4.1 Creación de un Algoritmo\nLa forma en la que trabajaremos la creación de un algoritmo es siguiendo los siguientes pasos: 1. Análisis del problema: entender el objetivo y los posibles casos puntuales del mismo. 2. Primer borrador de solución: confeccionar una idea generalizada de cómo podría resolverse el problema. 3. División del problema en partes: dividir el problema en partes ayuda a descomponer un problema complejo en varios más sencillos. 4. Ensamble de las partes para la versión final del algoritmo: acoplar todo el conjunto de partes del problema para lograr el objetivo general.\nEstos cuatro pasos podrán iterarse (repetirse) la cantidad de veces que sean necesarios, para poder lograr acercarnos más a la solución en cada iteración.\n\n\n\n1.1.5 Programa\nUn programa es un algoritmo escrito en un lenguaje de programación.\n\n\n1.1.6 Lenguaje de Programación\nUn lenguaje de programación es un protocolo de comunicación.\nUn protocolo es un conjunto de normas consensuadas.\n\\(\\implies\\) Entonces, un lenguaje de programación es un conjunto de normas consensuadas, entre la persona y la máquina, para poder comunicarse.\nCuando logramos que un lenguaje pueda ser comprendido por el humano y por la máquina, tenemos una comunicación efectiva en donde podremos hacer programas y pedirle a la máquina que los ejecute.\nUn buen ejemplo de cómo una computadora interpreta nuestras instrucciones sin pensar al respecto, sin tener sentido común y sin ambigüedades, es este video. La computadora lo único que hace es interpretar de forma explícita lo que nosotros le pedimos que haga.\nUn lenguaje de programación tiene reglas estrictas que se deben respetar y no se admiten ambiguedades o sobreentendidos.\n\n\n1.1.7 Entorno de Desarrollo\nUn entorno de desarrollo es un conjunto de herramientas que nos permiten escribir, editar, compilar y ejecutar programas.\n\nEn la materia utilizaremos un entorno de desarrollo llamado Replit, que nos permite escribir código en un editor de texto, compilarlo y ejecutarlo en un mismo lugar de forma online. Pero existen muchos otros entornos de desarrollo, como por ejemplo Visual Studio Code, Eclipse, NetBeans, etc."
  },
  {
    "objectID": "unidad_1.html#lenguaje-python",
    "href": "unidad_1.html#lenguaje-python",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.2 Lenguaje Python",
    "text": "1.2 Lenguaje Python\nEn este curso utilizaremos el lenguaje de programación Python. Python es un lenguaje de programación de propósito general, que se utiliza en muchos ámbitos de la industria y la academia.\nPython es un lenguaje realmente fácil de aprender, con una curva de aprendizaje muy suave. Es un lenguaje de alto nivel, lo que significa que es un lenguaje que se asemeja mucho al lenguaje natural, y que no requiere de conocimientos de bajo nivel para poder utilizarlo.\n\n1.2.1 Hola, Mundo!\nEl primer programa que se escribe en cualquier lenguaje de programación es el programa “Hola, Mundo!”. Este programa es un programa que imprime en pantalla el texto “Hola, Mundo!”.\nEn Python, el programa “Hola, Mundo!” se escribe de la siguiente forma:\n\nprint(\"Hola, Mundo!\")\n\nHola, Mundo!\n\n\nprint es una función que imprime en pantalla el texto que se le pasa entre paréntesis. En este caso, el texto que se le pasa como parámetro es \"Hola, Mundo!\". Al escribir las comillas dobles, estamos indicando que el texto que se encuentra entre ellas es un texto literal.\nDe la misma forma, podremos imprimir cualquier otro mensaje en pantalla, como por ejemplo:\n\nprint(\"Hola, me llamo Rosita y soy programadora\")\n\nHola, me llamo Rosita y soy programadora\n\n\nAl igual que Rosita, al hacer nuestro primer ‘Hola, Mundo!’ nos convertimos en programadores. ¡Felicitaciones!\nA partir de la próxima clase, comenzaremos a ver cómo escribir programas más complejos, que nos permitan resolver problemas más interesantes."
  },
  {
    "objectID": "unidad_1.html#anexo-replit",
    "href": "unidad_1.html#anexo-replit",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.3 Anexo: Replit",
    "text": "1.3 Anexo: Replit\n\n1.3.1 Creación de una nueva cuenta\nPara utilizar replit vamos a ingresar a https://replit.com/.\n\n\n\n\nPágina de inicio de Replit\n\n\nVamos a presionar luego en Sign Up, donde va a pedir crear una cuenta, o iniciar sesión si ya tenemos una. Una de nuestras opciones es, si tenemos una cuenta google ya creada, iniciar sesión con eso. De lo contrario, podemos crear una cuenta nueva con un mail.\n\n\n\nPágina de creación de cuenta de Replit\n\n\n\n\n1.3.2 Creación de un nuevo proyecto\nUna vez creada la cuenta e iniciado sesión, vamos a ver esta pantalla:\n\n\n\nHome de Replit\n\n\nEn la misma vamos a ver muchas opciones, pero la que nosotros nos interesa es el botón de + Create Repl, que nos va a permitir crear un nuevo proyecto.\n\n\n\nBotón de creación de un nuevo proyecto en Replit\n\n\nSe va a abrir la siguiente ventana: \nDonde vamos a buscar y elegir en “Templates” el lenguaje de programación Python. Luego, vamos a asignarle un nombre y seleccionar “Create repl”.\nSe debería ver algo así:\n\n\n\nVentana completa de creación de un nuevo proyecto en Replit\n\n\n\n\n1.3.3 Uso del nuevo proyecto\nLos espacios o proyectos en replit se llaman Workspace, que significa espacio de trabajo. En este espacio de trabajo vamos a poder escribir código, ejecutarlo, y ver los resultados de la ejecución.\nUna vez creado el espacio de trabajo, se nos va a abrir una pantalla donde vamos a ver varias cosas.\nInicialmente, tenemos en el centro el espacio de edición de código, donde vamos a escribir nuestro programa. \nEn la parte superior, vamos a ver un botón de Run, que nos va a permitir ejecutar el programa que escribimos.\n\n\n\nBotón de ejecución de código\n\n\nEn la parte derecha, vamos a ver el resultado de la ejecución del programa. En este caso, como no escribimos nada, no hay nada para mostrar.\n\n\n\nResultado de la ejecución de código\n\n\nFinalmente, en la parte izquierda vamos a tener el menú de archivos, donde vamos a poder crear nuevos archivos, borrarlos, etc. También tiene el acceso a otras herramientas que de momento no vamos a estar usando.\n\n\n\nMenú de archivos\n\n\nVamos a ver que en el menú de archivos ya tenemos un archivo creado, llamado main.py. Este archivo es el archivo principal de nuestro programa, y es el que se ejecuta cuando presionamos el botón de Run.\nSi bien podemos tener otros archivos, el único que se ejecuta cuando presionamos Run es main.py. Por lo tanto, es importante que nuestro programa principal o lo que nosotros queremos correr, esté en este archivo. Lo que podemos hacer, es crear otros archivos para ir guardando nuestro código y ejercicios anteriores sin necesidad de que se ejecuten cada vez que presionamos Run.\n\n¡Probemos el espacio de trabajo! Vamos a escribir en el archivo main.py el siguiente código: print(\"Hola, Mundo!\"). Luego, vamos a presionar el botón de Run y vamos a ver el resultado en la parte derecha de la pantalla.\n\n¡Felicitaciones! Ya escribiste tu primer programa en Python.\n\n\n\n\n\n\n\n\n\n\n¿Lograste ver el resultado? ¿Qué pasa si presionás el botón de Run varias veces seguidas?"
  },
  {
    "objectID": "unidad_2.html#sentencias-básicas",
    "href": "unidad_2.html#sentencias-básicas",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.1 Sentencias Básicas",
    "text": "2.1 Sentencias Básicas\nEn esta unidad vamos a centrarnos en la herramienta que vamos a emplear, que es Python. Vamos a hacer un programa sencillo, interactuar con el usuario y más.\n\n2.1.1 Flujo de Control de un Programa\nEl flujo de control de un programa es la forma en la que se ejecutan las instrucciones de un programa. En Python, el flujo de control es secuencial, es decir, se ejecutan las instrucciones una detrás de otra. En otros lenguajes de programación, el flujo de control puede ser condicional o repetitivo.\nEjemplo:\nEsta línea se ejecutaría primero        ↓\nEsta línea se ejecutaría después        ↓\nEsta línea se ejecutaría a lo último    \nEn este curso, la comunicación de los programas con el mundo exterior se realizará casi exclusivamente con el usuario por medio de la consola (o terminal, la presentamos en la unidad anterior en el anexo de Replit).\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nEsto no significa que todos los programas siempre se comuniquen con el usuario para todo. Pensemos en las aplicaciones que usamos generalmente, como instagram: imaginémonos si para cada acción que hiciéramos dentro de la app la misma nos preguntara si queremos hacerlo o no:\n\n- “¿Estás seguro/a de que querés iniciar sesión?”\n- “¿Estás seguro/a de que querés traer tu nombre de usuario para mostrarse en el perfil?”\n- “¿Estás seguro/a de que querés traer tu foto de usuario para mostrarse en el perfil?”\n\nSería extremadamente molesto. Uno simplemente inicia sesión, y hay un montón de cosas y procesos que se ejecutan uno detrás de otro, automáticamente.\n\nHay cosas que no necesitan de la interacción del usuario. Nosotros nos vamos a centrar en la interacción con el usuario en gran parte del curso, pero no es lo único que se puede hacer. Los programas pueden comunicarse con otros programas y las partes de un mismo programa pueden comunicarse con otras partes del mismo programa.  Más adelante vamos a ver un poco más de esta diferencia.\n\n\n\n\n2.1.2 Valores y Tipos\nSi tenemos la operación 7 * 5, sabemos que el resultado es 35. Decimos que tanto 7, 5 como 35 son valores. En los lenguajes de programación, cada valor tiene un tipo.\nEn este caso, 7, 5 y 35 son enteros (o integers en inglés). En Python, los enteros se representan con el tipo int.\nPython tiene dos tipos de datos numéricos: - número enteros - números de punto flotante\nLos números enteros representan un valor entero exacto, como 42, 0, -5 o 10000.\nLos números de punto flotante tienen una parte fraccionaria, como 3.14159, 1.0 o 0.0.\nSegún los operandos (los valores que se operan) y el operador (el símbolo que indica la operación), el resultado puede ser de un tipo u otro. Por ejemplo, si tenemos 7 / 5, el resultado es 1.4, que es un número de punto flotante. Si tenemos 7 + 5, el resultado es 12, que es un número entero.\n\n1 + 2\n\n3\n\n\nVamos a elegir usar enteros cada vez que necesitemos recordar, almacenar o representar un valor exacto, como pueden ser por ejemplo: la cantidad de alumnos, cuántas veces repetimos una operación, un número de documento, etc.\nVamos a elegir usar números de punto flotante cada vez que necesitemos recordar, almacenar o representar un valor aproximado, como pueden ser por ejemplo: la altura o el peso de una persona, la temperatura de un día, una distancia recorrida, etc.\n\n0.1 + 0.2\n\n0.30000000000000004\n\n\nComo vemos, cuando hay números de punto flotante, el resultado es aproximado. 0.1 + 0.2 nos debería dar 0.3, pero nos da 0.30000000000000004. Esto es porque los números de punto flotante son aproximados, y no pueden representar todos los valores de forma exacta. Esto es algo que vamos a tener que tener en cuenta cuando trabajemos con números de punto flotante.\n\n\n\n\n\n\nUso de punto\n\n\n\nNotemos que para representar números de punto flotante, usamos el punto (.) y no la coma (,). Esto es porque en Python, la coma se usa para separar valores, como vamos a ver más adelante.\n\n\nAdemás de efectuar operaciones matemáticas, Python nos permite trabajar con porciones de texto, que se llaman cadenas (o strings en inglés). Las cadenas se representan con el tipo str.\nLas cadenas se escriben entre comillas simples (') o dobles (\").\n\nprint( \"¡Hola!\" )\n\n¡Hola!\n\n\n\nprint( '¡Hola!' )\n\n¡Hola!\n\n\nLas cadenas también tienen operaciones disponibles, como por ejemplo la concatenación, que es la unión de dos cadenas en una sola. Esto se hace con el operador +.\n\nprint( \"¡Hola!\" + \" ¿Cómo estás?\" )\n\n¡Hola! ¿Cómo estás?\n\n\nVamos a ver más de estas operaciones más adelante.\n\n\n2.1.3 Variables\nPython nos permite asignarle un nombre a un valor, de forma tal que podamos “recordarlo” y usarlo más adelante. A esto se le llama asignación.\nEstos nombres se llaman variables, y son espacios donde podemos almacenar valores.\n\nLa asignación se hace con el operador = de la siguiente forma: &lt;nombre&gt; = &lt;valor o expresion&gt;.\nEjemplos:\n\nx = 5\n\n\ny = x + 2\n\n\nprint(y)\n\n7\n\n\n\nprint(y * 2)\n\n14\n\n\n\nlenguaje = \"Python\"\n\ntexto = \"Estoy programando en \" + lenguaje\nprint(texto)\n\nEstoy programando en Python\n\n\nEn este ejemplo, creamos las siguientes variables:\n\nx\ny\nlenguaje\ntexto\n\ny las asociamos a los valores 5, 7, “Python” y “Estoy programando en Python” respectivamente. Luego podemos usar esas variables como parte de cualquier expresión, y en el momento de evaluarla, Python reemplazará las variables por su valor asociado.\n\n\n\n\n\n\nVariables y Constantes\n\n\n\nSi el dato es inmutable (no puede cambiar) durante la ejecución del programa, se dice que ese dato es una constante. Si tiene la habilidad de cambiar, se dice que es una variable. En Python, todas las variables son mutables, es decir, pueden cambiar su valor durante la ejecución del programa.\nY no sólo pueden cambiar su valor, sino también su tipo: x = 5 y x = \"Hola\" son dos asignaciones válidas, y se pueden hacer una debajo de la otra:\n\nx = 5\nx = \"Hola\"\nprint(x)\n\nHola\n\n\n\n\n\n\n\n\n\n\nNombres de Variables\n\n\n\nNo se puede usar el mismo nombre para dos datos diferentes a la vez; una variable puede referenciar un sólo dato por vez. Si se usa un mismo nombre para un dato diferente, se pierde la referencia al dato anterior.\n\n\n\n\n\n2.1.4 Funciones\nPara poder realizar algunas operaciones particulares, necesitamos introducir el concepto de función. Una función es un bloque de código que se ejecuta cuando se la llama.\nEs un fragmento de programa que permite efectuar una operación determinada. abs, print, max son ejemplos de funciones de Python: abspermite calcular el valor absoluto de un número, print permite mostrar un valor por pantalla y max permite calcular el máximo entre dos valores.\n\nUna función puede recibir 0 o más parámetros o argumentos, que son valores que se le pasan a la función entre paréntesis y separados por comas, para que los use.\n\n\nabs(-5)\n\n5\n\n\n\nprint(\"¡Hola!\")\n\n¡Hola!\n\n\n\nmax(5, 7)\n\n7\n\n\nLa función recibe los parámetros, efectúa una operación y devuelve un resultado.\nPython viene equipado de muchas funciones predefinidas, pero nosotros como programadores debemos ser capaces de escribir nuevas instrucciones para la computadora. Las grandes aplicaciones como el correo electrónico, navegación web, chat, juegos, etc. no son más que grandes programas implementados introduciendo nuevas funciones a la máquina, escritas por uno o más programadores.\n\n\n\nUna función recibe parámetros y devuelve un resultado\n\n\n\n\n\n\n\n\nPython es Case Sensitive\n\n\n\nPython es Case Sensitive, es decir, distingue entre mayúsculas y minúsculas.\nEs muy importante respetar mayúsculas y minúsculas: PRINT() o prINT() no serán reconocidas. Esto aplica para todo lo que escribamos en nuestros programas.\n\n\nSi queremos crear una función que nos devuelva un saludo a Lucia cada vez que se la llama, debemos ingresar el siguiente conjunto de líneas en Python:\n\ndef saludar_lucia():\n  return \"Hola, Lucia!\"\n\nVarias cosas a notar del código:\n\nsaludar_lucia es el nombre de la función. Podría ser cualquier otro nombre, pero es una buena práctica que el nombre de la función describa lo que hace.\n\ndef es una palabra clave que indica que estamos definiendo una función.\n\nreturn indica el valor que devuelve la función. Es decir, el resultado. Puede devolverse una sola cosa, como en este caso, o varias cosas separadas por comas.\n\nLa sangría (el espacio inicial) en el renglón 2 le indica a Python que estamos dentro del cuerpo de la función. El cuerpo de la función es el bloque de código que se ejecuta cuando se llama a la misma.\n\n\n\n\n\n\n\n\nSangría\n\n\n\nLa sangría puede ingresarse utilizando dos o más espacios, o presionando la tecla Tab. Es importante prestar atención en no mezclar espacios con tabs, para evitar “confundir” al intérprete.\n\n\n\n\n\n\n\n\nFirma de la función\n\n\n\nLa firma de una función es la primera línea de la misma, donde se indica el nombre de la función y los parámetros que recibe. La firma permite identificar y diferenciar a una función de otra.\n\n\nPero, como vemos, el bloque de código anterior no hace nada. Para que la función haga algo, tenemos que llamarla. Para llamar a una función, escribimos su nombre, seguido de paréntesis y los parámetros que recibe, separados por comas.\nsaludar_lucia()\nSe dice que estamos invocando o llamando a la función. Y al invocar una función, se ejecutan las instrucciones que habíamos escrito en su cuerpo.\n\nPero de nuevo, vemos que no pasa nada. ¿Por qué? Porque la función usa return para devolver un valor. Pero nosotros no estamos haciendo nada con ese valor. Para poder verlo, tenemos que imprimirlo por pantalla.\n\nsaludo = saludar_lucia()\nprint(saludo)\n\nHola, Lucia!\n\n\nLo que hicimos fue asignar el resultado devuelto por saludar_lucia a la variable saludo, y luego imprimir el valor de la variable por pantalla.\nBueno, ahora podemos saludar a Lucia. Pero vamos a querer saludar a otras personas también. ¿Cómo hacemos? Podemos hacer una función que reciba el nombre de la persona a saludar como parámetro.\n\ndef saludar(nombre):\n  return \"Hola, \" + nombre + \"!\"\n\nDe esta forma, podemos saludar a cualquier persona, pasando su nombre como parámetro.\n\n# Esta es otra forma de imprimir, sin necesidad de guardarnos\n# el resultado de la función en una variable,\n# simplemente la imprimimos\nprint(saludar(\"Lucia\"))\n\nHola, Lucia!\n\n\n\nprint(saludar(\"Serena\"))\n\nHola, Serena!\n\n\n\n2.1.4.1 Ejemplos\n\nEjemplo\nEscribir una función que calcule el doble de un número.\n\n\ndef obtener_doble(numero):\n  return numero * 2\n\nPara invocarla, debemos llamarla pasándole un número:\n\ndoble = obtener_doble(5)\nprint(doble)\n\n10\n\n\n\nEjemplo\nPensá un número, duplícalo, súmale 6, divídelo por 2 y resta el número que elegiste al comienzo. El número que queda es siempre 3.\n\n\ndef f(numero):\n  return ((numero * 2) + 6) / 2 - numero\n\n\nprint(f(5))\n\n3.0\n\n\n\n\n\n2.1.5 Ingreso de Datos por Consola\nHasta ahora, los programas que hicimos no interactuaban con el usuario. Pero para que nuestros programas sean más útiles, vamos a querer que el usuario pueda ingresar datos, y que el programa pueda mostrarle datos por pantalla. Para esto, vamos a usar la función input.\ninput()\nInput es una función que bloquea el flujo del programa, esperando a que el usuario ingrese una entrada por consola y presione enter. Cuando el usuario presiona enter, la función devuelve el valor ingresado por el usuario.\n\ninput()\nprint(\"terminé!\")\nSi corremos el bloque de código anterior, vamos a tener un comportamiento como este:\n\nLa consola va a quedar vacía, esperando el ingreso del usuario\nIngresamos un valor, el que tengamos ganas, y presionamos enter.\nLa consola muestra el mensaje “terminé!”.\n\n\n\n\nInput bloquea el flujo del programa\n\n\n\n\n\nIngresamos un valor (puede ser un número, texto, o ambos)\n\n\n\n\n\nAl presionar Enter, la consola muestra el mensaje “terminé!”\n\n\n\n2.1.5.1 Obteniendo el Valor Ingresado\nComo dijimos más arriba, la función input devuelve el valor ingresado por el usuario. Para poder usarlo, tenemos que guardarlo en una variable.\nnombre = input()\nprint(\"Hola, \" + nombre + \"!\")\n\n\n\nIngresamos “Mariana” y presionamos Enter.\n\n\nPara hacer nuestro programa más amigable, podemos mostrarle al usuario un mensaje antes de pedirle que ingrese un valor. Para esto, podemos pasarle un parámetro a la función input, que es el mensaje que queremos mostrarle al usuario.\nnombre = input(\"Ingresá tu nombre: \")\nprint(\"Hola, \" + nombre + \"!\")\n\n\n\nIngresamos “Mariana” y presionamos Enter.\n\n\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nA partir de la guía 2, a menos que el ejercicio diga específicamente “pedirle al usuario”, no se debe usar input, sino que todo tiene que recibirse por parámetro en la función.\nLo mismo con print: A menos que el ejercicio diga específicamente “imprimir”, todo siempre se tiene que devolver con un return."
  },
  {
    "objectID": "unidad_2.html#buenas-prácticas-de-programación",
    "href": "unidad_2.html#buenas-prácticas-de-programación",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.2 Buenas Prácticas de programación",
    "text": "2.2 Buenas Prácticas de programación\n\n2.2.1 Sobre Comentarios\nLos comentarios son líneas que se escriben en el código, pero que no se ejecutan. Sirven para que el programador pueda dejar notas en el código, para que se entienda mejor qué hace el programa.\nLos comentarios se escriben con el símbolo #. Todo lo que esté a la derecha del # no se ejecuta. También se pueden encerrar entre tres comillas dobles (\"\"\") para escribir comentarios de varias líneas.\n# Esto es un comentario\n\n\"\"\" Esto es un comentario\nde varias líneas \"\"\"\nNo es correcto escribir comentarios que no aporten nada al código, o tener el código absolutamente plagado de comentarios. Los comentarios deben ser útiles, y deben aportar información que no se pueda inferir del código. Nuestro primer intento de hacer el código más entendible no tienen que ser los comentarios, sino mejorar el código en sí.\n\n\n2.2.2 Sobre Convención de Nombres\nPara nombres de variables y funciones, se usa snake_case, que es básicamente dejar todas las palabras en minúscula y unirlas con un guión bajo. Ejemplos: numero_positivo, sumar_cinco, pedir_numero, etc.  Siempre emplear un nombre que nos remita al significado que tendrá ese dato, siempre en snake_case: numero, letra, letra2, edad_hermano, etc.\n\n2.2.2.1 Variables\nLas variables son cosas. Entonces sus nombres son sustantivos: nombre, numero, suma, resta, resultado, respuesta_usuario. La única excepción son las variables booleanas (ya las vamos a ver, son aquellas que pueden guardar dos posibles valores: verdadero o falso), que suelen tener nombres como es_par, es_cero, es_entero, porque su valor es true o false.\nA veces es útil alguna frase para identificar mejor el contenido:\nedad_mayor_hijo, apellido_conyuge\n\n\n2.2.2.2 Funciones\nLas funciones hacen algo. Entonces sus nombres son verbos. Se usan siempre verbos en infinitivo (terminan en -ar, -er, -ir): calcular_suma, imprimir_mensaje, correr_prueba, obtener_triplicado, etc.\nDe nuevo, las excepciones son las funciones que devuelven un valor booleano (V o F). Esas pueden llamarse como: es_par, da_cero, tiene_letra_a, porque devuelven verdadero o falso, y eso nos confirma o niega la afirmación que hace el nombre.\n\n\n\n2.2.3 Sobre Ordenamiento de Código\nCuando uno corre Python, lo que hace el lenguaje es leer línea a línea nuestro código. Lo que se puede ejecutar, lo ejecuta. Las funciones las guarda en memoria para poder usarlas luego.\nEntonces es más ordenado y prolijo primero poner todas las funciones, y después el código “ejecutable” (si van a dejar código suelto en el archivo).\n\nAdemás, no olvidemos que Python tiene un flujo de control de arriba para abajo. Si intentamos invocar funciones antes de que estén definidas (def), Python no va a saber qué hacer, y nos va a tirar un error.\n\nEsto es correcto: \nEsto es incorrecto: \n\n\n2.2.4 Sobre uso de Parámetros en Funciones\nUna función se puede pensar como una caja cerrada o una fábrica. La función tiene dos puertas: una de entrada y una de salida.\nLa puerta de entrada son los parámetros y la de salida es el output (el resultado).\n\n\n\nCuando se llama o invoca a la función, la puerta de entrada se abre, permitiéndonos enviarle (pasarle) cero, uno o más parámetros a la función (según cómo esté definida). Los parámetros son datos que la función necesida para funcionar, y como ya dijimos, se le pasan a la misma entre los paréntesis de la llamada.\n\n\nEjemplo: saludar(nombre), imprimir_elementos(lista), sumar(numero1, numero2), etc.\n\n\n\n\nUna vez que la función se empieza a ejecutar, ambas puertas se cierran. Esto quiere decir que, mientras la función se está ejecutando, nada entra y nada sale de la misma.\nLa función debería trabajar únicamente con los datos que se le hayan pasado por parámetro o que se le pidan al usuario dentro de ella, pero no debería utilizar nada que esté por fuera de la misma.\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nPython nos deja usar cosas por fuera de la función y sin recibir los datos por parámetro, porque es un lenguaje muy benevolente. Pero está mal usar cosas que no se hayan recibido por parámetro: es una mala práctica.\n\n\n\n\n\nUna vez que la función terminó de ejecutarse, el o los valores de salida (resultados) se devuelven por el output. Una función puede retornar uno o más elementos, o podría simplemente no retornar nada.\nreturn suma, return numero1, numero2, return, etc.\n\n\n\nPodemos ver la diferencia entre enviar algo por parámetro y usarlo por fuera de la función a continuación:\n\n\n\n\nEsto está mal\n\n\nEsto está bien\n\n\n\n\ndef saludar():\n  print(\"Hola, \" + nombre + \"!\")\n\nnombre = \"Manuela\"\nsaludar()\n\n\ndef saludar(persona):\n  print(\"Hola, \" + persona + \"!\")\n\nnombre = \"Manuela\"\nsaludar(nombre)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nComo podemos observar los nombres de los argumentos cuando se invoca y en la definición de la firma pueden ser los mismos o distintos. En este caso, la función sabe que está recibiendo algo como parámetro, y sabe que dentro de su cuerpo a este dato lo va a identificar como persona, pero no hace falta que la variable que nosotros le pasamos como parámetro también se llame persona: en este caso se llama nombre."
  },
  {
    "objectID": "unidad_2.html#tipos-de-datos",
    "href": "unidad_2.html#tipos-de-datos",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.3 Tipos de Datos",
    "text": "2.3 Tipos de Datos\n\n2.3.1 Datos Simples\nLos programas trabajan con una gran variedad de datos. Los datos más simples son los que ya vimos: números enteros, números de punto flotante y cadenas.\nPero dependiendo de la naturaleza o el tipo de información, cabrá la posibilidad de realizar distintas transformaciones aplicando operadores. Por eso, a la hora de representar información no sólo es importante que identifiquemos al dato y podamos conocer su valor, sino saber qué tipo de tratamiento podemos darle.\nTodos los lenguajes tienen tipos predefinidos de datos. Se llaman predefinidos porque el lenguaje ya los conoce: sabe cómo guardarlos en memoria y qué transformaciones puede aplicarles.\nEn Python, tenemos los siguientes tipos de datos:\n\n\n\n\n\n\n\n\nTipo\nDescripción\nEjemplo\n\n\n\n\nint\nNúmeros enteros\n5, 0, -5, 10000\n\n\nfloat\nNúmeros de punto flotante o reales\n3.14159, 1.0, 0.0\n\n\ncomplex\nNúmeros complejos\n(1, 2j), (1.0,-2.0j), (0,1j). La componente con j es la parte imaginaria.\n\n\nbool\nValores booleanos o valores lógicos\nTrue, False\n\n\nstr\nCadenas de caracteres\n\"Hola\", \"Python\", \"¡Hola, mundo!\", \"\" (cadena vacía, no contiene ningún caracter)\n\n\n\n\n\n\n\n\n\n¿Por qué se llaman “cadenas de caracteres”?\n\n\n\nPorque son una cadena de caracteres, es decir, una secuencia de caracteres. Por ejemplo, la cadena “Hola” está formada por los caracteres “H”, “o”, “l” y “a”. Esto nos permite acceder a cada uno de los caracteres de la cadena por separado si quisiéramos, o a porciones de una cadena, como vamos a ver más adelante.\nMás aún, podemos ver que el texto “hola” no será igual a “aloh” ni a “Holá”, porque son cadenas distintas.\nUn string permite almacenar cualquier tipo de caracter unicode dentro (letras, números, símbolos, emojis, etc.).\n\n\n\n\n2.3.2 Operadores Numéricos\nLos operadores son símbolos que representan una operación. Por ejemplo, el operador + representa la suma.\n\nPara transformar datos numéricos, emplearemos los siguientes operadores:\n\n\n\nSímbolo\nDefinición\nEjemplo\n\n\n\n\n+\nSuma\n5 + 3\n\n\n-\nResta\n5 - 3\n\n\n*\nProducto\n5 * 3\n\n\n**\nPotencia\n5 ** 2\n\n\n/\nDivisión\n5 / 3\n\n\n//\nDivisión entera\n5 // 3\n\n\n%\nMódulo o Resto\n5 % 3\n\n\n+=\nSuma abreviada\nx = 0x += 3\n\n\n-=\nResta abreviada\nx = 0x -= 3\n\n\n*=\nProducto abreviado\nx = 0x *= 3\n\n\n/=\nDivisión abreviada\nx = 0x /= 3\n\n\n//=\nDivisión entera abreviada\nx = 0x //= 3\n\n\n%=\nMódulo o Resto abreviado\nx = 0x %= 3\n\n\n\nComo pasa en matemática, para alterar cualquier precedencia (prioridad de operadores) se pueden usar paréntesis.\n\n(5 + 3) * 2\n\n16\n\n\n\n5 + (3 * 2)\n\n11\n\n\nEl orden de prioridad de ejecución para los operadores va a ser el mismo que en matemática.\n\n\n2.3.3 Operadores de Texto\nPara transformar datos de texto, emplearemos los siguientes operadores:\n\n\n\n\n\n\n\n\nSímbolo\nDefinición\nEjemplo\n\n\n\n\n+\nConcatenación\n\"Hola\" + \" \" + \"Mundo\"\n\n\n*\nRepetición\n\"Hola\" * 3\n\n\n+=\nConcatenación abreviada\nx = \"Hola\"x += \" Mundo\"\n\n\n*=\nRepetición abreviada\nx = \"Hola\"x *= 3\n\n\n[k] o [-k]\nAcceso a un caracter\n\"Hola\"[0]\"Hola\"[-1]\n\n\n[k1:k2]\nAcceso a una porción\n\"Hola\"[0:2]\"Hola\"[1:]\"Hola\"[:2]\"Hola\"[:]\n\n\n\nDe nuevo, para alterar precedencias, se deben usar ().\n\n2.3.3.1 Manipulando Strings\nSi bien esto se va a ahondar en la siguiente sesión de la materia, es importante saber que los strings, como se dijo más arriba, son un conjunto de caracteres. Pero no sólo un conjunto, sino un conjunto ordenado. Esto quiere decir que cada caracter tiene una posición dentro de la cadena, y que esa posición es importante.\n\nPor ejemplo, la cadena \"Hola\" tiene 4 caracteres: \"H\", \"o\", \"l\" y \"a\".\nLa posición de cada caracter es la siguiente:\n\n\n\nPosición\n0\n1\n2\n3\n\n\n\n\nCaracter\n“H”\n“o”\n“l”\n“a”\n\n\n\nEntonces, si queremos acceder al caracter \"H\", tenemos que usar la posición 0. Si queremos acceder al caracter \"a\", tenemos que usar la posición 3.\n\n\n\n\n\n\n\nTip\n\n\n\nPara acceder a un caracter de una cadena, usamos los corchetes ([]) y dentro de ellos la posición del caracter que queremos acceder.\n\n\n\n\nletra = \"Hola\"[0]\nprint(letra)\n\nH\n\n\nPero no sólo puedo obtener los caracteres en las posicione de la palabra, sino que puedo obtener slices o porciones de la misma, usando algo que vemos por primera vez: los rangos.\nUn rango tiene tres partes:\n[start : end : step]\n\nstart es el índice de inicio del rango. Si no se especifica, se toma el índice 0. El caracter en la posición de inicio siempre se incluye.\nend es el índice de fin del rango. Si no se especifica, se toma el índice final de la cadena. El caracter en la posición de fin nunca se incluye.\nstep es el tamaño del paso. Si no se especifica, se toma el valor 1.\n\n\nEjemplos:\n\n\n\n\n\n\n\n\n2.3.4 Input y Casteo\nCuando usamos la función input, el valor que devuelve es siempre una cadena. Esto es porque el usuario puede ingresar cualquier cosa, y no sabemos qué tipo de dato es.\n\nPor ejemplo, si le pedimos al usuario que ingrese un número, el usuario puede ingresar un número entero, un número de punto flotante, un número complejo, o incluso un texto. Entonces, el valor que devuelve input es siempre una cadena, y nosotros tenemos que transformarla al tipo de dato que necesitemos.\n\nPor ejemplo:\nedad = input(\"Indique su edad:\")\nprint(\"Su edad es:\", edad_nueva)\n\n\n\n\n\n\nImprimiendo Strings y Variables (Iterpolación de Cadenas)\n\n\n\nExisten muchas formas de concatenar variables con texto.\n\nUsando el operador +: \"Su edad es: \" + edad\nUsando el método fstring: f\"Su edad es: {edad}\"\nUsando el caracter ,: print(\"Su edad es:\", edad)\n\nLa forma más recomendada es la segunda, usando fstring. Pero dependerá de cada caso.\n\n\nEl problema es que, si bien nuestro código anterior funciona, no podemos operar edad como si fuese un número, porque es un string.\nEl siguiente código va a fallar:\nedad = input(\"Indique su edad:\")\nedad_nueva = edad + 1\nprint(\"Edad siguiente:\", edad_nueva)\n\n\n\nEjecución del bloque de código\n\n\nComo vemos, la consola nos arroja un error, o en términos simples decimos que “explotó”.\n\n\n\n\n\n\n¿Qué es un error?\n\n\n\nLos errores son información que nos da la consola para que podamos corregir nuestro código.\n\n\nEn este caso, nos dice que no se puede concatenar un string con un int.\n¿Por qué nos dice eso? Porque edad es un string: \"25\", y estamos tratando de sumarle 1, que es un int: 1.\n\nPara poder operar con edad como si fuese un número, tenemos que transformarla a un número. Esto se llama castear.\n\nPara castear un valor a un tipo de dato, usamos el nombre del tipo de dato, seguido de paréntesis y el valor que queremos castear.\nint(\"25\")\nDe esta forma, podemos modificar nuestro código anterior:\nedad = int(input(\"Indique su edad:\")) # Le agregamos int\nedad_nueva = edad + 1\nprint(\"Edad siguiente:\", edad_nueva)\nY obtenemos un código que funciona correctamente.\n\n\n\nEjecución del bloque de código\n\n\nDe esta forma, podemos castear a varios tipos de datos:\nnumero_entero = int(input(\"Ingrese un número\"))\npunto_flotante = float(input(\"Ingrese un número\"))\n\npunto_flotante2 = float(numero_entero)\n\nnumero_en_str = str(numero_entero)\nEjemplo:\nnombre_menor = input('Ingresá el nombre de un conocido/a:')\nedad_menor = int(input(f'Ingresá la edad de { nombre_menor } '))\nnombre_mayor = input(f'Cómo se llama el hermano/a mayor de {nombre_menor}? ')\ndiferencia = int(input(f'Cuántos años más grande es {nombre_mayor}?  '))\n\nedad_mayor = edad_menor + diferencia\n\nprint(nombre_menor,'tiene',edad_menor,'años')\nprint(nombre_mayor,'es mayor y tiene', edad_mayor, 'años')\n\n\n\nEjecución del bloque de código"
  },
  {
    "objectID": "unidad_2.html#bonus-track-algunas-funciones-predefinidas-de-python",
    "href": "unidad_2.html#bonus-track-algunas-funciones-predefinidas-de-python",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.4 Bonus Track: Algunas Funciones Predefinidas de Python",
    "text": "2.4 Bonus Track: Algunas Funciones Predefinidas de Python\n\n\n\n\n\n\nRecomendación\n\n\n\nTe recomendamos que te animes a probar estas funciones, para ver qué hacen y terminar de entenderlas.\n\n\n\n\n\n\n\n\n\n\nFunción\nDefinición\nEjemplo de uso\n\n\n\n\nprint()\nImprime un mensaje o valor en la consola\nprint(\"Hello, world!\")\n\n\ninput()\nLee una entrada de texto desde el usuario\nname = input(\"Enter your name: \")\n\n\nabs()\nDevuelve el valor absoluto de un número\nabs(-5)\n\n\nround()\nRedondea un número al entero más cercano\nround(3.7)\n\n\nint()\nConvierte un valor en un entero\nx = int(\"5\")\n\n\nfloat()\nConvierte un valor en un número de punto flotante\ny = float(\"3.14\")\n\n\nstr()\nConvierte un valor en una cadena de texto\nmessage = str(42)\n\n\nbool()\nConvierte un valor en un booleano\nis_valid = bool(1)\n\n\nlen()\nDevuelve la longitud (número de elementos) de un objeto\nlength = len(\"Hello\")\n\n\nmax()\nDevuelve el valor máximo entre varios elementos o una secuencia\nmax(4, 9, 2)\n\n\nmin()\nDevuelve el valor mínimo entre varios elementos o una secuencia\nmin(4, 9, 2)\n\n\npow()\nCalcula la potencia de un número\nresult = pow(2, 3)\n\n\nrange()\nGenera una secuencia de números\nnumbers = range(1, 5)\n\n\ntype()\nDevuelve el tipo de un objeto\ndata_type = type(\"Hello\")\n\n\nround()\nRedondea un número a un número de decimales específico\nrounded_num = round(3.14159, 2)\n\n\nisinstance()\nVerifica si un objeto es una instancia de una clase específica\nis_instance = isinstance(5, int)\n\n\nreplace()\nReemplaza todas las apariciones de un substring por otro\ntext = \"Hello, World!\"new_text = text.replace(\"Hello\", \"Hi\")\n\n\neval(&lt;expr&gt;)\nEvalúa una expresión\neval(\"2 + 2\")"
  },
  {
    "objectID": "unidad_3.html#decisiones",
    "href": "unidad_3.html#decisiones",
    "title": "3  Estructuras de Control",
    "section": "3.1 Decisiones",
    "text": "3.1 Decisiones\n\nEjemplo Leer un número y, si el número es positivo, imprimir en pantalla “Número positivo”.\n\nNecesitamos decidir de alguna forma si nuestro número \\(x\\) es positivo (&gt;0) o no. Para resolver este problema, introducimos una nueva instrucción, llamada condicional: if.\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nDonde if es una palabra reservada, &lt;expresion&gt; es una condición y &lt;cuerpo es un bloque de código que se ejecuta sólo si la condición es verdadera.\nPor lo tanto, antes de seguir explicando sobre la instrucción if, debemos entender qué es una condición. Estas expresiones tendrán valores del tipo sí o no.\n\n3.1.1 Expresiones Booleanas\nLas expresiones booleanas forman parte de la lógica binomial, es decir, sólo pueden tener dos valores: True o False. Estos valores no tienen elementos en común, por lo que no se pueden comparar entre sí. Por ejemplo, True &gt; False no tiene sentido. Y además, son complementarios: algo que no es True, es False; y algo que no es False, es True. Son las únicas dos opciones posibles.\nPython, además de los tipos numéricos como inty float, y de las cadenas de caracteres str, tiene un tipo de datos llamado bool. Este tipo de datos sólo puede tener dos valores: True o False. Por ejemplo:\nn = 3 # n es de tipo 'int' y tiene valor 3\nb = True # b es de tipo 'bool' y tiene valor True\n\n\n3.1.2 Expresiones de Comparación\nLas expresiones booleanas se pueden construir usando los operadores de comparación: sirven para comparar valores entre sí, y permiten construir una pregunta en forma de código.\nPor ejemplo, si quisiéramos saber si 5 es mayor a 3, podemos construir la expresión:\n\n5 &gt; 3\n\nTrue\n\n\nComo 5 es en efecto mayor a 3, esta expresión, al ser evaluada, nos devuelve el valor True.\nSi quisiéramos saber si 5 es menor a 3, podemos construir la expresión:\n\n5 &lt; 3\n\nFalse\n\n\nComo 5 no es menor a 3, esta expresión, al ser evaluada, nos devuelve el valor False.\nLas expresiones booleanas de comparación que ofrece Python son:\n\n\n\nExpresión\nSignificado\n\n\n\n\na == b\na es igual a b\n\n\na != b\na es distinto de b\n\n\na &lt; b\na es menor que b\n\n\na &gt; b\na es mayor que b\n\n\na &lt;= b\na es menor o igual que b\n\n\na &gt;= b\na es mayor o igual que b\n\n\n\nVeamos algunos ejemplos:\n5 == 5\n\n5 != 5\n\n5 &lt; 5\n\n5 &gt;= 5\n\n5 &gt; 4\n\n5 &lt;= 4\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos probar estas expresiones para ver qué valores devuelven. Podés hacerlo de dos formas:\n\nGuardando el resultado de la expresión en una variable, para luego imprimirla:\n\nresultado = 5 == 5\nprint(resultado)\n\nImprimiendo directamente el resultado de la expresión:\n\nprint(5 == 5)\n\n\n\n\n3.1.3 Operadores Lógicos\nAdemás de los operadores de comparación, Python también tiene operadores lógicos, que permiten combinar expresiones booleanas para construir expresiones más complejas. Por ejemplo, quizás no sólo queremos saber si 5 es mayor a 3, sino que también queremos saber si 5 es menor que 10. Para esto, podemos usar el operador and:\n5 &gt; 3 and 5 &lt; 10\nPython tiene tres operadores lógicos: and, or y not. Veamos qué hacen:\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\na and b\nEl resultado es Truesolamente si aes Truey bes True. Ambos deben ser True, de lo contrario devuelve False.\n\n\na or b\nEl resultado es Truesi aes True o bes True (o ambos). Si ambos son False, devuelve False.\n\n\nnot a\nEl resultado es True si aes False, y viceversa.\n\n\n\nAlgunos ejemplos:\n\n5 &gt; 2 and 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 or 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 and 5 &gt; 6\n\nFalse\n\n\n\n5 &gt; 2 or 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 6\n\nFalse\n\n\n\nnot 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 2\n\nTrue\n\n\n\nnot 5 &gt; 2\n\nFalse\n\n\n\n\n\n\n\n\nPrioridad de Operadores\n\n\n\n\n\nLas expresiones lógicas complejas (con más de un operador), se resuelven al igual que en matemáticas: respetando precedencias y de izquierda a derecha. También admiten el uso de () para alterar las precedencias.\nSin embargo, si no tenemos precedencias explícitas con (), Python prioriza resolver primero los and, luego los or y por último los not.\nEjemplos:\n\nTrue or False and False\n\nTrue\n\n\nPor la prioridad del and, primero se resuelve False and False, que da False. Luego, se resuelve True or False, que da True.\n\nTrue or False or False\n\nTrue\n\n\nComo no hay and, se resuelve de izquierda a derecha. Primero se resuelve True or False, que da True. Luego, se resuelve True or False, que da True.\n\n(True or False) and False\n\nFalse\n\n\nComo hay paréntesis, se resuelve primero lo que está dentro de los paréntesis. True or False da True. Luego, True and False da False.\n\n\n\n\n\n3.1.4 Comparaciones Simples\nVolvamos al problema inicial: Queremos saber, dado un número \\(x\\), si es positivo o no, e imprimir un mensaje en consecuencia.\nRecordemos la instrucción if que acabamos de introducir y que sirve para tomar decisiones simples. Esta instrucción tiene la siguiente estructura:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\ndonde:\n\n&lt;expresion&gt;debe ser una expresión lógica.\n&lt;cuerpo&gt;es un bloque de código que se ejecuta sólo si la expresión es verdadera.\n\n\n\n\nDiagrama de Flujo para la instrucción if\n\n\nComo ahora ya sabemos cómo construir condiciones de comparación, vamos a comparar si nuestro número x es mayor a 0:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n\nPodemos probarlo:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\n\n\nComo vemos, si el número es positivo, se imprime el mensaje. Pero si el número no es positivo, no se imprime nada. Necesitamos además agregar un mensaje “Número no positivo”, si es que la condición no se cumple.\nModifiquemos el diseño: 1. Si \\(x&gt;0\\), se imprime “Número positivo”. 2. En caso contrario, se imprime “Número no positivo”.\nPodríamos probar con el siguiente código:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if not x &gt; 0:\n      print(\"Número no positivo\")\n\nOtra solución posible es:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if x &lt;= 0:\n      print(\"Número no positivo\")\n\nAmbas están bien. Si lo probamos, vemos que funciona:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\nSin embargo, hay una mejor forma de hacer esta función. Existe una condición alternativa para la estructura de decisión if, que tiene la forma:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nelse:\n    &lt;cuerpo&gt;\ndonde if y else son palabras reservadas. Su efecto es el siguiente:\n\nSe evalúa la &lt;expresion&gt;.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\nDiagrama de Flujo para la instrucción if-else\n\n\nPor lo tanto, podemos reescribir nuestra función de la siguiente forma:\n\ndef imprimir_si_positivo_o_no(x): # le cambiamos el nombre\n  if x &gt; 0:\n      print(\"Número positivo\")\n  else:\n      print(\"Número no positivo\")\n\nProbemos:\n\nimprimir_si_positivo_o_no(5)\nimprimir_si_positivo_o_no(-5)\nimprimir_si_positivo_o_no(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\n¡Sigue funcionando!\nLo importante a destacar es que, si la condición del if es verdadera, se ejecuta el &lt;cuerpo&gt; del if y no se ejecuta el &lt;cuerpo&gt; del else. Y viceversa: si la condición del if es falsa, se ejecuta el &lt;cuerpo&gt; del else y no se ejecuta el &lt;cuerpo&gt; del if. Nunca se ejecutan ambos casos, porque son caminos paralelos que no se cruzan, como vimos en el diagrama de flujo más arriba.\n\n\n3.1.5 Múltiples decisiones consecutivas.\nSupongamos que ahora queremos imprimir un mensaje distinto si el número es positivo, negativo o cero. Podríamos hacerlo con dos decisiones consecutivas:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\") # cuerpo del primer if\n  else:\n      if x == 0:                      #\n          print(\"Número cero\")        #\n      else:                           #\n          print(\"Número negativo\")    # todo esto es el cuerpo del primer else\n\nA esto se le llama anidar, y es donde dentro de unas ramas de la decisión (en este caso, la del else), se anida una nueva decisión. Pero no es la única forma de implementarlo. Podríamos hacerlo de la siguiente forma:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  elif x == 0:\n      print(\"Número cero\")\n  else:\n      print(\"Número negativo\")\n\nLa estructura elif es una abreviatura de else if. Es decir, es un else que tiene una condición. Su efecto es el siguiente:\n\n\n\nDiagrama de Flujo para la instrucción if-elif-else del ejemplo\n\n\n\nSe evalúa la &lt;expresion&gt; del if.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se evalúa la &lt;expresion&gt; del elif.\nSi la &lt;expresion&gt; del elif es verdadera, se ejecuta su &lt;cuerpo&gt;.\nSi la &lt;expresion&gt; del elif es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\n\n\n\nSabías que… ?\n\n\n\n\n\nEn Python se consideran verdaderos (True) también todos los valores numéricos distintos de 0, las cadenas de caracteres que no sean vacías, y cualquier valor que no sea vacío en general. Los valores nulos o vacíos son falsos.\nif x == 0:\nes equivalente a:\nif not x:\nY además, existe el valor especial None, que representa la ausencia de valor, y es considerado falso. Podemos preguntar si una variable tiene el valor None usando el operador is:\nif x is None:\no también:\nif not x:\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nDebemos calcular el pago de una persona empleada en nuestra empresa. El cálculo debe hacerse por la cantidad de horas trabajadas, y se le debe pedir al usuario la cantidad de horas y cuánto vale cada hora.\nAdicionalmente, se abona un plus fijo de guardería a todo empleado/a con infantes a su cargo. Y se paga un 10% de incentivo a todo empleado/a que haya trabajado 30 horas o más y no reciba el plus por guardería.\n\nPista: pensar los distintos tipos de liquidación:\na) Empleado/a con menos de 30 horas y sin infantes a cargo.\nb) Empleado/a con 30 horas o más y sin infantes a cargo.\nc) Empleado/a con menos de 30 horas y con infantes a cargo.\nd) Empleado/a con 30 horas o más y con infantes a cargo.\n\n\n\n\n\n\nAyuda: Flujo de la resolución\n\n\n\n\n\n\n\n\nDiagrama de Flujo para el desafío"
  },
  {
    "objectID": "unidad_3.html#ciclos-y-rangos",
    "href": "unidad_3.html#ciclos-y-rangos",
    "title": "3  Estructuras de Control",
    "section": "3.2 Ciclos y Rangos",
    "text": "3.2 Ciclos y Rangos\nSupongamos que en una fábrica se nos pide hacer un procedimiento para entrenar al personal nuevo. Para comenzar se nos encarga la descripción de uno muy simple: descarga de cajas de material del camión del proveedor y almacenamiento en el depósito. Así que aplicamos lo que venimos aprendiendo hasta ahora sobre algoritmos y describimos la operación para la descarga de 3 cajas:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte\n\n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Colocar la caja sobre el piso en el sector correspondiente \n7 Ir al garage o playón donde estacionó el camión\n\n8 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n9 Caminar sosteniendo la caja hasta el depósito \n10 Colocar la caja sobre la caja anterior \n11 Ir al garage o playón donde estacionó el camión\n\n12 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n13 Caminar sosteniendo la caja hasta el depósito \n14 Colocar la caja sobre la caja anterior\n\n15 Apagar luces y cerrar puerta del depósito \n16 Ir al garage o playón donde estacionó el camión \n17 Cerrar y trabar puertas del camión \n18 Avisar fin de descarga al transportista\nYa lo tenemos. Ahora el jefe dice que en el camión suelen venir entre 5 y 15 cajas de material y nos pide que definas el mismo procedimiento para todos los casos posibles. Notemos que se repiten las instrucciones 2, 3, 4, 5 y 6 para cada caja ¿Qué hacemos? ¿Vamos a seguir copiando y pegando las instrucciones para cada caja? ¿Y si algún día vienen más de 15 o menos de 5? ¿Vamos a tener una lista de instrucciones distinta para cada cantidad de cajas que puedan venir? Parece ser necesario hacer algo más genérico que le facilite la vida a todos. Una nueva versión:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte \n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Si es la primera caja, colocarla sobre el piso en el sector correspondiente;\nsi no, apilarla sobre la anterior;\nsalvo que ya haya 3 apiladas,\nen ese caso colocarla a la derecha sobre el piso \n7 Ir al garage o playón donde estacionó el camión \n\n8 Repetir 4,5,6,7 mientras queden cajas para descargar \n\n9 Cerrar y trabar puertas del camión \n10 Avisar fin de descarga al transportista \n11 Volver a depósito \n12 Apagar luces y cerrar puerta del depósito\nEsta descripción es bastante más compacta y cubre todas las posibles cantidades de cajas en un envío (habituales y excepcionales), de modo que con una única página en el manual de procedimientos será suficiente.\nSin embargo, los algoritmos que venimos escribiendo se parecen más al primer procedimiento que al segundo. ¿Cómo podemos mejorarlos?\n\n\n\n\n\n\nCiclos\n\n\n\nEl ciclo, bucle o sentencia iterativa es una instrucción que permite ejecutar un bloque de código varias veces. En Python, existen dos tipos de ciclos: while y for.\n\n\n\n3.2.1 Ciclo for\nLa instrucción for nos indica que queremos repetir un bloque de código una cierta cantidad de veces. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\nfor i in range(1, 11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo for incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nfor &lt;nombre&gt; in &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice definido porque una vez evaluada la &lt;expresion&gt;, se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: tantas veces como elementos tenga la &lt;expresion&gt;.\nLa expresión puede indicarse con range:\n\nrange(n) devuelve una secuencia de números desde 0 hasta n-1.\nrange(a, b) devuelve una secuencia de números desde a hasta b-1.\nrange(a, b, c) devuelve una secuencia de números desde a hasta b-1, de a c en c.\n\nSe podría decir que el range puede recibir 3 valores: range(start, end, step) o range(inicio, fin, paso), donde:\n\nstart o inicio es el valor inicial de la secuencia. Por defecto es 0.\nend o fin es el valor final de la secuencia. No se incluye en la secuencia.\nstep o paso es el incremento entre cada elemento de la secuencia. Por defecto es 1.\n\nSi le pasamos un sólo parámetro, lo toma como end.\nSi le pasamos dos, los toma como start y end.\nY si le pasamos tres, los toma como start, end y step.\n\n\n\n\n\n\nNote\n\n\n\n¿Te suena quizás a algo que ya vimos? Quizás… ¿los slices de las cadenas de caracteres?\n\n\nAdemás, la variable &lt;nombre&gt; va a ir tomando el valor de cada elemento de la &lt;expresion&gt; en cada iteración. En nuestro ejemplo de imprimir los números del 1 al 10, vemos que i toma los valores 1, 2, 3, 4, 5, 6, 7, 8, 9 y 10, en ese orden.\n\n\nEjemplo\nSe pide una función que imprima todos los números pares entre dos números dados a y b. Se considera que a y b son siempre números enteros positivos, y que a es menor que b.\n\n\ndef imprimir_pares(a, b):\n  for i in range(a, b):\n    if i % 2 == 0: # si el resto de dividir por 2 es cero, es par\n      print(i)\n\nimprimir_pares(1,15)\n\n2\n4\n6\n8\n10\n12\n14\n\n\n\n\n\nEjemplo\nSe pide una función que imprima todos los números del 1 al 10, en orden inverso.\n\n\ndef imprimir_inverso():\n  for i in range(10, 0, -1):\n      print(i)\n\nimprimir_inverso()\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\n\n\n3.2.1.1 Iterables\nComo dijimos más arriba, la expresión del for puede ser cualquier expresión que devuelva una secuencia de valores. A estas expresiones se las llama iterables.\nUn ciclo for también podría iterar sobre elementos de una lista (tema que vamos a ver más adelante), o sobre caracteres de una palabra. Por ejemplo:\n\nfor num in [1, 3, 7, 5, 2]:\n    print(num)\n\n1\n3\n7\n5\n2\n\n\n\nfor c in \"Hola\":\n    print(c)\n\nH\no\nl\na\n\n\n\n\n\n3.2.2 Ciclo while\nLa instrucción while nos indica que queremos repetir un bloque de código mientras se cumpla una condición. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\ni = 1\nwhile i &lt; 11:\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo while incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nwhile &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice indefinido porque una vez evaluada la &lt;expresion&gt;, no se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: se ejecuta mientras la &lt;expresion&gt; sea verdadera.\nPara usar la instrucción while, tenemos cuatro aspectos para armar y afinar correctamente:\n\nCuerpo\nCondición\nEstado Previo\nPaso\n\nAntes, para la instrucción for, sólo considerábamos el cuerpo y la condición. Ahora, además, tenemos que considerar el estado previo y el paso.\nEl cuerpo es la porción de código que se repetirá mientras la condición sea verdadera.\nLa condición es la expresión booleana que se evalúa para decidir si se ejecuta el cuerpo o no.\nEl estado previo es el estado de las variables antes de ejecutar el cuerpo. En general, se refiere al estado de las variables que participan de la condición.\nEl paso es la porción de código que modifica el estado previo. En general, se refiere a la modificación de las variables que participan de la condición.\n\n\n\n\n\n\n\nWarning\n\n\n\nCon los ciclos while hay que tener mucho cuidado de no caer en un loop infinito. Esto sucede cuando la condición siempre es verdadera, y el cuerpo no modifica el estado previo. Por ejemplo:\nwhile True: # más adelante sobre el uso de `while True`\n    print(\"Hola\")\no bien:\ni = 0\nwhile i &lt; 10:\n    print(i) # el valor de i nunca cambia\n\n\n\nEjercicio\nRepetir el ejercicio 7.b de la guía 2 usando un ciclo while. Repetir usando un ciclo for. ¿Qué diferencias hay entre ambos?  \n\n\n\n3.2.3 Break, Continue y Return\nbreak y continueson dos palabras clave en Python que se utilizan en bucles (tanto for como while) para alterar el flujo de ejecución del bucle.\n\n3.2.3.1 Break\nLa declaración break se usa para salir inmediatamente de un bucle antes de que se complete su iteración normal. Cuando se encuentra una declaración break dentro de un bucle, el bucle for o while se detiene inmediatamente y continúa con la ejecución de las instrucciones que están después del mismo.\nPor ejemplo, supongamos que queremos encontrar al primer número múltiplo de 3 entre 10 y 30:\n\nnumero = 10\nwhile numero &lt;= 30:\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n  numero += 1\n\nEl primer número múltiplo de 3 es: 12\n\n\n\nfor numero in range(10, 31):\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n\nEl primer número múltiplo de 3 es: 12\n\n\n\n\n3.2.3.2 Continue\nLa declaración continue se usa para omitir el resto del código dentro de una iteración actual del bucle y continuar con la siguiente iteración. Cuando se encuentra una declaración continue dentro de un bucle, el bucle for o while salta a la siguiente iteración del bucle sin ejecutar las instrucciones que están después del continue.\nPor ejemplo, supongamos que queremos imprimir todos los números entre 1 y 20, excepto los múltiplos de 4:\n\nnumero = 1\nwhile numero &lt;= 20:\n  if numero % 4 == 0:\n      numero += 1\n      continue\n  print(numero)\n  numero += 1\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\nfor numero in range(1, 21):\n  if numero % 4 == 0:\n      continue\n  print(numero)\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotemos que tanto para el uso de break como de continue, si el código se encuentra con uno de ellos en la ejecución, no ejecuta nada posterior a ellos: en el caso de break, corta o interrumpe la ejecución del bucle; en el case de continue, saltea el resto del código de esa iteración y pasa a la siguiente, volviendo a evaluar la condición si el bucle es while.\n\n\n\n\n3.2.3.3 Return\nCuando estamos dentro de una función, la instrucción return nos permite devolver un valor y salir de la función. Ahora, si además estamos dentro de un ciclo, también nos permite salir del mismo sin ejecutar el resto del código.\nPor ejemplo:\n\ndef obtener_primer_par_desde(n):\n  for num in range(n, n+10):\n    print(f\"Analizando si el número {num} es par\")\n    if num % 2 == 0:\n      return num\n  return None\n\n\nobtener_primer_par_desde(9)\n\nAnalizando si el número 9 es par\nAnalizando si el número 10 es par\n\n\n10\n\n\nComo vemos, la función obtener_primer_par_desde recibe un número n, y devuelve el primer número par que encuentra a partir de n. Si no encuentra ningún número par, devuelve None.\nSi encuentra un número par, no sigue analizando el resto de los números. Usa return para salir del ciclo y devuelve el número encontrado.\n\n\n\n3.2.4 Consideraciones del While\nEs importante no ser redundantes con el código y no “hacer preguntas” que ya sabemos.\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\n\n&lt;codigo cuando ya no se cumple la condición&gt;\nVeamos un ejemplo:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nif numero == 3:\n  print(\"El número es 3\")\nelse:\n  print(\"El número no es 3\")\nEl output va a ser siempre el mismo:\n1\n2\n3\nEl número es 3\n¿Por qué? Porque nuestra condición del while es lo que dice “mientras esto se cumpla, yo repito el bloque del código de adentro”. Nuestra condición es que numero &lt; 3. En el momento en que numero llega a 3, el bucle whiledeja de cumplir con la condición, y la ejecución se corta, se termina con el bucle.\nEs decir, el bloque\nif numero == 3:\n  print(\"El número es 3\")\nsiempre se ejecuta.\nY el bloque\nelse:\n  print(\"El número no es 3\")\nnunca se ejecuta.\nPor lo tanto, podemos reescribir el código de la siguiente forma:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nprint(\"El número es 3\")\n\nDe la misma forma, no tendría sentido hacer algo así:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\n  if numero == 3:\n    break\n\nif numero == 3 está absolutamente de más. Si numero es 3, el bucle while no se ejecuta, por lo que nunca se va a llegar a esa línea de código. No es necesario “re-chequear” la condición del while dentro del mismo, porque asumimos que si llegamos a esa línea de código, es porque la condición se cumplió. Por lo tanto, podemos reescribir el código de la siguiente forma:\n\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\nAhora, el continue está de más también, porque se usa cuando nosotros queremos forzar a que el ciclo pase a la siguiente iteración. Pero en este caso, el ciclo ya va a pasar a la siguiente iteración, porque estamos en la última línea del cuerpo.\n\nEste es nuestro código final, escrito de forma correcta:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\n3.2.4.1 While True\nLa instrucción while está hecha para que se ejecute mientras la condición sea verdadera. Pero, ¿qué pasa si usamos while True? Lo que pasa al usar while True es que nuestro código se vuelve más propenso al error: si no tenemos cuidado, podemos caer en un loop infinito.\n\nComo no tenemos una condición a evaluar ni modificar en cada iteración, el bucle se ejecuta infinitamente. Dependería de nosotros, como programadores, que el bucle se corte en algún momento. Es decir, dependería de que nos acordemos de poner dentro del while alguna decisión que haga que el bucle se corte. Y si por alguna razón no nos acordamos, el bucle se ejecutaría infinitamente, dejando al programa “congelado” o “colgado”, sin responder, y usando todos los recursos de la computadora.\nEn pocas palabras, podemos afirmar que el uso de while True en Python es una mala práctica de programación, y recomendamos evitarla fuertemente.\n\n\n3.2.4.2 Modificando la Condición\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\nLa mejor decisión que se puede tomar para el  de un bloque while es asumir que, durante toda su ejecución exceptuando la última línea, la condición se cumple. Es decir, que el cuerpo del bucle se ejecuta mientras la condición sea verdadera. Por lo tanto, si queremos modificar la condición, debemos hacerlo en la última línea del cuerpo.\nPor ejemplo, esto no es correcto:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  numero += 1     # actualización de la condición\n  print(numero)\n\n1\n2\n3\n\n\nComo vemos, se imprimen los números 1, 2, 3; pero no el 0. Esto es porque estamos modificando la condición ni bien empieza el bucle, y no en la última línea del cuerpo.\nLa forma correcta de hacerlo sería:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1     # actualización de la condición\n\n0\n1\n2\n\n\nDe esta forma, todo lo que se encuentre antes de la última línea del cuerpo se ejecuta mientras la condición sea verdadera. Y la última línea del cuerpo es la que modifica la condición.\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número entero positivo y muestre por pantalla todos los números pares desde 1 hasta ese número.\nResolver primero usando un ciclo while y luego usando un ciclo for.\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número par. Mientras el usuario ingrese números que no cumplan con lo pedido, se lo debe volver a solicitar.\nPista: resolver usando while."
  },
  {
    "objectID": "unidad_4.html#subtitle",
    "href": "unidad_4.html#subtitle",
    "title": "4  Tipos de Datos Estructurados",
    "section": "4.1 Subtitle",
    "text": "4.1 Subtitle"
  },
  {
    "objectID": "unidad_5.html#subtitle",
    "href": "unidad_5.html#subtitle",
    "title": "5  Entrada y Salida de Información",
    "section": "5.1 Subtitle",
    "text": "5.1 Subtitle"
  },
  {
    "objectID": "unidad_6.html#subtitle",
    "href": "unidad_6.html#subtitle",
    "title": "6  Bibliotecas",
    "section": "6.1 Subtitle",
    "text": "6.1 Subtitle"
  },
  {
    "objectID": "guia.html#recomendaciones-al-realizar-las-guías",
    "href": "guia.html#recomendaciones-al-realizar-las-guías",
    "title": "Guía de Ejercicios",
    "section": "Recomendaciones al realizar las guías",
    "text": "Recomendaciones al realizar las guías\n\nPrestá atención al leer el enunciado. En particular:\n\nSi se pide una función que devuelva o calcule un valor, la función debe tener una función return.\nSi se pide una función que imprima un valor, la función debe tener un print.\nSi se pide una función que pida o pregunte algo al usuario, la función debe tener un input.\nA menos que se diga específicamente “pedirle al usuario”, no es necesario que el programa contenga input. En todo caso, hacer que la función reciba el o los datos por parámetro.\n\nCada ejercicio puede tener muchas soluciones posibles. Una vez que encuentres una solución, en lugar de pasar al siguiente ejercicio, pensá si se te ocurre una solución cuya codificación sea más simple.\nEs muy importante que el código sea lo más claro y legible posible.\n\nEn particular, nombres de funciones y variables deben ser descriptivos.\nTambién prestá atención a los espacios en blanco y a la indentación.\n\nNo documentes en exceso, pero tampoco ahorres documentación necesaria.\nProbá siempre que el código cumpla con lo solicitado."
  },
  {
    "objectID": "guia.html#guía-1-introducción-a-la-algoritmia-y-la-programación",
    "href": "guia.html#guía-1-introducción-a-la-algoritmia-y-la-programación",
    "title": "Guía de Ejercicios",
    "section": "Guía 1: Introducción a la Algoritmia y la Programación",
    "text": "Guía 1: Introducción a la Algoritmia y la Programación\n\n\n\n\n\n\nRecomendación\n\n\n\nEn esta guía nos dedicaremos a introducirnos en los conceptos de programación y algoritmo. Para los primeros seis ejercicios, te recomendamos ver este video para recordar cómo entiende la computadora nuestras instrucciones.\n\n\n\nSe tiene que explicar a una máquina exactamente cómo servir un vaso de jugo (de los que vienen en cartón) de la heladera. Recordando la definición de algoritmo, hacer una descripción paso a paso de lo que se tiene que hacer y usar para lograr el objetivo. Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe tiene que explicar a una máquina exactamente cómo hacer una tostada con queso, pensá qué ingredientes se necesitan con sus cantidades, cómo tiene que ser el espacio de trabajo y los elementos que va a necesitar usar. Recordando la definición de algoritmo, hacer una descripción paso a paso de lo que se tiene que hacer y usar para hacer una tostada con queso. Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe te pide que organices una colecta de alimentos no perecederos por la Ciudad de Buenos Aires. Contamos con algunos automóviles y camionetas de voluntarios, un listado de donaciones, listado de los alimentos a donar, la disponibilidad horaria y la dirección en la cual se dejan los alimentos. La colecta se realiza en un solo día. ¿Cómo la organizarías? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nTenés que enviar invitaciones personalizadas para tu cumpleaños. Cada invitación tiene que mencionar el nombre de la persona y la relación que tiene con vos. Contamos con una impresora a la que le das el texto a enviar, un listado con los nombres de los invitados y la relación que cada uno tiene con vos. ¿Cómo redactarías el texto de la invitación? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe te encargó definir qué datos son necesarios para el registro de estudiantes en un curso de inglés. ¿Qué datos crees que deberían ser obligatorios y cuáles opcionales? ¿Y si el curso es de cocina? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nContás con un listado de cosas a comprar y tenes que ir a un supermercado que cuenta con distintas góndolas o pasillos. Cada góndola o pasillo puede contar con varios, uno o ninguno de los productos de tu lista. ¿Cuál sería el listado de instrucciones para poder terminar lo más rápido posible? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nCon el anexo de Replit de la Unidad 1, realizá tu primer programa: hacé que se imprima por pantalla un “¡Hola mundo!”."
  },
  {
    "objectID": "guia.html#guía-2-tipos-de-datos-expresiones-y-funciones",
    "href": "guia.html#guía-2-tipos-de-datos-expresiones-y-funciones",
    "title": "Guía de Ejercicios",
    "section": "Guía 2: Tipos de Datos, Expresiones y Funciones",
    "text": "Guía 2: Tipos de Datos, Expresiones y Funciones\n\nGuardar el texto “Hola, Mundo!” en una variable e imprimirla por pantalla.\nGuardar los números 1, 2 y 3 en tres variables distintas e imprimirlos por pantalla.\n\nGuardar los números 1, 2 y 3 en tres variables distintas y luego sumarlos e imprimir el resultado por pantalla.\n\nRepetir con las distintas operaciones disponibles que se vieron en la unidad 2: resta, multiplicación, división, división entera, resto, potencia; combinando los números entre sí.\n\nCrear un programa que le solicite al usuario:\n\nSu nombre y lo imprima por pantalla.\nSu edad y la imprima por pantalla.\nSu edad, le sume 1, y la imprima por pantalla.\n\nCrear un programa que le solicite al usuario un número, y que devuelva el resto obtenido de dividirlo por 2.\n¿Qué operador vimos para obtener el resto?\nEscribir un programa que le pida al usuario su año de nacimiento, y que le diga qué edad tiene en el año actual.\nCrear un programa que le solicite al usuario 5 enteros y que muestre por pantalla el promedio de ellos. Hacerlo de dos formas:\n\nPrimero, usando 5 variables para cada entero.\nDespués, usando una sola variable para almacenar la suma de los 5 enteros. ¿Cómo se te ocurre que podrías hacer?\n\nCrear una función que reciba un número y que devuelva el valor absoluto.\nCrear una función que reciba un número y que devuelva True si es par, y False si es impar.\nCrear una función que reciba un número y un string, y que devuelva ambos concatenados dentro de un nuevo string.\nCrear una función que reciba dos enteros y que devuelva el resto y el cociente entre ellos.\nCrear una función que le pida al usuario su nombre y apellido, e los imprima con el siguiente formato: “Apellido, Nombre”.\nHacer una función que reciba una palabra y devuelva la cantidad de letras que tiene.\n\nHacer una función que reciba una palabra y que imprima los primeros 5 caracteres únicamente. Ejemplo: Si se recibe “pensamiento” se debe imprimir “pensa”.\nHacer una función que reciba una palabra y que imprima sólo los caracteres ubicados en posiciones pares. Ejemplo: Si se recibe “pensamiento” se debe imprimir “pnaino”.\nHacer una función que reciba una palabra y que imprima la palabra dada vuelta. Ejemplo: Si se recibe “materia” se debe imprimir “airetam”.\n\nHacer una funcion que reciba una palabra, le borre todas las letras “a” e imprima el resultado por pantalla. Pista: usar una función predefinida de Python. Ejemplo: Si se recibe “casa” se debe imprimir “cs”. Pista: usar slices.\nAnalizar qué tipo de dato (o error) se obtiene al hacer las siguientes operaciones:\n\n5 / 2\n5 // 2\n5 % 2\n5 ** 2\n5.0 / 2\n5.0 // 2\n5.0 % 2\n5.0 ** 2\n5 / 2.0\n5 // 2.0\n5 % 2.0\n5 ** 2.0\n5.0 / 2.0\n5.0 // 2.0\n5.0 % 2.0\n5.0 ** 2.0\n\"Hola\" * 2\n\"Hola\" + 2\n\"Hola\" + \"2\"\nx = \"Hola\"\nx += \" mundo\"\n\n\nEscribir una función que convierta un valor dado en grado Celcius, a Fahrenheit. Recordar que la fórmula para la conversión es: F = 9/5 * C + 32.\nEscribir una función que convierta un valor dado en grados Fahrenheit, a Celcius. Usar la misma fórmula anterior.\n\nEscribir una función que calcule el área de un triángulo recibiendo como parámetros su base y su altura.\nSiendo el cálculo de la norma de un vector \\(v\\) en \\(R^3\\):\n\\[||v|| = \\sqrt{v_1^2 + v_2^2 + v_3^2}\\]\nEscribir una función que calcule la norma de un vector en R3 recibiendo como parámetros las 3 componentes \\(v_1\\), \\(v_2\\) y \\(v_3\\) del mismo.\nDesafío (no obligatorio): Calcular el área de un rectángulo (alineado con los ejes \\(x\\) e \\(y\\)), dadas sus coordenadas \\(x_1\\), \\(x_2\\), \\(y_1\\) e \\(y_2\\)."
  },
  {
    "objectID": "guia.html#guía-3-estructuras-de-control",
    "href": "guia.html#guía-3-estructuras-de-control",
    "title": "Guía de Ejercicios",
    "section": "Guía 3: Estructuras de Control",
    "text": "Guía 3: Estructuras de Control\n\n1. Decisiones\n\nEscribir una función que, dado un número entero \\(n\\), calcule si es impar o no.\nEscribir una implementación propia de la función \\(abs\\), que devuelva el valor absoluto de cualquier valor que reciba. Ejemplo: mi_abs(5) devuelve 5 y mi_abs(-5) devuelve 5. Pista: No se puede usar la función predefinida abs.\nEscribir una función que reciba un número y devuelva True si es entero y False si no lo es. Pista: no se puede usar la función isinstance.\nEscribir una función para determinar si una letra recibida es vocal o no. La misma debe devolver un valor booleano. Luego, escribir una función para determinar si una letra es consonante o no.\n\nResolver sin el uso de in ni not in.\nResolver usando in y not in.\nResolver para que la función identifique tanto mayúsculas como minúsculas. Pista: investigar los métodos lower y upper de string.\n\n\n\n\n\n\n\n\nTip: in y not in\n\n\n\n\n\n¿Conocés el uso de in?\nPara saber si un elemento está en una lista o en un string, podemos usar in y not in. Por ejemplo:\n\n'a' in 'hola'\n\nTrue\n\n\n\n'w' in 'hola'\n\nFalse\n\n\n\n'w' not in 'hola'\n\nTrue\n\n\n\n'casa' in ['cama', 'mesa', 'silla']\n\nFalse\n\n\n\n\n\n\nEscribir funciones que resuelvan los siguientes problemas:\n\nDado un año, que devuelva si es bisiesto. Nota: un año es bisiesto si es un número divisible por 4, pero no si es divisible por 100, excepto que también sea divisible por 400.\nDado un mes y un año, que devuelva la cantidad de días correspondientes.\nPedirle al usuario su día y mes de cumpleaños. El programa debe imprimir un mensaje indicando a qué signo corresponde el usuario.\n\nAries: 21 de marzo al 20 de abril.\nTauro: 21 de abril al 20 de mayo.\nGeminis: 21 de mayo al 21 de junio.\nCancer: 22 de junio al 23 de julio.\nLeo: 24 de julio al 23 de agosto.\nVirgo: 24 de agosto al 23 de septiembre.\nLibra: 24 de septiembre al 22 de octubre.\nEscorpio: 23 de octubre al 22 de noviembre.\nSagitario: 23 de noviembre al 21 de diciembre.\nCapricornio: 22 de diciembre al 20 de enero.\nAcuario: 21 de enero al 19 de febrero.\nPiscis: 20 de febrero al 20 de marzo.\nPiedra, papel o tijera: escribir un programa de “Piedra, papel o tijera” tal que sea imposible que el usuario gane. El usuario debe ingresar R (piedra), P (papel), o T (tijera) y la computadora debe siempre ganarle. Ejemplo:\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: R\n¡Papel! ¡Gané!\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: P\n¡Tijera! ¡Gané!\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: T\n¡Piedra! ¡Gané!\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: M\nEsa jugada no está disponible.\nSuponiendo que el primer día del año fue lunes, escribir una función que reciba un número con el día del año (de 1 a 366) y devuelva el día de la semana que le toca. Por ejemplo: si se recibe ‘3’, debe devolver “miércoles”, y si se recibe ‘9’, debe devolver “martes”.\n\n\n\n2. Ciclos\n\nEscribir función que:\n\nImprima por pantalla todos los números entre 10 y 20.\nSalude a todas las personas de esta lista [Flaminia, Iara, Agostina, Priscila, Sol, Lucía] con el mensaje \"Hola &lt;nombre&gt;! Vamos a aprender a programar\".\nLe pida al usuario que ingrese 5 números y le muestre la suma total de todos ellos.\nImprima por pantalla todos los números entre 100 y 199 que sean divisibles por 7.\nReciba dos números, y recorra todos los números entre ellos, imprimiendo en pantalla si es par o impar. Por ejemplo, recibiendo 1 y 3, debe imprimir:\n\n1 es impar\n2 es par\n3 es impar\nSe quiere hacer un programa para enseñar a los niños las tablas de multiplicar del 1 al 10. Crear una función que reciba un número e imprima por pantalla la tabla de multiplicar de ese número. Ejemplo:\nmostrar_tablas_para(1)\ndebe imprimir:\n1 x 1 = 1\n1 x 2 = 2\n1 x 3 = 3\n1 x 4 = 4\n1 x 5 = 5\n1 x 6 = 6\n1 x 7 = 7\n1 x 8 = 8\n1 x 9 = 9\n1 x 10 = 10\nmostrar_tablas_para(-2)\ndebe imprimir:\nError: El número debe ser positivo y estar entre 1 y 10\nCrear una función que cante el feliz cumpleaños. Dado un entero, debe imprimir ‘Que los cumplas feliz’ en distintas líneas por esa cantidad de veces.\n\nNecesitamos escribir un programa de cobro en el supermercado. La función debe recibir un número entero que representa el monto a pagar y debe permitir al usuario que ingrese valores, hasta que el pago se haya realizado en su totalidad. Además, le debe ir indicando cuánto le queda por pagar. El programa no da vuelto.\n\nEjemplo: Su total a pagar es: 500  Ingrese el monto a pagar: 100  Pendientes: 400. Ingrese el monto a pagar: 200  Pendientes: 200. Ingrese el monto a pagar: 200  Pendientes: 0. Gracias por su compra.\n\nHacer que el programa anterior dé vuelto:\n\nEjemplo: Su total a pagar es: 500  Ingrese el monto a pagar: 100  Pendientes: 400. Ingrese el monto a pagar: 200  Pendientes: 200. Ingrese el monto a pagar: 300  Pendientes: 0. Su vuelto es: 100. Gracias por su compra.\nEscribir un programa que le pida al usuario que ingrese un número. Para ese número, se imprime la tabla de multiplicar del 1 al 10. Luego, se le vuelve a pedir otro número. Si el usuario ingresa “X”, el programa debe terminar. El usuario debe poder ingresar números indefinidamente hasta que ingrese “X”. Se puede reutilizar la función del ejercicio 9 de esta guía.\nEjemplo: Hola! Esto es Tablas de Multiplicar  Ingrese un número o \"X\" para salir: 1  1 x 1 = 1  1 x 2 = 2  1 x 3 = 3  1 x 4 = 4  1 x 5 = 5  1 x 6 = 6  1 x 7 = 7  1 x 8 = 8  1 x 9 = 9  1 x 10 = 10  Ingrese un número o \"X\" para salir: -2  Error: El número debe ser positivo y estar entre 1 y 10  Ingrese un número o \"X\" para salir: X  ¡Adios!\nManejo de contraseñas\n\nEscribir un programa que contenga una constraseña inventada, que le pregunte al usuario la contraseña, y no le permita continuar hasta que la haya ingresado correctamente.\nModificar el programa anterior para que solamente permita una cantidad fija de intentos.\nModificar el programa anterior para que sea una función que devuelva si el usuario ingresó o no la contraseña correctamente, mediante un valor booleano (True o False).\n\n\nHacer una función que reciba un número del 1 al 10, y luego permita al usuario poder adivinar ese número, ingresando valores repetidamente. Para cada ingreso del usuario, el programa debe indicarle si su numero es menor o mayor al número a adivinar. Una vez que el usuario ingresa el número correcto, lo felicita y termina.\nRepetir permitiendo únicamente 3 intentos.\nRepetir generando el número aleatoriamente de la siguiente forma dentro de la función, sin recibirlo por parámetro:\n\n\n\nimport random\nnumero_a_adivinar = random.randint(1, 10)\nprint(numero_a_adivinar)\n\n5\n\n\n\n\n\n\n\n\nTip: Librerías\n\n\n\n\n\n¿Sabías que Python tiene muchas librerías que podés usar para hacer cosas más complejas? Por ejemplo, la librería random tiene funciones para generar números aleatorios. También hay otras librerías como Pandas para trabajar con datos, Matplotlib para hacer gráficos, Numpy para trabajar con matrices, y muchas más. Vamos a estar viendo estas tres en la última unidad de la materia.\nUna librería es un conjunto de funciones que alguien más escribió y que podemos usar en nuestros programas. Para usar una librería, primero tenemos que importarla. Por ejemplo, para usar la librería random, tenemos que poner import random al principio de nuestro programa (arriba de todo en nuestro archivo). Luego, podemos usar las funciones de la librería, como random.randint(1, 10).\n\n\n\n\n\nQueremos modelar una máquina de sacar juguetes. Debemos hacer una función que reciba un número que representa la cantidad de fichas \\(x\\) que necesita la máquina para funcionar. Se debe imprimir un mensaje en pantalla que indique “Ingresá \\(x\\) fichas para comenzar”. El usuario deberá ingresar entonces letras “F”, que representan a las fichas. Notar que si se ingresa algo distinto a “F”, se ignora.\n\nSe debe seguir solicitando fichas siempre que no se haya alcanzado la cantidad necesaria para funcionar. Cuando se haya alcanzado la cantidad necesaria, se debe imprimir un mensaje que indique “¡A jugar!”. Ejemplo:\nIngresá 2 fichas para comenzar: F\nIngresá 2 fichas para comenzar: B\nIngresá 2 fichas para comenzar: Hola\nIngresá 2 fichas para comenzar: F\n¡A jugar!\n\nModificar el programa anterior para que vaya mostrando la cantidad de fichas que faltan para comenzar a jugar. Ejemplo:\n\nIngresá 2 fichas para comenzar: F\nIngresá 1 fichas para comenzar: B\nIngresá 1 fichas para comenzar: ficha\nIngresá 1 fichas para comenzar: F\n¡A jugar!\nCrear una función que calcule si un número es primo o no. Un número es primo cuando solamente es divisible por sí mismo y por 1. Pista: usar el operador módulo %.\nDesafío (obligatorio): Crear una función que reciba un número entero e imprima los números primos entre 0 y el número ingresado.\nDesafío (obligatorio):\n\nCrear una función que reciba dos números, y devuelva la suma de todos los números múltiplos de 7 entre esos dos números. Por ejemplo, si recibe 3 y 25, debe devolver 7 + 14 + 21 = 42. Si recibe 3 y 4, debe devolver 0, ya que no hay múltiplos de 7 entre esos dos números.\nRepetir calculando el promedio en vez de la suma.\nRepetir calculando únicamente el promedio entre los primeros 3 múltiplos de 7 encontrados. Pista: usar break.\nRepetir calculando únicamente el promedio entre los múltiplos de 7 encontrados que no sean múltiplos de 2. Pista: usar continue.\n\nDesafío (obligatorio):\n\nEscribir una función que dada la cantidad de ejercicios de un examen, y el porcentaje de ejercicios bien resueltos necesario para aprobar dicho examen, revise un grupo de exámenes.\n\nPara ello, en cada paso debe preguntarle al usuario la cantidad de ejercicios resueltos por el alumno, o pedirle que ingrese “*” para salir. Debe mostrar por pantalla el porcentaje correspondiente a la cantidad de ejercicios resueltos respecto a la cantidad de ejercicios del examen y una leyenda que indique si aprobó o no.\n\nAdicional al punto anterior: imprimir un mensaje informándole al usuario la cantidad de ejercicios y el % de aprobación.\nValidar que el usuario siempre ingrese números positivos y menor o iguales a la cantidad de ejercicios del examen, o “*“. De lo contrario, mostrar un mensaje de error y volver a pedirle el dato al usuario."
  },
  {
    "objectID": "unidad_4.html#secuencias-tuplas-y-listas",
    "href": "unidad_4.html#secuencias-tuplas-y-listas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.1 Secuencias, Tuplas y Listas",
    "text": "4.1 Secuencias, Tuplas y Listas"
  },
  {
    "objectID": "unidad_4.html#secuencias",
    "href": "unidad_4.html#secuencias",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.1 Secuencias",
    "text": "4.1 Secuencias\nUna secuencia es una serie de elementos ordenados que se suceden unos a otros.\nUna secuencia en Python es un grupo de elementos con una organización interna, que se alojan de manera contigua en memoria.\nLas secuencias son tipos de datos que pueden ser iterados, y que tienen un orden definido. Las secuencias más comunes son las listas, las tuplas y las cadenas de caracteres.\n\n4.1.1 Rangos\nLos rangos ya los hemos visto antes, pero lo que no habíamos definido es que son secuencias. Los rangos representan específicamente una secuencia de números inmutable.\nLos rangos se definen con la función range(), que recibe como parámetros el inicio, el fin y el paso. El inicio es opcional y por defecto es 0, el paso también es opcional y por defecto es 1.\n\n\n4.1.2 Cadenas de Caracteres\nUn string es un tipo de secuencia que sólo admite caracteres como elementos. Los strings son inmutables, es decir, no se pueden modificar una vez creados.\nInternamente, cada uno de los caracteres se almacenará de forma contigua en memoria. Es por esto que podemos acceder a cada uno de los caracteres de un string a través de su índice haciendo uso de [].\n\n\n\nÍndice\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nLetra\nH\no\nl\na\n\nM\nu\nn\nd\no\n\n\n\nHasta ahora, vimos que:\n\nLas cadenas de caracteres pueden ser concatenadas con el operador +:\n\n\nsaludo = \"Hola\"\ndespedida = \"Chau\"\nprint(saludo + despedida)\n\nHolaChau\n\n\n\nLas cadenas de caracteres pueden ser sliceadas o incluso acceder a un único elemento usando []:\n\n\nsaludo = \"Hola Mundo\"\nprint(saludo[0:4])\nprint(saludo[5])\n\nHola\nM\n\n\nPodemos agregar también que:\n\nLas cadenas de caracteres pueden ser multiplicadas por un número entero (y el resultado es la concatenación de la cadena consigo misma esa cantidad de veces):\n\n\nsaludo = \"Hola\"\nprint(saludo * 3)\n\nHolaHolaHola"
  },
  {
    "objectID": "unidad_4.html#introducción-secuencias",
    "href": "unidad_4.html#introducción-secuencias",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.1 Introducción: Secuencias",
    "text": "4.1 Introducción: Secuencias\nUna secuencia es una serie de elementos ordenados que se suceden unos a otros.\nUna secuencia en Python es un grupo de elementos con una organización interna, que se alojan de manera contigua en memoria.\nLas secuencias son tipos de datos que pueden ser iterados, y que tienen un orden definido. Las secuencias más comunes son los rangos, las cadenas de caracteres, las listas y las tuplas. En este capítulo vamos a ver las características de cada una de ellas y cómo podemos manipularlas."
  },
  {
    "objectID": "unidad_4.html#rangos",
    "href": "unidad_4.html#rangos",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.2 Rangos",
    "text": "4.2 Rangos\nLos rangos ya los hemos visto antes, pero lo que no habíamos definido es que son secuencias. Los rangos representan específicamente una secuencia de números inmutable.\nLos rangos se definen con la función range(), que recibe como parámetros el inicio, el fin y el paso. El inicio es opcional y por defecto es 0, el paso también es opcional y por defecto es 1.\n\n\n\n\n\n\nNote\n\n\n\nPara más información de los rangos, ver la unidad 3."
  },
  {
    "objectID": "unidad_4.html#cadenas-de-caracteres",
    "href": "unidad_4.html#cadenas-de-caracteres",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.3 Cadenas de Caracteres",
    "text": "4.3 Cadenas de Caracteres\nUn string es un tipo de secuencia que sólo admite caracteres como elementos. Los strings son inmutables, es decir, no se pueden modificar una vez creados.\nInternamente, cada uno de los caracteres se almacenará de forma contigua en memoria. Es por esto que podemos acceder a cada uno de los caracteres de un string a través de su índice haciendo uso de [].\n\n\n\nÍndice\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nLetra\nH\no\nl\na\n\nM\nu\nn\nd\no\n\n\n\nHasta ahora, vimos que:\n\nLas cadenas de caracteres pueden ser concatenadas con el operador +:\n\n\nsaludo = \"Hola\"\ndespedida = \"Chau\"\nprint(saludo + despedida)\n\nHolaChau\n\n\n\nLas cadenas de caracteres pueden ser sliceadas o incluso acceder a un único elemento usando []:\n\n\nsaludo = \"Hola Mundo\"\nprint(saludo[0:4])\nprint(saludo[5])\n\nHola\nM\n\n\nPodemos agregar también que:\n\nLas cadenas de caracteres pueden ser multiplicadas por un número entero (y el resultado es la concatenación de la cadena consigo misma esa cantidad de veces):\n\n\nsaludo = \"Hola\"\nprint(saludo * 3)\n\nHolaHolaHola\n\n\nAdicional a esas 3 operaciones, las cadenas de caracteres tienen una gran cantidad de métodos que nos permiten manipularlas. Veamos algunos de ellos.\n\n4.3.1 Métodos de Cadenas de Caracteres\nTodos los métodos de las cadenas de caracteres devuelven una nueva cadena de caracteres o un valor, y no modifican la cadena original (ya que las cadenas de caracteres son inmutables).\n\n4.3.1.1 Longitud de una Cadena\nSe puede averiguar la cantidad de caracteres que conforman una cadena utilizando la función predefinida len():\n\nprint(len(\"Pensamiento Computacional\"))\n\n25\n\n\nExiste también una cadena especial, la cadena vacía (ya la hemos visto antes), que es la cadena que no contiene ningún caracter entre las comillas. La longitud de la cadena vacía es 0.\n\n\n\n\n\n\nTip: Len e Índices de la Cadena\n\n\n\n\n\nEs interesante notar lo siguiente: si tenemos una cadena de caracteres de longitud n, los índices de la cadena van desde 0 hasta n-1. Esto es porque el índice n no existe, ya que el primer índice es 0 y el último es n-1.\nVeámoslo con un ejemplo: tenemos el caracter Hola.\n\n\n\nÍndice\n0\n1\n2\n3\n\n\n\n\nLetra\nH\no\nl\na\n\n\n\nLa longitud de la cadena es 4, pero el último índice es 3. Si intentamos acceder al índice 4, nos dará un error:\nsaludo = \"Hola\"\nprint(saludo[4])\nIndexError: string index out of range\nLo que nos indica el error es que el índice está fuera del rango de la cadena. Esto es porque el índice 4 no existe, ya que el último índice es 3. El largo de la cadena es 4, y el último índice disponible es 4-1=3.\n\nLos índices positivos (entre 0 y len(s) - 1) son los caracteres de la cadena del primero al último.\nLos índices negativos (entre -len(s) y -1) proveen una notación que hace más fácil indicar cuál es el último caracter de la cadena: s[-1] es el último caracter, s[-2] es el penúltimo, y así sucesivamente.\n\n\nsaludo = \"Hola\"\nprint(saludo[-1])\nprint(saludo[-2])\nprint(saludo[-3])\nprint(saludo[-4])\n\na\nl\no\nH\n\n\nAdemás, el uso de índices negativos también es válido para slices:\n\nsaludo = \"Hola\"\nprint(saludo[-3:-1])\n\nol\n\n\nAl usar índices negativos, es importante no salirse del rango de los índices permitidos.\n\n\n\n\n\n4.3.1.2 Recorriendo Cadenas de Caracteres\nDijimos que los strings son secuencias, y por lo tanto podemos iterar sobre ellos. Esto significa que podemos recorrerlos con un ciclo for:\n\nsaludo = \"Hola Mundo\"\nfor caracter in saludo:\n    print(caracter)\n\nH\no\nl\na\n \nM\nu\nn\nd\no\n\n\nSi bien esto ya lo habíamos nombrado en la sección anterior como una posibilidad, ahora sabemos por qué: todas las secuencias son iterables, y por lo tanto, podemos recorrerlas.\n\n\n4.3.1.3 Buscando Subcadenas\nEl operador in nos permite saber si una subcadena se encuentra dentro de otra cadena. En la guía de la unidad 3 te pedimos que investigues acerca del operador in y not in para el ejercicio de vocales y consonantes.\na in b es una expresión (¿qué era una expresión?, repasar de ser necesario la unidad 3) que devuelve True si a es una subcadena de b, y False en caso contrario.\n\nprint( \"Hola\" in \"Hola Mundo\")\n\nTrue\n\n\nAl ser una expresión booleana, se puede usar como condición tanto de un if como de un while:\n\nif \"Hola\" in \"Hola Mundo\":\n    print(\"Se encontró una subcadena!\")\n\nSe encontró una subcadena!\n\n\n\nEjercicio 1. Investigar, para un string dado \\(s\\), cuál es el resultado del slice s[:] 2. Investigar, para un string dado \\(s\\), cuál es el resultado del slice s[j:] con \\(j\\) un número entero negativo.\n\n\n\n4.3.1.4 Inmutabilidad\nLas cadenas son inmutables. Esto significa que no se pueden modificar una vez creadas. Por ejemplo, si queremos cambiar un caracter de una cadena, no podemos hacerlo:\nsaludo = \"Hola Mundo\"\nsaludo[0] = \"h\"\nTypeError: 'str' object does not support item assignment\nSi queremos realizar una modificación sobre una cadena, lo que tenemos que hacer es crear una nueva cadena con la modificación que queremos:\nsaludo = \"Hola Mundo\"\nsaludo = \"h\" + saludo[1:]\nprint(saludo)\n\n\n4.3.1.5 Otros Métodos de Cadenas de Caracteres\nLas cadenas de caracteres tienen una gran cantidad de métodos que nos permiten manipularlas. Algunos ya los vimos, como len(), in y not in. Veamos otros.\n\n\n\n\n\n\n\n\nMétodo\nDescripción\nEjemplo\n\n\n\n\ncapitalize()\nDevuelve una copia de la cadena con el primer caracter en mayúscula y el resto en minúscula\n\"hola mundo\".capitalize() devuelve \"Hola mundo\"\n\n\ncount(subcadena)\nDevuelve la cantidad de veces que aparece la subcadena en la cadena\n\"Hola mundo\".count(\"o\") devuelve 2\n\n\nfind(subcadena)\nDevuelve el índice de la primera aparición de la subcadena en la cadena, o -1 si no se encuentra\n\"Hola mundo\".find(\"mundo\") devuelve 5\n\n\nupper()\nDevuelve una copia de la cadena con todos los caracteres en mayúscula\n\"Hola mundo\".upper() devuelve \"HOLA MUNDO\"\n\n\nlower()\nDevuelve una copia de la cadena con todos los caracteres en minúscula\n\"Hola mundo\".lower() devuelve \"hola mundo\"\n\n\nstrip()\nDevuelve una copia de la cadena sin los espacios en blanco al principio y al final\n\" Hola mundo \".strip() devuelve \"Hola mundo\".\n\n\nstrip(subcadena)\nDevuelve una copia de la cadena sin los caracteres de la subcadena al principio y al final. Sólo funciona para quitar elementos de los extremos del string\n\"Hola mundo\".strip(\"do\") devuelve \"Hola mun\"\n\n\nreplace(subcadena1, subcadena2)\nDevuelve una copia de la cadena reemplazando todas las apariciones de la subcadena1 por la subcadena2\n\"Hola mundo\".replace(\"mundo\", \"amigos\") devuelve \"Hola amigos\"\n\n\nsplit()\nDevuelve una lista de subcadenas separando la cadena por los espacios en blanco\n\"Hola mundo  \".split() devuelve [\"Hola\", \"mundo\"]\n\n\nsplit(separador)\nDevuelve una lista de subcadenas separando la cadena por el separador\n\"Hola, mundo\".split(\", \") devuelve [\"Hola\", \"mundo\"]\n\n\nisdigit()\nDevuelve True si todos los caracteres de la cadena son dígitos, False en caso contrario\n\"123\".isdigit() devuelve True\n\n\nisalpha()\nDevuelve True si todos los caracteres de la cadena son letras, False en caso contrario\n\"Hola\".isalpha() devuelve True\n\n\nisalnum()\nDevuelve True si todos los caracteres de la cadena son letras o dígitos, False en caso contrario\n\"Hola123\".isalnum() devuelve True\n\n\ncapitalize()\nDevuelve una copia de la cadena con el primer caracter en mayúscula y el resto en minúscula\n\"hola mundo\".capitalize() devuelve \"Hola mundo\"\n\n\nindex(subcadena)\nDevuelve el índice de la primera aparición de la subcadena en la cadena, o produce un error si no se encuentra\n\"Hola mundo\".index(\"mundo\") devuelve 5"
  },
  {
    "objectID": "unidad_4.html#tuplas",
    "href": "unidad_4.html#tuplas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.4 Tuplas",
    "text": "4.4 Tuplas\nLas tuplas son una secuencia de elementos inmutable. Esto significa que no se pueden modificar una vez creadas. En Python, el tipo de dato asociado a las tuplas se llama tuple y se definen con paréntesis ():\ntupla = (1, 2, 3)\nLas tuplas pueden tener elementos de cualquier tipo, es decir, pueden ser heterogéneas. Por ejemplo, podemos tener una tupla con un número, un string y un booleano:\ntupla = (1, \"Hola\", True)\nUna tupla de un sólo elemento (unitaria) debe definirse de la siguiente manera:\ntupla = (1,)\nLa coma al final es necesaria para diferenciar una tupla de un número entre paréntesis (1).\n\nEjemplos de tuplas podrían ser:\n\nUna fecha, representada como una tupla de 3 elementos: día, mes y año: (1, 1, 2020)\nDatos de una persona: (nombre, edad, dni): (\"Carla\", 30, 12345678)\n\nIncluso es posible anidar tuplas, como por ejemplo guardar, para una persona, la fecha de nacimiento: (\"Carla\", 30, 12345678, (1, 1, 1990))\n\n4.4.1 Tuplas como Secuencias\nComo las tuplas son secuencias, al igual que las cadenas, podemos utilizar la misma notación de índices para obtener cada uno de sus elementos y, de la misma forma que las cadenas, los elementos comienzan a enumerarse en su posición desde el 0:\n\nfecha = (1, 12, 2020)\nprint(fecha[0])\n\n1\n\n\nTambién podemos usar la notación de rangos, o slices, para obtener subconjuntos de la tupla. Esto es algo típico de las secuencias:\n\nfecha = (1, 12, 2020)\nprint(fecha[0:2])\n\n(1, 12)\n\n\n\n\n4.4.2 Tuplas como Inmutables\nAl igual que con las cadenas, las componentes de las tuplas no pueden ser modificadas. Es decir, no puedo cambiar los valores de una tupla una vez creada:\nfecha = (1, 12, 2020)\nfecha[0] = 2\nTypeError: 'tuple' object does not support item assignment\n\n\n4.4.3 Longitud de una Tupla\nLa longitud de una tupla se puede obtener con la función predefinida len(), que devuelve la cantidad de elementos o componentes que tiene esa tupla:\n\nfecha = (1, 12, 2020)\nprint(len(fecha))\n\n3\n\n\nUna tupla vacía es una tupla que no tiene elementos: (). La longitud de una tupla vacía es 0.\n\nEjercicio Calcular la longitud de la tupla anidada (\"Carla\", 30, 12345678, (1, 1, 1990)). ¿Cuántos elementos tiene?\n\n\n\n4.4.4 Empaquetado y desempaquetado de tuplas\nSi a una variable se le asigna una secuencia de valores separados por comas, el valor de esa variable será la tupla formada por esos valores. Ejemplo:\n\na = 1\nb = 2\nc = 3\nd = a, b, c\n\nprint(d)\n\n(1, 2, 3)\n\n\nA esto se le llama empaquetado.\n\nDe forma similar, si se tiene una tupla de largo \\(k\\), se puede asignar cada uno de los elementos de la tupla a \\(k\\) variables distintas. Esto se llama desempaquetado.\n\nd = (1, 2, 3)\na, b, c = d\n\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nSi estamos desempaquetando una tupla de largo \\(k\\) pero lo hacemos en una cantidad de variables menor a \\(k\\), se producirá un error.\nd = (1, 2, 3)\na, b = d\nObtendremos:\nValueError: too many values to unpack\no\nValueError: not enough values to unpack"
  },
  {
    "objectID": "unidad_4.html#listas",
    "href": "unidad_4.html#listas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.5 Listas",
    "text": "4.5 Listas\nLas listas, al igual que las tuplas, también pueden usarse para modelar datos compuestos, pero cuya cantidad y valor varían a lo largo del tiempo. Son secuencias mutables, y vienen dotadas de una variedad de operaciones muy útiles.\nLa notación para lista es una secuencia de valores entre corchetes y separados por comas.\nlista = [1, 2, 3]\n\nlista_vacia = []\n\n4.5.1 Longitud de una Lista\nLa longitud de una lista se puede obtener con la función predefinida len(), que devuelve la cantidad de elementos que tiene esa lista:\n\nlista = [1, 2, 3]\nprint(len(lista))\n\n3\n\n\n\n\n4.5.2 Listas como Secuencias\nDe la misma forma que venimos haciendo con las cadenas y las tuplas, podremos acceder a los elementos de una lista a través de su índice, slicear y recorrerla con un ciclo for.\n\nlista = [1, 2, 3]\nprint(lista[0])\n\n1\n\n\n\nlista = [\"Civil\", \"Informática\", \"Química\", \"Industrial\"]\nprint(lista[1:3])\n\n['Informática', 'Química']\n\n\n\nlista = [\"Civil\", \"Informática\", \"Química\", \"Industrial\"]\nfor elemento in lista:\n    print(elemento)\n\nCivil\nInformática\nQuímica\nIndustrial\n\n\n\n\n4.5.3 Listas como Mutables\nA diferencia de las tuplas, las listas son mutables. Esto significa que podemos modificar sus elementos una vez creadas.\n\nPara cambiar un elemento de una lista, se usa la notación de índices:\n\n\nlista = [1, 2, 3]\nlista[0] = 4\nprint(lista)\n\n[4, 2, 3]\n\n\n\nPara agregar un elemento al final de una lista, se usa el método append():\n\n\nlista = [1, 2, 3]\nlista.append(4)\nprint(lista)\n\n[1, 2, 3, 4]\n\n\n\nPara agregar un elemento en una posición específica de una lista, se usa el método insert():\n\n\nlista = [1, 2, 3]\nlista.insert(0, 4)\nprint(lista)\n\n[4, 1, 2, 3]\n\n\nEl método ingresa el número 4 en la posición 0 de la lista, y desplaza el resto de los elementos hacia la derecha.\n\nlista = [1, 2, 3]\nlista.insert(1, 3)\nprint(lista)\n\n[1, 3, 2, 3]\n\n\nEl método ingresa el número 3 en la posición 1 de la lista, y desplaza el resto de los elementos hacia la derecha.\nLas listas no controlan si se insertan elementos repetidos, por lo que si queremos exigir unicidad, debemos hacerlo mediante otras herramientas en nuestro código.\n\nPara eliminar un elemento de una lista, se usa el método remove():\n\n\nlista = [1, 2, 3]\nlista.remove(2)\nprint(lista)\n\n[1, 3]\n\n\nRemove busca el elemento 2 en la lista y lo elimina. Si el elemento no existe, se produce un error.\nSi el valor está repetido, se eliminará la primera aparición del elemento, empezando por la izquierda.\n\nlista = [1, 2, 3, 2]\nlista.remove(2)\nprint(lista)\n\n[1, 3, 2]\n\n\n\nPara quitar el último elemento de una lista, se usa el método pop():\n\n\nlista = [1, 2, 3]\nlista.pop()\nprint(lista)\n\n[1, 2]\n\n\nEl método pop() devuelve el elemento que se eliminó de la lista. Si la lista está vacía, se produce un error.\n\nlista = [1, 2, 3]\nelemento = lista.pop()\nprint(elemento)\n\n3\n\n\n\nPara quitar un elemento de una lista en una posición específica, se usa el método pop() con un índice:\n\n\nlista = [1, 2, 3]\nlista.pop(1)\nprint(lista)\n\n[1, 3]\n\n\nAl igual que antes, el método pop() devuelve el elemento que se eliminó de la lista. Si la lista está vacía, se produce un error.\n\nextend() agrega los elementos de una lista al final de otra. Es lo mismo que concatenar dos listas con el operador +:\n\n\nlista1 = [1, 2, 3]\nlista2 = [4, 5, 6]\nlista1.extend(lista2)\nprint(lista1)\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\n4.5.4 Referencias de Listas\n\na = [1,2,3,4]\nb = a\na.pop()\n\nprint(b)\n\n[1, 2, 3]\n\n\nSe dice que b es una referencia a a. Esto significa que b no es una copia de a, sino que es a misma. Por lo tanto, si modificamos a, también modificamos b.\nUna forma de crear una copia de una lista es usando el método copy():\n\na = [1,2,3,4]\nb = a.copy()\na.pop()\n\nprint(b)\n\n[1, 2, 3, 4]\n\n\n\n\n4.5.5 Búsqueda de Elementos en una Lista\n\nPara saber si un elemento se encuentra en una lista, se puede utilizar el operador in:\n\n\nlista = [1, 2, 3]\nprint(2 in lista)\n\nTrue\n\n\nComo vemos, el operador in es válido para todas las secuencias, incluyendo tuplas y cadenas.\n\nPara averiguar la posición de un valor dentro de una lista, usaremos el método index():\n\n\nlista = [\"a\", \"b\", \"t\", \"z\"]\nprint(lista.index(\"t\"))\n\n2\n\n\nSi el valor no se encuentra en la lista, se produce un error.\nSi el valor se encuentra repetido, se devuelve la posición de la primera aparición del elemento, empezando por la izquierda.\n\n\n4.5.6 Iterando sobre Listas\nLas listas son secuencias, y por lo tanto podemos iterar sobre ellas. Esto significa que podemos recorrerlas con un ciclo for:\n\nlista = [1, 2, 3]\nfor elemento in lista:\n    print(elemento)\n\n1\n2\n3\n\n\nEsta forma de recorrer elementos usando for es utilizable con todos los tipos de secuencias.\n\n\n4.5.7 Ordenando Listas\nNos puede interesar que los elementos de una lista estén ordenados según algún criterio. Python provee dos operaciones para obtener una lista ordenada a partir de la desordenada.\n\nsorted(s) devuelve una lista ordenada con los elementos de la secuencia s. La secuencia s no se modifica.\n\n\nlista = [3, 1, 2]\nlista_nueva = sorted(lista)\n\nprint(lista)\nprint(lista_nueva)\n\n[3, 1, 2]\n[1, 2, 3]\n\n\n\ns.sort() ordena la lista s en el lugar. Es decir, modifica la lista s y no devuelve nada.\n\n\nlista = [3, 1, 2]\nlista.sort()\n\nprint(lista)\n\n[1, 2, 3]\n\n\nTanto el método sort() como el método sorted() ordenan la lista en orden ascendente. Si queremos ordenarla en orden descendente, podemos usar el parámetro reverse:\n\nlista = [3, 1, 2]\nlista.sort(reverse=True)\nprint(lista)\n\n[3, 2, 1]\n\n\nExiste un método reverse (no disponible en Replit) que invierte la lista sin ordenarla. Una forma de reemplazarlo es usando slices, como ya vimos: lista[::-1].\n\n\n\n\n\n\n¡Cuidado con los Ordenamientos!\n\n\n\n\n\n\nTodos los elementos de la secuencia deben ser comparables entre sí. Si no lo son, se producirá un error. Por ejemplo, no se puede ordenar una lista que contenga números y strings.\nAl ordenar, las letras en minúscula no valen lo mismo que las letras en mayúscula. Si queremos ordenar “hola” y “HOLA” (por ejemplo), tenemos que compararlas convirtiendo todo a minúscula o todo a mayúscula.\nDe lo contrario, se ordena poniendo las mayúsculas primero y luego las minúsculas. Es decir, para una lista con los valores [\"hola\", \"HOLA\"], el ordenamiento será [\"HOLA\", \"hola\"].\n\n¿Existe una forma mejor de hacerlo? Sí. Usando keys de ordenamiento:\n\nlista = [\"hola\", \"HOLA\"]\nlista.sort(key=str.lower)\nprint(lista)\n\n['hola', 'HOLA']\n\n\nLo importante de momento es que sepas que existe esta forma de ordenar. A key se le puede pasar una función que se va a aplicar a cada elemento de la lista antes de ordenar. En este caso, la función str.lower convierte todo a minúscula antes de intentar ordenar.\n\n\n\n\n\n4.5.8 Listas por Comprensión\nLas listas por comprensión son una forma de crear listas de forma concisa y elegante.\nPor ejemplo, si queremos crear una lista con los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\nnumeros = []\nfor i in range(1, 11):\n    numeros.append(i)\nprint(numeros)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\nSin embargo, podemos hacerlo de forma más concisa usando una lista por comprensión:\n\nnumeros = [i for i in range(1, 11)]\nprint(numeros)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\nLa sintaxis de una lista por comprensión es la siguiente:\n[&lt;expresión&gt; for &lt;elemento&gt; in &lt;secuencia&gt;]\nLa expresión se evalúa para cada elemento de la secuencia, y el resultado de esa evaluación se agrega a la lista.\n\n\n4.5.9 Listas anidadas\nLas listas también puede estar anidadas, es decir, una lista puede contener a otras listas. Por ejemplo, podemos tener una lista de listas de números:\nvalores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nAquía \\(valores\\) es una lista que contiene 3 elementos, que a su vez son también listas. Entonces, valores[0] sería la lista [1,2,3]. Si quisiéramos, por ejemplo, acceder al número 2 de dicha lista, tendríamos que volver a acceder al índice 1 de la lista valores[0]:\n\nvalores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nnumero = valores[0][1]\nprint(numero)\n\n2\n\n\n\n\n\n\n\n\nGeneralización\n\n\n\nEste concepto de listas anidadas se puede generalizar a cualquier secuencia anidada. Por ejemplo, una tupla de tuplas, o una lista de tuplas, o una tupla de listas, etc.\n\ntupla = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\nnumero = tupla[1][2]\nprint(numero)\n\n6\n\n\n\nlista = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nnumero = lista[2][0]\nprint(numero)\n\n7\n\n\n\ntupla = ([1, 2, 3], [4, 5, 6], [7, 8, 9])\nnumero = tupla[0][1]\nprint(numero)\n\n2\n\n\nIncluso se puede reemplazar un elemento anidado por otro:\n\ntupla = ([1, 2, 3], [4, 5, 6], [7, 8, 9])\ntupla[0][1] = 10\nprint(tupla)\n\n([1, 10, 3], [4, 5, 6], [7, 8, 9])\n\n\nEsto es válido siempre y cuando el elemento a reemplazar esté dentro de una secuencia mutable. En el caso de arriba, estamos cambiando el valor de una lista, que se encuentra dentro de la tupla. La tupla no cambia: sigue teniendo 3 listas guardadas.\nSi quisiéramos editar una tupla guardada dentro de una lista, no funcionaría:\nlista = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nlista[0][1] = 10\nprint(lista)\nTypeError: 'tuple' object does not support item assignment\n\n\nLas listas anidadas suelen usarse para representar matrices. Para ello, se puede pensar que cada lista representa una fila de la matriz, y cada elemento de la lista representa un elemento de la fila. Por ejemplo, la matriz:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\n\\]\nse puede representar como la lista de listas:\nmatriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que reciba una cantidad de filas y una cantidad de columnas y devuelva una matriz de ceros de ese tamaño. Usar listas por comprensión.\nEjemplo: matrix(2,3) devuelve [[0, 0, 0], [0, 0, 0]]\n\n\n\n\n\nEjemplo Dada una lista de tuplas de dos elementos (precio, producto), desempaquetar la lista en dos listas separadas: una con los precios y otra con los productos.\n\n\nlista = [(100, \"Coca Cola\"), (200, \"Pepsi\"), (300, \"Sprite\")]\n\nprecios = []\nproductos = []\n\nfor precio, producto in lista: # Acá estamos desempaquetando: precio, producto\n    precios.append(precio)\n    productos.append(producto)\n\nprint(precios)\nprint(productos)\n\n[100, 200, 300]\n['Coca Cola', 'Pepsi', 'Sprite']"
  },
  {
    "objectID": "unidad_4.html#operaciones-de-las-secuencias",
    "href": "unidad_4.html#operaciones-de-las-secuencias",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.7 Operaciones de las Secuencias",
    "text": "4.7 Operaciones de las Secuencias\nTanto las cadenas, como las tuplas y las listas son secuencias, y por lo tanto comparten una serie de operaciones que podemos realizar sobre ellas.\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\nx in s\nDevuelve True si el elemento x se encuentra en la secuencia s, False en caso contrario \n\n\ns + t\nConcatena las secuencias s y t\n\n\ns * n\nRepite la secuencia s n veces\n\n\ns[i]\nDevuelve el elemento de la secuencia s en la posición i\n\n\ns[i:j:k]\nDevuelve un slice de la secuencia s desde la posición i hasta la posición j (no incluída), con pasos de a k\n\n\nlen(s)\nDevuelve la cantidad de elementos de la secuencia s\n\n\nmin(s)\nDevuelve el elemento mínimo de la secuencia s\n\n\nmax(s)\nDevuelve el elemento máximo de la secuencia s\n\n\nsum(s)\nDevuelve la suma de los elementos de la secuencia s\n\n\nenumerate(s)\nDevuelve una secuencia de tuplas de la forma (i, s[i]) para cada elemento de la secuencia s\n\n\ncount(x)\nDevuelve la cantidad de veces que aparece el elemento x en la secuencia s\n\n\nindex(x)\nDevuelve el índice de la primera aparición del elemento x en la secuencia s\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos que pruebes cada una de estas operaciones con las distintas secuencias que vimos en este capítulo.\n\n\nAdemás, es posible crear una lista o tupla a partir de cualquier otra secuencia, usando las funciones list y tuple respectivamente:\n\nlista = list(\"Hola\")\nprint(lista)\n\n['H', 'o', 'l', 'a']\n\n\n\ntupla = tuple(\"Hola\")\nprint(tupla)\n\n('H', 'o', 'l', 'a')\n\n\n\nlista = list( (1, 2, 3) ) # Convertimos una tupla en una lista\nprint(lista)\n\n[1, 2, 3]\n\n\nEsta última es particularmente útil cuando necesitamos trabajar con una tupla, pero como son inmutables, la convertimos a lista para manipularla sin problemas.\n\nEjemplo Escribir una función que le pida al usuario que ingrese números enteros positivos, los vaya agregando a una lista, y que cuando el usuario ingrese un 0, devuelva la lista de números ingresados.\n\ndef ingresar_numeros():\n    numeros = []\n    numero = int(input(\"Ingrese un número: \"))\n\n    while numero != 0:\n        numeros.append(numero)\n        numero = int(input(\"Ingrese un número: \"))\n    return numeros\n\n\n\n\n\n\nEjemplo Escribir una función que cuente la cantidad de letras que tiene una cadena de caracteres, y devuelva su valor.\nLuego, usar esa función como key para ordenar la siguiente lista: [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"].\n\n\ndef contar_letras(cadena):\n    return len(cadena)\n\nlista = [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"]\nlista.sort(key=contar_letras)\n\nprint(lista)\n\n['Año', 'Messi', 'Arañas', 'Camiseta', 'Murcielago', 'Onomatopeya']\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que cuente la cantidad de vocales que tiene una cadena de caracteres, y devuelva su valor. Debe considerar mayúsculas y minúsculas. Pista: podés usar la función para saber si una letra es vocal que hiciste en la unidad 3.\nLuego, usar esa función como key para ordenar la siguiente lista: [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"]."
  },
  {
    "objectID": "unidad_4.html#listas-y-cadenas",
    "href": "unidad_4.html#listas-y-cadenas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.6 Listas y Cadenas",
    "text": "4.6 Listas y Cadenas\nVimos que las cadenas tienen el método split, que nos permite separar una cadena en una lista de subcadenas. Por ejemplo:\n\ncadena = \"Esta es una      cadena con    espacios   varios\"\nlista = cadena.split()\n\nprint(lista)\n\n['Esta', 'es', 'una', 'cadena', 'con', 'espacios', 'varios']\n\n\nTambién podemos hacer lo contrario: podemos unir una lista de subcadenas en una cadena usando el método join:\n\nlista = [\"Esta\", \"es\", \"una\", \"cadena\", \"con\", \"espacios\", \"varios\"]\ncadena = \" \".join(lista)\n\nprint(cadena)\n\nEsta es una cadena con espacios varios\n\n\nLa sintaxis del método join es:\n&lt;separador&gt;.join(&lt;lista&gt;)\nEl separador es el caracter que se va a usar para unir los elementos de la lista. En el ejemplo, el separador es un espacio \" \", pero puede ser cualquier caracter. La lista contiene a las subcadenas que se van a unir."
  }
]