[
  {
    "objectID": "unidad_3.html#decisiones",
    "href": "unidad_3.html#decisiones",
    "title": "3  Estructuras de Control",
    "section": "3.1 Decisiones",
    "text": "3.1 Decisiones\n\nEjemplo Leer un número y, si el número es positivo, imprimir en pantalla “Número positivo”.\n\nNecesitamos decidir de alguna forma si nuestro número \\(x\\) es positivo (&gt;0) o no. Para resolver este problema, introducimos una nueva instrucción, llamada condicional: if.\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nDonde if es una palabra reservada, &lt;expresion&gt; es una condición y &lt;cuerpo es un bloque de código que se ejecuta sólo si la condición es verdadera.\nPor lo tanto, antes de seguir explicando sobre la instrucción if, debemos entender qué es una condición. Estas expresiones tendrán valores del tipo sí o no.\n\n3.1.1 Expresiones Booleanas\nLas expresiones booleanas forman parte de la lógica binomial, es decir, sólo pueden tener dos valores: True o False. Estos valores no tienen elementos en común, por lo que no se pueden comparar entre sí. Por ejemplo, True &gt; False no tiene sentido. Y además, son complementarios: algo que no es True, es False; y algo que no es False, es True. Son las únicas dos opciones posibles.\nPython, además de los tipos numéricos como inty float, y de las cadenas de caracteres str, tiene un tipo de datos llamado bool. Este tipo de datos sólo puede tener dos valores: True o False. Por ejemplo:\nn = 3 # n es de tipo 'int' y tiene valor 3\nb = True # b es de tipo 'bool' y tiene valor True\n\n\n3.1.2 Expresiones de Comparación\nLas expresiones booleanas se pueden construir usando los operadores de comparación: sirven para comparar valores entre sí, y permiten construir una pregunta en forma de código.\nPor ejemplo, si quisiéramos saber si 5 es mayor a 3, podemos construir la expresión:\n\n5 &gt; 3\n\nTrue\n\n\nComo 5 es en efecto mayor a 3, esta expresión, al ser evaluada, nos devuelve el valor True.\nSi quisiéramos saber si 5 es menor a 3, podemos construir la expresión:\n\n5 &lt; 3\n\nFalse\n\n\nComo 5 no es menor a 3, esta expresión, al ser evaluada, nos devuelve el valor False.\nLas expresiones booleanas de comparación que ofrece Python son:\n\n\n\nExpresión\nSignificado\n\n\n\n\na == b\na es igual a b\n\n\na != b\na es distinto de b\n\n\na &lt; b\na es menor que b\n\n\na &gt; b\na es mayor que b\n\n\na &lt;= b\na es menor o igual que b\n\n\na &gt;= b\na es mayor o igual que b\n\n\n\nVeamos algunos ejemplos:\n5 == 5\n\n5 != 5\n\n5 &lt; 5\n\n5 &gt;= 5\n\n5 &gt; 4\n\n5 &lt;= 4\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos probar estas expresiones para ver qué valores devuelven. Podés hacerlo de dos formas:\n\nGuardando el resultado de la expresión en una variable, para luego imprimirla:\n\nresultado = 5 == 5\nprint(resultado)\n\nImprimiendo directamente el resultado de la expresión:\n\nprint(5 == 5)\n\n\n\n\n3.1.3 Operadores Lógicos\nAdemás de los operadores de comparación, Python también tiene operadores lógicos, que permiten combinar expresiones booleanas para construir expresiones más complejas. Por ejemplo, quizás no sólo queremos saber si 5 es mayor a 3, sino que también queremos saber si 5 es menor que 10. Para esto, podemos usar el operador and:\n5 &gt; 3 and 5 &lt; 10\nPython tiene tres operadores lógicos: and, or y not. Veamos qué hacen:\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\na and b\nEl resultado es Truesolamente si aes Truey bes True. Ambos deben ser True, de lo contrario devuelve False.\n\n\na or b\nEl resultado es Truesi aes True o bes True (o ambos). Si ambos son False, devuelve False.\n\n\nnot a\nEl resultado es True si aes False, y viceversa.\n\n\n\nAlgunos ejemplos:\n\n5 &gt; 2 and 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 or 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 and 5 &gt; 6\n\nFalse\n\n\n\n5 &gt; 2 or 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 6\n\nFalse\n\n\n\nnot 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 2\n\nTrue\n\n\n\nnot 5 &gt; 2\n\nFalse\n\n\n\n\n\n\n\n\nPrioridad de Operadores\n\n\n\n\n\nLas expresiones lógicas complejas (con más de un operador), se resuelven al igual que en matemáticas: respetando precedencias y de izquierda a derecha. También admiten el uso de () para alterar las precedencias.\nSin embargo, si no tenemos precedencias explícitas con (), Python prioriza resolver primero los and, luego los or y por último los not.\nEjemplos:\n\nTrue or False and False\n\nTrue\n\n\nPor la prioridad del and, primero se resuelve False and False, que da False. Luego, se resuelve True or False, que da True.\n\nTrue or False or False\n\nTrue\n\n\nComo no hay and, se resuelve de izquierda a derecha. Primero se resuelve True or False, que da True. Luego, se resuelve True or False, que da True.\n\n(True or False) and False\n\nFalse\n\n\nComo hay paréntesis, se resuelve primero lo que está dentro de los paréntesis. True or False da True. Luego, True and False da False.\n\n\n\n\n\n3.1.4 Comparaciones Simples\nVolvamos al problema inicial: Queremos saber, dado un número \\(x\\), si es positivo o no, e imprimir un mensaje en consecuencia.\nRecordemos la instrucción if que acabamos de introducir y que sirve para tomar decisiones simples. Esta instrucción tiene la siguiente estructura:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\ndonde:\n\n&lt;expresion&gt;debe ser una expresión lógica.\n&lt;cuerpo&gt;es un bloque de código que se ejecuta sólo si la expresión es verdadera.\n\n\n\n\nDiagrama de Flujo para la instrucción if\n\n\nComo ahora ya sabemos cómo construir condiciones de comparación, vamos a comparar si nuestro número x es mayor a 0:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n\nPodemos probarlo:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\n\n\nComo vemos, si el número es positivo, se imprime el mensaje. Pero si el número no es positivo, no se imprime nada. Necesitamos además agregar un mensaje “Número no positivo”, si es que la condición no se cumple.\nModifiquemos el diseño: 1. Si \\(x&gt;0\\), se imprime “Número positivo”. 2. En caso contrario, se imprime “Número no positivo”.\nPodríamos probar con el siguiente código:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if not x &gt; 0:\n      print(\"Número no positivo\")\n\nOtra solución posible es:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if x &lt;= 0:\n      print(\"Número no positivo\")\n\nAmbas están bien. Si lo probamos, vemos que funciona:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\nSin embargo, hay una mejor forma de hacer esta función. Existe una condición alternativa para la estructura de decisión if, que tiene la forma:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nelse:\n    &lt;cuerpo&gt;\ndonde if y else son palabras reservadas. Su efecto es el siguiente:\n\nSe evalúa la &lt;expresion&gt;.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\nDiagrama de Flujo para la instrucción if-else\n\n\nPor lo tanto, podemos reescribir nuestra función de la siguiente forma:\n\ndef imprimir_si_positivo_o_no(x): # le cambiamos el nombre\n  if x &gt; 0:\n      print(\"Número positivo\")\n  else:\n      print(\"Número no positivo\")\n\nProbemos:\n\nimprimir_si_positivo_o_no(5)\nimprimir_si_positivo_o_no(-5)\nimprimir_si_positivo_o_no(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\n¡Sigue funcionando!\nLo importante a destacar es que, si la condición del if es verdadera, se ejecuta el &lt;cuerpo&gt; del if y no se ejecuta el &lt;cuerpo&gt; del else. Y viceversa: si la condición del if es falsa, se ejecuta el &lt;cuerpo&gt; del else y no se ejecuta el &lt;cuerpo&gt; del if. Nunca se ejecutan ambos casos, porque son caminos paralelos que no se cruzan, como vimos en el diagrama de flujo más arriba.\n\n\n3.1.5 Múltiples decisiones consecutivas.\nSupongamos que ahora queremos imprimir un mensaje distinto si el número es positivo, negativo o cero. Podríamos hacerlo con dos decisiones consecutivas:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\") # cuerpo del primer if\n  else:\n      if x == 0:                      #\n          print(\"Número cero\")        #\n      else:                           #\n          print(\"Número negativo\")    # todo esto es el cuerpo del primer else\n\nA esto se le llama anidar, y es donde dentro de unas ramas de la decisión (en este caso, la del else), se anida una nueva decisión. Pero no es la única forma de implementarlo. Podríamos hacerlo de la siguiente forma:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  elif x == 0:\n      print(\"Número cero\")\n  else:\n      print(\"Número negativo\")\n\nLa estructura elif es una abreviatura de else if. Es decir, es un else que tiene una condición. Su efecto es el siguiente:\n\n\n\nDiagrama de Flujo para la instrucción if-elif-else del ejemplo\n\n\n\nSe evalúa la &lt;expresion&gt; del if.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se evalúa la &lt;expresion&gt; del elif.\nSi la &lt;expresion&gt; del elif es verdadera, se ejecuta su &lt;cuerpo&gt;.\nSi la &lt;expresion&gt; del elif es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\n\n\n\nSabías que… ?\n\n\n\n\n\nEn Python se consideran verdaderos (True) también todos los valores numéricos distintos de 0, las cadenas de caracteres que no sean vacías, y cualquier valor que no sea vacío en general. Los valores nulos o vacíos son falsos.\nif x == 0:\nes equivalente a:\nif not x:\nY además, existe el valor especial None, que representa la ausencia de valor, y es considerado falso. Podemos preguntar si una variable tiene el valor None usando el operador is:\nif x is None:\no también:\nif not x:\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nDebemos calcular el pago de una persona empleada en nuestra empresa. El cálculo debe hacerse por la cantidad de horas trabajadas, y se le debe pedir al usuario la cantidad de horas y cuánto vale cada hora.\nAdicionalmente, se abona un plus fijo de guardería a todo empleado/a con infantes a su cargo. Y se paga un 10% de incentivo a todo empleado/a que haya trabajado 30 horas o más y no reciba el plus por guardería.\n\nPista: pensar los distintos tipos de liquidación:\na) Empleado/a con menos de 30 horas y sin infantes a cargo.\nb) Empleado/a con 30 horas o más y sin infantes a cargo.\nc) Empleado/a con menos de 30 horas y con infantes a cargo.\nd) Empleado/a con 30 horas o más y con infantes a cargo.\n\n\n\n\n\n\nAyuda: Flujo de la resolución\n\n\n\n\n\n\n\n\nDiagrama de Flujo para el desafío"
  },
  {
    "objectID": "unidad_3.html#ciclos-y-rangos",
    "href": "unidad_3.html#ciclos-y-rangos",
    "title": "3  Estructuras de Control",
    "section": "3.2 Ciclos y Rangos",
    "text": "3.2 Ciclos y Rangos\nSupongamos que en una fábrica se nos pide hacer un procedimiento para entrenar al personal nuevo. Para comenzar se nos encarga la descripción de uno muy simple: descarga de cajas de material del camión del proveedor y almacenamiento en el depósito. Así que aplicamos lo que venimos aprendiendo hasta ahora sobre algoritmos y describimos la operación para la descarga de 3 cajas:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte\n\n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Colocar la caja sobre el piso en el sector correspondiente \n7 Ir al garage o playón donde estacionó el camión\n\n8 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n9 Caminar sosteniendo la caja hasta el depósito \n10 Colocar la caja sobre la caja anterior \n11 Ir al garage o playón donde estacionó el camión\n\n12 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n13 Caminar sosteniendo la caja hasta el depósito \n14 Colocar la caja sobre la caja anterior\n\n15 Apagar luces y cerrar puerta del depósito \n16 Ir al garage o playón donde estacionó el camión \n17 Cerrar y trabar puertas del camión \n18 Avisar fin de descarga al transportista\nYa lo tenemos. Ahora el jefe dice que en el camión suelen venir entre 5 y 15 cajas de material y nos pide que definas el mismo procedimiento para todos los casos posibles. Notemos que se repiten las instrucciones 2, 3, 4, 5 y 6 para cada caja ¿Qué hacemos? ¿Vamos a seguir copiando y pegando las instrucciones para cada caja? ¿Y si algún día vienen más de 15 o menos de 5? ¿Vamos a tener una lista de instrucciones distinta para cada cantidad de cajas que puedan venir? Parece ser necesario hacer algo más genérico que le facilite la vida a todos. Una nueva versión:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte \n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Si es la primera caja, colocarla sobre el piso en el sector correspondiente;\nsi no, apilarla sobre la anterior;\nsalvo que ya haya 3 apiladas,\nen ese caso colocarla a la derecha sobre el piso \n7 Ir al garage o playón donde estacionó el camión \n\n8 Repetir 4,5,6,7 mientras queden cajas para descargar \n\n9 Cerrar y trabar puertas del camión \n10 Avisar fin de descarga al transportista \n11 Volver a depósito \n12 Apagar luces y cerrar puerta del depósito\nEsta descripción es bastante más compacta y cubre todas las posibles cantidades de cajas en un envío (habituales y excepcionales), de modo que con una única página en el manual de procedimientos será suficiente.\nSin embargo, los algoritmos que venimos escribiendo se parecen más al primer procedimiento que al segundo. ¿Cómo podemos mejorarlos?\n\n\n\n\n\n\nCiclos\n\n\n\nEl ciclo, bucle o sentencia iterativa es una instrucción que permite ejecutar un bloque de código varias veces. En Python, existen dos tipos de ciclos: while y for.\n\n\n\n3.2.1 Ciclo for\nLa instrucción for nos indica que queremos repetir un bloque de código una cierta cantidad de veces. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\nfor i in range(1, 11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo for incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nfor &lt;nombre&gt; in &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice definido porque una vez evaluada la &lt;expresion&gt;, se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: tantas veces como elementos tenga la &lt;expresion&gt;.\nLa expresión puede indicarse con range:\n\nrange(n) devuelve una secuencia de números desde 0 hasta n-1.\nrange(a, b) devuelve una secuencia de números desde a hasta b-1.\nrange(a, b, c) devuelve una secuencia de números desde a hasta b-1, de a c en c.\n\nSe podría decir que el range puede recibir 3 valores: range(start, end, step) o range(inicio, fin, paso), donde:\n\nstart o inicio es el valor inicial de la secuencia. Por defecto es 0.\nend o fin es el valor final de la secuencia. No se incluye en la secuencia.\nstep o paso es el incremento entre cada elemento de la secuencia. Por defecto es 1.\n\nSi le pasamos un sólo parámetro, lo toma como end.\nSi le pasamos dos, los toma como start y end.\nY si le pasamos tres, los toma como start, end y step.\n\n\n\n\n\n\nNote\n\n\n\n¿Te suena quizás a algo que ya vimos? Quizás… ¿los slices de las cadenas de caracteres?\n\n\nAdemás, la variable &lt;nombre&gt; va a ir tomando el valor de cada elemento de la &lt;expresion&gt; en cada iteración. En nuestro ejemplo de imprimir los números del 1 al 10, vemos que i toma los valores 1, 2, 3, 4, 5, 6, 7, 8, 9 y 10, en ese orden.\n\n\nEjemplo\nSe pide una función que imprima todos los números pares entre dos números dados a y b. Se considera que a y b son siempre números enteros positivos, y que a es menor que b.\n\n\ndef imprimir_pares(a, b):\n  for i in range(a, b):\n    if i % 2 == 0: # si el resto de dividir por 2 es cero, es par\n      print(i)\n\nimprimir_pares(1,15)\n\n2\n4\n6\n8\n10\n12\n14\n\n\n\n\n\nEjemplo\nSe pide una función que imprima todos los números del 1 al 10, en orden inverso.\n\n\ndef imprimir_inverso():\n  for i in range(10, 0, -1):\n      print(i)\n\nimprimir_inverso()\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\n\n\n3.2.1.1 Iterables\nComo dijimos más arriba, la expresión del for puede ser cualquier expresión que devuelva una secuencia de valores. A estas expresiones se las llama iterables.\nUn ciclo for también podría iterar sobre elementos de una lista (tema que vamos a ver más adelante), o sobre caracteres de una palabra. Por ejemplo:\n\nfor num in [1, 3, 7, 5, 2]:\n    print(num)\n\n1\n3\n7\n5\n2\n\n\n\nfor c in \"Hola\":\n    print(c)\n\nH\no\nl\na\n\n\n\n\n\n3.2.2 Ciclo while\nLa instrucción while nos indica que queremos repetir un bloque de código mientras se cumpla una condición. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\ni = 1\nwhile i &lt; 11:\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo while incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nwhile &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice indefinido porque una vez evaluada la &lt;expresion&gt;, no se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: se ejecuta mientras la &lt;expresion&gt; sea verdadera.\nPara usar la instrucción while, tenemos cuatro aspectos para armar y afinar correctamente:\n\nCuerpo\nCondición\nEstado Previo\nPaso\n\nAntes, para la instrucción for, sólo considerábamos el cuerpo y la condición. Ahora, además, tenemos que considerar el estado previo y el paso.\nEl cuerpo es la porción de código que se repetirá mientras la condición sea verdadera.\nLa condición es la expresión booleana que se evalúa para decidir si se ejecuta el cuerpo o no.\nEl estado previo es el estado de las variables antes de ejecutar el cuerpo. En general, se refiere al estado de las variables que participan de la condición.\nEl paso es la porción de código que modifica el estado previo. En general, se refiere a la modificación de las variables que participan de la condición.\n\n\n\n\n\n\n\nWarning\n\n\n\nCon los ciclos while hay que tener mucho cuidado de no caer en un loop infinito. Esto sucede cuando la condición siempre es verdadera, y el cuerpo no modifica el estado previo. Por ejemplo:\nwhile True: # más adelante sobre el uso de `while True`\n    print(\"Hola\")\no bien:\ni = 0\nwhile i &lt; 10:\n    print(i) # el valor de i nunca cambia\n\n\n\nEjercicio\nRepetir el ejercicio 7.b de la guía 2 usando un ciclo while. Repetir usando un ciclo for. ¿Qué diferencias hay entre ambos?  \n\n\n\n3.2.3 Break, Continue y Return\nbreak y continueson dos palabras clave en Python que se utilizan en bucles (tanto for como while) para alterar el flujo de ejecución del bucle.\n\n3.2.3.1 Break\nLa declaración break se usa para salir inmediatamente de un bucle antes de que se complete su iteración normal. Cuando se encuentra una declaración break dentro de un bucle, el bucle for o while se detiene inmediatamente y continúa con la ejecución de las instrucciones que están después del mismo.\nPor ejemplo, supongamos que queremos encontrar al primer número múltiplo de 3 entre 10 y 30:\n\nnumero = 10\nwhile numero &lt;= 30:\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n  numero += 1\n\nEl primer número múltiplo de 3 es: 12\n\n\n\nfor numero in range(10, 31):\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n\nEl primer número múltiplo de 3 es: 12\n\n\n\n\n3.2.3.2 Continue\nLa declaración continue se usa para omitir el resto del código dentro de una iteración actual del bucle y continuar con la siguiente iteración. Cuando se encuentra una declaración continue dentro de un bucle, el bucle for o while salta a la siguiente iteración del bucle sin ejecutar las instrucciones que están después del continue.\nPor ejemplo, supongamos que queremos imprimir todos los números entre 1 y 20, excepto los múltiplos de 4:\n\nnumero = 1\nwhile numero &lt;= 20:\n  if numero % 4 == 0:\n      numero += 1\n      continue\n  print(numero)\n  numero += 1\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\nfor numero in range(1, 21):\n  if numero % 4 == 0:\n      continue\n  print(numero)\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotemos que tanto para el uso de break como de continue, si el código se encuentra con uno de ellos en la ejecución, no ejecuta nada posterior a ellos: en el caso de break, corta o interrumpe la ejecución del bucle; en el case de continue, saltea el resto del código de esa iteración y pasa a la siguiente, volviendo a evaluar la condición si el bucle es while.\n\n\n\n\n3.2.3.3 Return\nCuando estamos dentro de una función, la instrucción return nos permite devolver un valor y salir de la función. Ahora, si además estamos dentro de un ciclo, también nos permite salir del mismo sin ejecutar el resto del código.\nPor ejemplo:\n\ndef obtener_primer_par_desde(n):\n  for num in range(n, n+10):\n    print(f\"Analizando si el número {i} es par\")\n    if num % 2 == 0:\n      return num\n  return None\n\n\nobtener_primer_par_desde(9)\n\nAnalizando si el número 11 es par\nAnalizando si el número 11 es par\n\n\n10\n\n\nComo vemos, la función obtener_primer_par_desde recibe un número n, y devuelve el primer número par que encuentra a partir de n. Si no encuentra ningún número par, devuelve None.\nSi encuentra un número par, no sigue analizando el resto de los números. Usa return para salir del ciclo y devuelve el número encontrado.\n\n\n\n3.2.4 Consideraciones del While\nEs importante no ser redundantes con el código y no “hacer preguntas” que ya sabemos.\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\n\n&lt;codigo cuando ya no se cumple la condición&gt;\nVeamos un ejemplo:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nif numero == 3:\n  print(\"El número es 3\")\nelse:\n  print(\"El número no es 3\")\nEl output va a ser siempre el mismo:\n1\n2\n3\nEl número es 3\n¿Por qué? Porque nuestra condición del while es lo que dice “mientras esto se cumpla, yo repito el bloque del código de adentro”. Nuestra condición es que numero &lt; 3. En el momento en que numero llega a 3, el bucle whiledeja de cumplir con la condición, y la ejecución se corta, se termina con el bucle.\nEs decir, el bloque\nif numero == 3:\n  print(\"El número es 3\")\nsiempre se ejecuta.\nY el bloque\nelse:\n  print(\"El número no es 3\")\nnunca se ejecuta.\nPor lo tanto, podemos reescribir el código de la siguiente forma:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nprint(\"El número es 3\")\n\nDe la misma forma, no tendría sentido hacer algo así:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\n  if numero == 3:\n    break\n\nif numero == 3 está absolutamente de más. Si numero es 3, el bucle while no se ejecuta, por lo que nunca se va a llegar a esa línea de código. No es necesario “re-chequear” la condición del while dentro del mismo, porque asumimos que si llegamos a esa línea de código, es porque la condición se cumplió. Por lo tanto, podemos reescribir el código de la siguiente forma:\n\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\nAhora, el continue está de más también, porque se usa cuando nosotros queremos forzar a que el ciclo pase a la siguiente iteración. Pero en este caso, el ciclo ya va a pasar a la siguiente iteración, porque estamos en la última línea del cuerpo.\n\nEste es nuestro código final, escrito de forma correcta:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\n3.2.4.1 While True\nLa instrucción while está hecha para que se ejecute mientras la condición sea verdadera. Pero, ¿qué pasa si usamos while True? Lo que pasa al usar while True es que nuestro código se vuelve más propenso al error: si no tenemos cuidado, podemos caer en un loop infinito.\n\nComo no tenemos una condición a evaluar ni modificar en cada iteración, el bucle se ejecuta infinitamente. Dependería de nosotros, como programadores, que el bucle se corte en algún momento. Es decir, dependería de que nos acordemos de poner dentro del while alguna decisión que haga que el bucle se corte. Y si por alguna razón no nos acordamos, el bucle se ejecutaría infinitamente, dejando al programa “congelado” o “colgado”, sin responder, y usando todos los recursos de la computadora.\nEn pocas palabras, podemos afirmar que el uso de while True en Python es una mala práctica de programación, y recomendamos evitarla fuertemente.\n\n\n3.2.4.2 Modificando la Condición\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\nLa mejor decisión que se puede tomar para el  de un bloque while es asumir que, durante toda su ejecución exceptuando la última línea, la condición se cumple. Es decir, que el cuerpo del bucle se ejecuta mientras la condición sea verdadera. Por lo tanto, si queremos modificar la condición, debemos hacerlo en la última línea del cuerpo.\nPor ejemplo, esto no es correcto:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  numero += 1     # actualización de la condición\n  print(numero)\n\n1\n2\n3\n\n\nComo vemos, se imprimen los números 1, 2, 3; pero no el 0. Esto es porque estamos modificando la condición ni bien empieza el bucle, y no en la última línea del cuerpo.\nLa forma correcta de hacerlo sería:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1     # actualización de la condición\n\n0\n1\n2\n\n\nDe esta forma, todo lo que se encuentre antes de la última línea del cuerpo se ejecuta mientras la condición sea verdadera. Y la última línea del cuerpo es la que modifica la condición.\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número entero positivo y muestre por pantalla todos los números pares desde 1 hasta ese número.\nResolver primero usando un ciclo while y luego usando un ciclo for.\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número par. Mientras el usuario ingrese números que no cumplan con lo pedido, se lo debe volver a solicitar.\nPista: resolver usando while."
  }
]