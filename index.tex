% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Pensamiento Computacional},
  pdfauthor={Aldana Rastrelli, Juan Pablo Bulacios, Pablo Notari},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Pensamiento Computacional}
\author{Aldana Rastrelli, Juan Pablo Bulacios, Pablo Notari}
\date{2023-12-27}

\begin{document}
\maketitle
\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[borderline west={3pt}{0pt}{shadecolor}, breakable, enhanced, interior hidden, sharp corners, boxrule=0pt, frame hidden]}{\end{tcolorbox}}\fi

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\bookmarksetup{startatroot}

\hypertarget{pensamiento-computacional}{%
\chapter*{Pensamiento Computacional}\label{pensamiento-computacional}}
\addcontentsline{toc}{chapter}{Pensamiento Computacional}

\markboth{Pensamiento Computacional}{Pensamiento Computacional}

Bienvenidos y bienvenidas a la cátedra de Pensamiento Computacional del
Ciclo Básico Común de la Facultad de Ingeniería - UBA.

\hypertarget{docentes-de-la-cuxe1tedra}{%
\section*{Docentes de la Cátedra}\label{docentes-de-la-cuxe1tedra}}
\addcontentsline{toc}{section}{Docentes de la Cátedra}

\markright{Docentes de la Cátedra}

\begin{itemize}
\item
  \textbf{Prof.~Titular:} Méndez, Mariano
\item
  Bulacios, Juan Pablo
\item
  Notari, Pablo
\item
  Rastrelli, Aldana
\end{itemize}

\bookmarksetup{startatroot}

\hypertarget{la-materia}{%
\chapter*{La Materia}\label{la-materia}}
\addcontentsline{toc}{chapter}{La Materia}

\markboth{La Materia}{La Materia}

\hypertarget{fundamentaciuxf3n}{%
\section*{Fundamentación}\label{fundamentaciuxf3n}}
\addcontentsline{toc}{section}{Fundamentación}

\markright{Fundamentación}

El pensamiento computacional es una disciplina que ha sido definida como
``el conjunto de procesos de pensamiento implicados en la formulación de
problemas y sus soluciones, de manera que dichas soluciones sean
representadas de una forma que puedan ser efectivamente ejecutadas por
un agente de procesamiento de información'', entendiendo por esto último
a un humano, una máquina o una combinación de ambos.

Reconoce antecedentes en trabajos de la Carnegie Mellon University de la
década de 1960 y del Massachusetts Institute of Technology de alrededor
de 1980, aunque su auge en la educación superior llegó con la primera
década del siglo XXI.

Las herramientas básicas en las que se funda el pensamiento
computacional son la descomposición, la abstracción, el reconocimiento
de patrones y la algoritmia. Está ampliamente aceptado que estas
herramientas no sirven solamente a los profesionales de Ciencias de la
Computación y de Informática, sino a cualquier persona que deba resolver
problemas, con lo cual el pensamiento computacional deviene una técnica
de resolución de problemas. Actualmente, los y las profesionales de la
Ingeniería requieren de una capacidad analítica que les permita resolver
problemas, y en ese sentido el pensamiento computacional se convierte en
un soporte invaluable de esa competencia (cada vez más las ciencias de
la computación y la informática constituyen una ciencia básica para
todas las ingenierías).

Si bien el pensamiento computacional no necesariamente requiere del uso
de computadoras, la programación de computadoras se convierte en su
complemento ideal. En primer lugar, porque permite comprobar, mediante
la codificación de un algoritmo en un programa, la validez de la
solución encontrada al problema, de manera sencilla y prácticamente
inmediata. En segundo lugar, porque la programación incentiva la
creatividad, la capacidad para la autoorganización y el trabajo en
equipo. En tercer lugar, porque la programación constituye un recurso
habitual del trabajo en el campo profesional de la ingeniería.

\hypertarget{objetivos-generales}{%
\section*{Objetivos Generales}\label{objetivos-generales}}
\addcontentsline{toc}{section}{Objetivos Generales}

\markright{Objetivos Generales}

El objetivo general de la asignatura es que los/as estudiantes adquieran
habilidades de resolución de problemas de ingeniería mediante el soporte
de un lenguaje de programación multiparadigma.

\bookmarksetup{startatroot}

\hypertarget{introducciuxf3n-a-la-algoritmia-y-a-la-programaciuxf3n}{%
\chapter{Introducción a la Algoritmia y a la
Programación}\label{introducciuxf3n-a-la-algoritmia-y-a-la-programaciuxf3n}}

\hypertarget{introducciuxf3n}{%
\section{Introducción}\label{introducciuxf3n}}

Como en todas las disciplinas, la Ingeniería de Software y la
Programación de Sistemas en general tienen un \textbf{lenguaje técnico}
específico. La utilización de ciertos términos y el compartir de ciertos
conceptos agiliza el diálogo y mejora la comprensión con los pares.

En este capítulo vamos a hacer una breve introducción de ciertos
conceptos, ideas y modelos que van a permitirnos establecer acuerdos y
manejar un lenguaje común.

\hypertarget{la-computadora}{%
\subsection{La Computadora}\label{la-computadora}}

Una computadora es un dispositivo físico de procesamiento de datos, con
un propósito general. Todos los programas que escribiremos serán
ejecutados (o \emph{corridos}) en una computadora. Una computadora es
capaz de procesar datos y obtener nueva información o resultados.

\hypertarget{software-y-hardware}{%
\subsection{Software y Hardware}\label{software-y-hardware}}

Toda computadora funciona con software y hardware. El software es el
conjunto de herramientas abstractas (programas), y se le llama
\textbf{componente lógica} del modelo computacional. El hardware es el
\textbf{componente físico} del dispositivo. Básicamente, el software
dice qué hacer, y el hardware lo hace.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{\textbf{¿Es indispensable tener una computadora para crear un
algoritmo?}\\
}, rightrule=.15mm, toprule=.15mm, left=2mm]

La respuesta, sorprendentemente, es no: muchos de los algoritmos que se
utilizan de forma computacional hoy en día fueron diseñados varias
décadas atrás. Pero la implementación de un algoritmo depende del grado
de avance del hardware y la tecnología disponible.

\end{tcolorbox}

\hypertarget{sistema-operativo}{%
\subsection{Sistema Operativo}\label{sistema-operativo}}

El sistema operaativo es el programa encargado de administrar los
recursos del sistema. Los recursos (como la memoria, por ejemplo) son
disputados entre diferentes programas o procesos ejecutándose al mismo
tiempo. El sistema operativo es el que decide cómo administrar y asignar
los recursos disponibles.

Los sistemas operativos más comunes el día de hoy son: Windows, Linux,
iOS, Android; por ejemplo.

\hypertarget{algoritmo}{%
\subsection{Algoritmo}\label{algoritmo}}

\textbf{Un algoritmo es una serie finita de pasos precisos para alcanzar
un objetivo.}

\begin{itemize}
\tightlist
\item
  ``serie'': porque son continuados uno detrás del otro, de forma
  ordenada.
\item
  ``finita'': porque no pueden ser pasos infinitos, en algún momento
  deben terminar.
\item
  ``pasos precisos'': porque en un algoritmo se debe ser lo más
  específico posible.
\end{itemize}

\begin{quote}
\textbf{Ejemplo} Un algoritmo puede ser una receta de cocina: tiene una
serie finita de pasos (son ordenados, uno detrás de otro, finitos porque
en algún momento deben terminar), que son precisos (porque tienen
indicaciones de cuánto agregar de cada ingrediente, cómo incorporarlo a
la preparación, etc) y están orientados en alcanzar un objetivo (obtener
una comida en particular).
\end{quote}

\hypertarget{creaciuxf3n-de-un-algoritmo}{%
\subsubsection{Creación de un
Algoritmo}\label{creaciuxf3n-de-un-algoritmo}}

La forma en la que trabajaremos la creación de un algoritmo es siguiendo
los siguientes pasos: 1. Análisis del problema: entender el objetivo y
los posibles casos puntuales del mismo. 2. Primer borrador de solución:
confeccionar una idea generalizada de cómo podría resolverse el
problema. 3. División del problema en partes: dividir el problema en
partes ayuda a descomponer un problema complejo en varios más sencillos.
4. Ensamble de las partes para la versión final del algoritmo: acoplar
todo el conjunto de partes del problema para lograr el objetivo general.

Estos cuatro pasos podrán iterarse (repetirse) la cantidad de veces que
sean necesarios, para poder lograr acercarnos más a la solución en cada
iteración.

\hypertarget{programa}{%
\subsection{Programa}\label{programa}}

\textbf{Un programa es un algoritmo escrito en un lenguaje de
programación.}

\hypertarget{lenguaje-de-programaciuxf3n}{%
\subsection{Lenguaje de
Programación}\label{lenguaje-de-programaciuxf3n}}

Un lenguaje de programación es un \textbf{protocolo de comunicación}.\\
Un protocolo es un \textbf{conjunto de normas consensuadas}.\\
\(\implies\) Entonces, un lenguaje de programación es un conjunto de
normas consensuadas, entre la persona y la máquina, para poder
comunicarse.

Cuando logramos que un \emph{lenguaje} pueda ser comprendido por el
humano y por la máquina, tenemos una comunicación efectiva en donde
podremos hacer programas y pedirle a la máquina que los ejecute.

Un buen ejemplo de cómo una computadora interpreta nuestras
instrucciones sin pensar al respecto, sin tener sentido común y sin
ambigüedades, es \href{https://www.youtube.com/watch?v=cDA3_5982h8}{este
video}. La computadora lo único que hace es \emph{interpretar} de forma
explícita lo que nosotros le pedimos que haga.

Un lenguaje de programación tiene reglas estrictas que se deben respetar
y no se admiten ambiguedades o sobreentendidos.

\hypertarget{entorno-de-desarrollo}{%
\subsection{Entorno de Desarrollo}\label{entorno-de-desarrollo}}

Un entorno de desarrollo es un conjunto de herramientas que nos permiten
escribir, editar, compilar y ejecutar programas.\\

En la materia utilizaremos un entorno de desarrollo llamado Replit, que
nos permite escribir código en un editor de texto, compilarlo y
ejecutarlo en un mismo lugar de forma online. Pero existen muchos otros
entornos de desarrollo, como por ejemplo Visual Studio Code, Eclipse,
NetBeans, etc.

\hypertarget{lenguaje-python}{%
\section{Lenguaje Python}\label{lenguaje-python}}

En este curso utilizaremos el lenguaje de programación \textbf{Python}.
Python es un lenguaje de programación de propósito general, que se
utiliza en muchos ámbitos de la industria y la academia.

Python es un lenguaje realmente fácil de aprender, con una curva de
aprendizaje muy suave. Es un lenguaje de alto nivel, lo que significa
que es un lenguaje que se asemeja mucho al lenguaje natural, y que no
requiere de conocimientos de bajo nivel para poder utilizarlo.

\hypertarget{hola-mundo}{%
\subsection{Hola, Mundo!}\label{hola-mundo}}

El primer programa que se escribe en cualquier lenguaje de programación
es el programa ``Hola, Mundo!''. Este programa es un programa que
imprime en pantalla el texto ``Hola, Mundo!''.

En Python, el programa ``Hola, Mundo!'' se escribe de la siguiente
forma:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hola, Mundo!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola, Mundo!
\end{verbatim}

\texttt{print} es una función que imprime en pantalla el texto que se le
pasa entre paréntesis. En este caso, el texto que se le pasa como
parámetro es \texttt{"Hola,\ Mundo!"}. Al escribir las comillas dobles,
estamos indicando que el texto que se encuentra entre ellas es un texto
literal.

De la misma forma, podremos imprimir cualquier otro mensaje en pantalla,
como por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hola, me llamo Rosita y soy programadora"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola, me llamo Rosita y soy programadora
\end{verbatim}

Al igual que Rosita, al hacer nuestro primer `Hola, Mundo!' nos
convertimos en programadores. ¡Felicitaciones!

A partir de la próxima clase, comenzaremos a ver cómo escribir programas
más complejos, que nos permitan resolver problemas más interesantes.

\hypertarget{anexo-replit}{%
\section{Anexo: Replit}\label{anexo-replit}}

\hypertarget{creaciuxf3n-de-una-nueva-cuenta}{%
\subsection{Creación de una nueva
cuenta}\label{creaciuxf3n-de-una-nueva-cuenta}}

Para utilizar replit vamos a ingresar a \url{https://replit.com/}.\\

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_start.png}

}

\caption{Página de inicio de Replit}

\end{figure}

Vamos a presionar luego en \texttt{Sign\ Up}, donde va a pedir crear una
cuenta, o iniciar sesión si ya tenemos una. Una de nuestras opciones es,
si tenemos una cuenta google ya creada, iniciar sesión con eso. De lo
contrario, podemos crear una cuenta nueva con un mail.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_signup.png}

}

\caption{Página de creación de cuenta de Replit}

\end{figure}

\hypertarget{creaciuxf3n-de-un-nuevo-proyecto}{%
\subsection{Creación de un nuevo
proyecto}\label{creaciuxf3n-de-un-nuevo-proyecto}}

Una vez creada la cuenta e iniciado sesión, vamos a ver esta pantalla:

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_home.png}

}

\caption{Home de Replit}

\end{figure}

En la misma vamos a ver muchas opciones, pero la que nosotros nos
interesa es el botón de \texttt{+\ Create\ Repl}, que nos va a permitir
crear un nuevo proyecto.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_create_repl.png}

}

\caption{Botón de creación de un nuevo proyecto en Replit}

\end{figure}

Se va a abrir la siguiente ventana:
\includegraphics{./imgs/unidad_1/replit_create_repl2.png}

Donde vamos a buscar y elegir en ``Templates'' el lenguaje de
programación Python. Luego, vamos a asignarle un nombre y seleccionar
``Create repl''.\\
Se debería ver algo así:

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_create_repl3.png}

}

\caption{Ventana completa de creación de un nuevo proyecto en Replit}

\end{figure}

\hypertarget{uso-del-nuevo-proyecto}{%
\subsection{Uso del nuevo proyecto}\label{uso-del-nuevo-proyecto}}

Los espacios o proyectos en replit se llaman \texttt{Workspace}, que
significa \texttt{espacio\ de\ trabajo}. En este espacio de trabajo
vamos a poder escribir código, ejecutarlo, y ver los resultados de la
ejecución.

Una vez creado el espacio de trabajo, se nos va a abrir una pantalla
donde vamos a ver varias cosas.

Inicialmente, tenemos en el centro el espacio de edición de código,
donde vamos a escribir nuestro programa.
\includegraphics{./imgs/unidad_1/replit_workspace1.png}

En la parte superior, vamos a ver un botón de \texttt{Run}, que nos va a
permitir ejecutar el programa que escribimos.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_workspace2.png}

}

\caption{Botón de ejecución de código}

\end{figure}

En la parte derecha, vamos a ver el resultado de la ejecución del
programa. En este caso, como no escribimos nada, no hay nada para
mostrar.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_workspace3.png}

}

\caption{Resultado de la ejecución de código}

\end{figure}

Finalmente, en la parte izquierda vamos a tener el menú de archivos,
donde vamos a poder crear nuevos archivos, borrarlos, etc. También tiene
el acceso a otras herramientas que de momento no vamos a estar usando.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_1/replit_workspace4.png}

}

\caption{Menú de archivos}

\end{figure}

Vamos a ver que en el menú de archivos ya tenemos un archivo creado,
llamado \texttt{main.py}. Este archivo es el archivo principal de
nuestro programa, y es el que se ejecuta cuando presionamos el botón de
\texttt{Run}.\\
Si bien podemos tener otros archivos, el único que se ejecuta cuando
presionamos \texttt{Run} es \texttt{main.py}. Por lo tanto, es
importante que nuestro programa principal o lo que nosotros queremos
correr, esté en este archivo. Lo que podemos hacer, es crear otros
archivos para ir guardando nuestro código y ejercicios anteriores sin
necesidad de que se ejecuten cada vez que presionamos \texttt{Run}.

\begin{quote}
\textbf{¡Probemos el espacio de trabajo!} Vamos a escribir en el archivo
\texttt{main.py} el siguiente código: \texttt{print("Hola,\ Mundo!")}.
Luego, vamos a presionar el botón de \texttt{Run} y vamos a ver el
resultado en la parte derecha de la pantalla.
\end{quote}

¡Felicitaciones! Ya escribiste tu primer programa en Python.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{}, rightrule=.15mm, toprule=.15mm, left=2mm]

¿Lograste ver el resultado? ¿Qué pasa si presionás el botón de
\texttt{Run} varias veces seguidas?\\

\end{tcolorbox}

\bookmarksetup{startatroot}

\hypertarget{tipos-de-datos-expresiones-y-funciones}{%
\chapter{Tipos de Datos, Expresiones y
Funciones}\label{tipos-de-datos-expresiones-y-funciones}}

\hypertarget{sentencias-buxe1sicas}{%
\section{Sentencias Básicas}\label{sentencias-buxe1sicas}}

En esta unidad vamos a centrarnos en la herramienta que vamos a emplear,
que es Python. Vamos a hacer un programa sencillo, interactuar con el
usuario y más.

\hypertarget{flujo-de-control-de-un-programa}{%
\subsection{Flujo de Control de un
Programa}\label{flujo-de-control-de-un-programa}}

El flujo de control de un programa es la forma en la que se ejecutan las
instrucciones de un programa. En Python, el flujo de control es
secuencial, es decir, se ejecutan las instrucciones una detrás de otra.
En otros lenguajes de programación, el flujo de control puede ser
condicional o repetitivo.

\textbf{Ejemplo:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Esta línea se ejecutaría primero        ↓}
\NormalTok{Esta línea se ejecutaría después        ↓}
\NormalTok{Esta línea se ejecutaría a lo último    }
\end{Highlighting}
\end{Shaded}

En este curso, la comunicación de los programas con el mundo exterior se
realizará casi exclusivamente con el usuario por medio de la consola (o
terminal, la presentamos en la unidad anterior en el anexo de Replit).

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{¡Cuidado!}, rightrule=.15mm, toprule=.15mm, left=2mm]

Esto no significa que todos los programas siempre se comuniquen con el
usuario para todo. Pensemos en las aplicaciones que usamos generalmente,
como instagram: imaginémonos si para cada acción que hiciéramos dentro
de la app la misma nos preguntara si queremos hacerlo o no:\\

\textbf{- ``¿Estás seguro/a de que querés iniciar sesión?''}\\
\textbf{- ``¿Estás seguro/a de que querés traer tu nombre de usuario
para mostrarse en el perfil?''}\\
\textbf{- ``¿Estás seguro/a de que querés traer tu foto de usuario para
mostrarse en el perfil?''}\\

Sería extremadamente molesto. Uno simplemente inicia sesión, y hay un
montón de cosas y procesos que se ejecutan uno detrás de otro,
automáticamente.\\

Hay cosas que no necesitan de la interacción del usuario. Nosotros nos
vamos a centrar en la interacción con el usuario en gran parte del
curso, pero no es lo único que se puede hacer. Los programas pueden
comunicarse con otros programas y las partes de un mismo programa pueden
comunicarse con otras partes del mismo programa.~ Más adelante vamos a
ver un poco más de esta diferencia.

\end{tcolorbox}

\hypertarget{valores-y-tipos}{%
\subsection{Valores y Tipos}\label{valores-y-tipos}}

Si tenemos la operación \texttt{7\ *\ 5}, sabemos que el resultado es
\texttt{35}. Decimos que tanto \texttt{7}, \texttt{5} como \texttt{35}
son \emph{valores}. En los lenguajes de programación, cada valor tiene
un \emph{tipo}.

En este caso, \texttt{7}, \texttt{5} y \texttt{35} son \emph{enteros} (o
\emph{integers} en inglés). En Python, los enteros se representan con el
tipo \texttt{int}.

Python tiene dos tipos de datos numéricos: - número enteros - números de
punto flotante

Los \textbf{números enteros} representan un valor entero exacto, como
\texttt{42}, \texttt{0}, \texttt{-5} o \texttt{10000}.\\
Los \textbf{números de punto flotante} tienen una parte fraccionaria,
como \texttt{3.14159}, \texttt{1.0} o \texttt{0.0}.

Según los operandos (los valores que se operan) y el operador (el
símbolo que indica la operación), el resultado puede ser de un tipo u
otro. Por ejemplo, si tenemos \texttt{7\ /\ 5}, el resultado es
\texttt{1.4}, que es un número de punto flotante. Si tenemos
\texttt{7\ +\ 5}, el resultado es \texttt{12}, que es un número entero.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

Vamos a elegir usar enteros cada vez que necesitemos recordar, almacenar
o representar un valor exacto, como pueden ser por ejemplo: la cantidad
de alumnos, cuántas veces repetimos una operación, un número de
documento, etc.\\
Vamos a elegir usar números de punto flotante cada vez que necesitemos
recordar, almacenar o representar un valor aproximado, como pueden ser
por ejemplo: la altura o el peso de una persona, la temperatura de un
día, una distancia recorrida, etc.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.30000000000000004
\end{verbatim}

Como vemos, cuando hay números de punto flotante, el resultado es
aproximado. \texttt{0.1\ +\ 0.2} nos debería dar \texttt{0.3}, pero nos
da \texttt{0.30000000000000004}. Esto es porque los números de punto
flotante son aproximados, y no pueden representar todos los valores de
forma exacta. Esto es algo que vamos a tener que tener en cuenta cuando
trabajemos con números de punto flotante.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Uso de punto}, rightrule=.15mm, toprule=.15mm, left=2mm]

Notemos que para representar números de punto flotante, usamos el punto
(\texttt{.}) y no la coma (\texttt{,}). Esto es porque en Python, la
coma se usa para separar valores, como vamos a ver más adelante.

\end{tcolorbox}

Además de efectuar operaciones matemáticas, Python nos permite trabajar
con porciones de texto, que se llaman \textbf{cadenas} (o \emph{strings}
en inglés). Las cadenas se representan con el tipo \texttt{str}.\\
Las cadenas se escriben entre comillas simples
(\texttt{\textquotesingle{}}) o dobles (\texttt{"}).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( }\StringTok{"¡Hola!"}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
¡Hola!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}¡Hola!\textquotesingle{}}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
¡Hola!
\end{verbatim}

Las cadenas también tienen operaciones disponibles, como por ejemplo la
concatenación, que es la unión de dos cadenas en una sola. Esto se hace
con el operador \texttt{+}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( }\StringTok{"¡Hola!"} \OperatorTok{+} \StringTok{" ¿Cómo estás?"}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
¡Hola! ¿Cómo estás?
\end{verbatim}

Vamos a ver más de estas operaciones más adelante.

\hypertarget{variables}{%
\subsection{Variables}\label{variables}}

Python nos permite asignarle un nombre a un valor, de forma tal que
podamos ``recordarlo'' y usarlo más adelante. A esto se le llama
\textbf{asignación}.\\
Estos nombres se llaman \textbf{variables}, y son espacios donde podemos
almacenar valores.\\

La asignación se hace con el operador \texttt{=} de la siguiente forma:
\texttt{\textless{}nombre\textgreater{}\ =\ \textless{}valor\ o\ expresion\textgreater{}}.

\textbf{Ejemplos:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(y }\OperatorTok{*} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
14
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lenguaje }\OperatorTok{=} \StringTok{"Python"}

\NormalTok{texto }\OperatorTok{=} \StringTok{"Estoy programando en "} \OperatorTok{+}\NormalTok{ lenguaje}
\BuiltInTok{print}\NormalTok{(texto)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Estoy programando en Python
\end{verbatim}

En este ejemplo, creamos las siguientes variables:

\begin{itemize}
\tightlist
\item
  x
\item
  y
\item
  lenguaje
\item
  texto
\end{itemize}

y las asociamos a los valores 5, 7, ``Python'' y ``Estoy programando en
Python'' respectivamente. Luego podemos usar esas variables como parte
de cualquier expresión, y en el momento de evaluarla, Python reemplazará
las variables por su valor asociado.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Variables y Constantes}, rightrule=.15mm, toprule=.15mm, left=2mm]

Si el dato es inmutable (no puede cambiar) durante la ejecución del
programa, se dice que ese dato es una \textbf{constante}. Si tiene la
habilidad de cambiar, se dice que es una variable. En Python, todas las
variables son mutables, es decir, pueden cambiar su valor durante la
ejecución del programa.\\
Y no sólo pueden cambiar su valor, sino también su tipo:
\texttt{x\ =\ 5} y \texttt{x\ =\ "Hola"} son dos asignaciones válidas, y
se pueden hacer una debajo de la otra:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{5}
\NormalTok{x }\OperatorTok{=} \StringTok{"Hola"}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola
\end{verbatim}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Nombres de Variables}, rightrule=.15mm, toprule=.15mm, left=2mm]

No se puede usar el mismo nombre para dos datos diferentes a la vez; una
variable puede referenciar un sólo dato por vez. Si se usa un mismo
nombre para un dato diferente, se pierde la referencia al dato
anterior.\\

\end{tcolorbox}

\hypertarget{funciones}{%
\subsection{Funciones}\label{funciones}}

Para poder realizar algunas operaciones particulares, necesitamos
introducir el concepto de \emph{función}. Una función es un bloque de
código que se ejecuta cuando se la llama.\\
Es un fragmento de programa que permite efectuar una operación
determinada. \texttt{abs}, \texttt{print}, \texttt{max} son ejemplos de
funciones de Python: \texttt{abs}permite calcular el valor absoluto de
un número, \texttt{print} permite mostrar un valor por pantalla y
\texttt{max} permite calcular el máximo entre dos valores.\\

Una función puede recibir 0 o más \emph{parámetros} o \emph{argumentos},
que son valores que se le pasan a la función entre paréntesis y
separados por comas, para que los use.\\

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{abs}\NormalTok{(}\OperatorTok{{-}}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"¡Hola!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
¡Hola!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{max}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
\end{verbatim}

La función recibe los parámetros, efectúa una operación y devuelve un
\emph{resultado}.

Python viene equipado de muchas funciones predefinidas, pero nosotros
como programadores debemos ser capaces de escribir nuevas instrucciones
para la computadora. Las grandes aplicaciones como el correo
electrónico, navegación web, chat, juegos, etc. no son más que grandes
programas implementados introduciendo nuevas funciones a la máquina,
escritas por uno o más programadores.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/funcion.png}

}

\caption{Una función recibe parámetros y devuelve un resultado}

\end{figure}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Python es Case Sensitive}, rightrule=.15mm, toprule=.15mm, left=2mm]

Python es Case Sensitive, es decir, distingue entre mayúsculas y
minúsculas.\\
Es muy importante respetar mayúsculas y minúsculas: PRINT() o prINT() no
serán reconocidas. Esto aplica para todo lo que escribamos en nuestros
programas.

\end{tcolorbox}

Si queremos crear una función que nos devuelva un saludo a Lucia cada
vez que se la llama, debemos ingresar el siguiente conjunto de líneas en
Python:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ saludar\_lucia():}
  \ControlFlowTok{return} \StringTok{"Hola, Lucia!"}
\end{Highlighting}
\end{Shaded}

Varias cosas a notar del código:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{saludar\_lucia} es el nombre de la función. Podría ser
  cualquier otro nombre, pero es una buena práctica que el nombre de la
  función describa lo que hace.\\
\item
  \texttt{def} es una palabra clave que indica que estamos definiendo
  una función.\\
\item
  \texttt{return} indica el valor que devuelve la función. Es decir, el
  \emph{resultado}. Puede devolverse una sola cosa, como en este caso, o
  varias cosas separadas por comas.\\
\item
  La sangría (el espacio inicial) en el renglón 2 le indica a Python que
  estamos dentro del \emph{cuerpo} de la función. El \emph{cuerpo} de la
  función es el bloque de código que se ejecuta cuando se llama a la
  misma.\\
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Sangría}, rightrule=.15mm, toprule=.15mm, left=2mm]

La sangría puede ingresarse utilizando dos o más espacios, o presionando
la tecla Tab. Es importante prestar atención en no mezclar espacios con
tabs, para evitar ``confundir'' al intérprete.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Firma de la función}, rightrule=.15mm, toprule=.15mm, left=2mm]

La firma de una función es la primera línea de la misma, donde se indica
el nombre de la función y los parámetros que recibe. La firma permite
identificar y diferenciar a una función de otra.

\end{tcolorbox}

Pero, como vemos, el bloque de código anterior no hace nada. Para que la
función haga algo, tenemos que llamarla. Para llamar a una función,
escribimos su nombre, seguido de paréntesis y los parámetros que recibe,
separados por comas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludar\_lucia()}
\end{Highlighting}
\end{Shaded}

Se dice que estamos \emph{invocando} o \emph{llamando} a la función. Y
al invocar una función, se ejecutan las instrucciones que habíamos
escrito en su cuerpo.\\

Pero de nuevo, vemos que no pasa nada. ¿Por qué? Porque la función usa
\texttt{return} para devolver un valor. Pero nosotros no estamos
haciendo nada con ese valor. Para poder verlo, tenemos que imprimirlo
por pantalla.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=}\NormalTok{ saludar\_lucia()}
\BuiltInTok{print}\NormalTok{(saludo)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola, Lucia!
\end{verbatim}

Lo que hicimos fue asignar el resultado devuelto por
\texttt{saludar\_lucia} a la variable \texttt{saludo}, y luego imprimir
el valor de la variable por pantalla.

Bueno, ahora podemos saludar a Lucia. Pero vamos a querer saludar a
otras personas también. ¿Cómo hacemos? Podemos hacer una función que
reciba el nombre de la persona a saludar como parámetro.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ saludar(nombre):}
  \ControlFlowTok{return} \StringTok{"Hola, "} \OperatorTok{+}\NormalTok{ nombre }\OperatorTok{+} \StringTok{"!"}
\end{Highlighting}
\end{Shaded}

De esta forma, podemos saludar a cualquier persona, pasando su nombre
como parámetro.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Esta es otra forma de imprimir, sin necesidad de guardarnos}
\CommentTok{\# el resultado de la función en una variable,}
\CommentTok{\# simplemente la imprimimos}
\BuiltInTok{print}\NormalTok{(saludar(}\StringTok{"Lucia"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola, Lucia!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(saludar(}\StringTok{"Serena"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola, Serena!
\end{verbatim}

\hypertarget{ejemplos}{%
\subsubsection{Ejemplos}\label{ejemplos}}

\begin{quote}
\textbf{Ejemplo}\\
Escribir una función que calcule el doble de un número.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ obtener\_doble(numero):}
  \ControlFlowTok{return}\NormalTok{ numero }\OperatorTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

Para invocarla, debemos llamarla pasándole un número:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{doble }\OperatorTok{=}\NormalTok{ obtener\_doble(}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(doble)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

\begin{quote}
\textbf{Ejemplo}\\
Pensá un número, duplícalo, súmale 6, divídelo por 2 y resta el número
que elegiste al comienzo. El número que queda es siempre 3.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ f(numero):}
  \ControlFlowTok{return}\NormalTok{ ((numero }\OperatorTok{*} \DecValTok{2}\NormalTok{) }\OperatorTok{+} \DecValTok{6}\NormalTok{) }\OperatorTok{/} \DecValTok{2} \OperatorTok{{-}}\NormalTok{ numero}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(f(}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3.0
\end{verbatim}

\hypertarget{ingreso-de-datos-por-consola}{%
\subsection{Ingreso de Datos por
Consola}\label{ingreso-de-datos-por-consola}}

Hasta ahora, los programas que hicimos no interactuaban con el usuario.
Pero para que nuestros programas sean más útiles, vamos a querer que el
usuario pueda ingresar datos, y que el programa pueda mostrarle datos
por pantalla. Para esto, vamos a usar la función \texttt{input}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{input}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Input es una función que bloquea el flujo del programa, esperando a que
el usuario ingrese una entrada por consola y presione \emph{enter}.
Cuando el usuario presiona \emph{enter}, la función devuelve el valor
ingresado por el usuario.\\

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{input}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\StringTok{"terminé!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si corremos el bloque de código anterior, vamos a tener un
comportamiento como este:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  La consola va a quedar vacía, esperando el ingreso del usuario
\item
  Ingresamos un valor, el que tengamos ganas, y presionamos enter.
\item
  La consola muestra el mensaje ``terminé!''.
\end{enumerate}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/input1.png}

}

\caption{Input bloquea el flujo del programa}

\end{figure}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/input2.png}

}

\caption{Ingresamos un valor (puede ser un número, texto, o ambos)}

\end{figure}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/input3.png}

}

\caption{Al presionar Enter, la consola muestra el mensaje ``terminé!''}

\end{figure}

\hypertarget{obteniendo-el-valor-ingresado}{%
\subsubsection{Obteniendo el Valor
Ingresado}\label{obteniendo-el-valor-ingresado}}

Como dijimos más arriba, la función \texttt{input} devuelve el valor
ingresado por el usuario. Para poder usarlo, tenemos que guardarlo en
una variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nombre }\OperatorTok{=} \BuiltInTok{input}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hola, "} \OperatorTok{+}\NormalTok{ nombre }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/ejemplo_input1.png}

}

\caption{Ingresamos ``Mariana'' y presionamos Enter.}

\end{figure}

Para hacer nuestro programa más amigable, podemos mostrarle al usuario
un mensaje antes de pedirle que ingrese un valor. Para esto, podemos
pasarle un parámetro a la función \texttt{input}, que es el mensaje que
queremos mostrarle al usuario.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nombre }\OperatorTok{=} \BuiltInTok{input}\NormalTok{(}\StringTok{"Ingresá tu nombre: "}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hola, "} \OperatorTok{+}\NormalTok{ nombre }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/ejemplo_input2.png}

}

\caption{Ingresamos ``Mariana'' y presionamos Enter.}

\end{figure}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{¡Cuidado!}, rightrule=.15mm, toprule=.15mm, left=2mm]

A partir de la guía 2, a menos que el ejercicio diga específicamente
``pedirle al usuario'', no se debe usar \texttt{input}, sino que todo
tiene que recibirse por parámetro en la función.

Lo mismo con \texttt{print}: A menos que el ejercicio diga
específicamente ``imprimir'', todo siempre se tiene que devolver con un
return.

\end{tcolorbox}

\hypertarget{buenas-pruxe1cticas-de-programaciuxf3n}{%
\section{Buenas Prácticas de
programación}\label{buenas-pruxe1cticas-de-programaciuxf3n}}

\hypertarget{sobre-comentarios}{%
\subsection{Sobre Comentarios}\label{sobre-comentarios}}

Los comentarios son líneas que se escriben en el código, pero que no se
ejecutan. Sirven para que el programador pueda dejar notas en el código,
para que se entienda mejor qué hace el programa.\\
Los comentarios se escriben con el símbolo \texttt{\#}. Todo lo que esté
a la derecha del \texttt{\#} no se ejecuta. También se pueden encerrar
entre tres comillas dobles (\texttt{"""}) para escribir comentarios de
varias líneas.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Esto es un comentario}

\CommentTok{""" Esto es un comentario}
\CommentTok{de varias líneas """}
\end{Highlighting}
\end{Shaded}

No es correcto escribir comentarios que no aporten nada al código, o
tener el código absolutamente plagado de comentarios. Los comentarios
deben ser útiles, y deben aportar información que no se pueda inferir
del código. Nuestro primer intento de hacer el código más entendible no
tienen que ser los comentarios, sino mejorar el código en sí.

\hypertarget{sobre-convenciuxf3n-de-nombres}{%
\subsection{Sobre Convención de
Nombres}\label{sobre-convenciuxf3n-de-nombres}}

Para nombres de variables y funciones, se usa snake\_case, que es
básicamente dejar todas las palabras en minúscula y unirlas con un guión
bajo. Ejemplos: \texttt{numero\_positivo}, \texttt{sumar\_cinco},
\texttt{pedir\_numero}, etc.~ Siempre emplear un nombre que nos remita
al significado que tendrá ese dato, siempre en snake\_case:
\texttt{numero}, \texttt{letra}, \texttt{letra2},
\texttt{edad\_hermano}, etc.

\hypertarget{variables-1}{%
\subsubsection{Variables}\label{variables-1}}

Las variables son cosas. Entonces sus nombres son sustantivos:
\texttt{nombre}, \texttt{numero}, \texttt{suma}, \texttt{resta},
\texttt{resultado}, \texttt{respuesta\_usuario}. La única excepción son
las variables booleanas (ya las vamos a ver, son aquellas que pueden
guardar dos posibles valores: verdadero o falso), que suelen tener
nombres como \texttt{es\_par}, \texttt{es\_cero}, \texttt{es\_entero},
porque su valor es true o false.

A veces es útil alguna frase para identificar mejor el contenido:\\
\texttt{edad\_mayor\_hijo}, \texttt{apellido\_conyuge}

\hypertarget{funciones-1}{%
\subsubsection{Funciones}\label{funciones-1}}

Las funciones hacen algo. Entonces sus nombres son verbos. Se usan
siempre verbos en infinitivo (terminan en \texttt{-ar}, \texttt{-er},
\texttt{-ir}): \texttt{calcular\_suma}, \texttt{imprimir\_mensaje},
\texttt{correr\_prueba}, \texttt{obtener\_triplicado}, etc.\\
De nuevo, las excepciones son las funciones que devuelven un valor
booleano (V o F). Esas pueden llamarse como: \texttt{es\_par},
\texttt{da\_cero}, \texttt{tiene\_letra\_a}, porque devuelven verdadero
o falso, y eso nos confirma o niega la afirmación que hace el nombre.

\hypertarget{sobre-ordenamiento-de-cuxf3digo}{%
\subsection{Sobre Ordenamiento de
Código}\label{sobre-ordenamiento-de-cuxf3digo}}

Cuando uno corre Python, lo que hace el lenguaje es leer línea a línea
nuestro código. Lo que se puede ejecutar, lo ejecuta. Las funciones las
guarda en memoria para poder usarlas luego.\\
Entonces es más ordenado y prolijo primero poner todas las funciones, y
después el código ``ejecutable'' (si van a dejar código suelto en el
archivo).\\

Además, no olvidemos que Python tiene un flujo de control de arriba para
abajo. Si intentamos invocar funciones antes de que estén definidas
(\texttt{def}), Python no va a saber qué hacer, y nos va a tirar un
error.\\

\textbf{Esto es correcto:}

\textbf{Esto es incorrecto:}

\hypertarget{sobre-uso-de-paruxe1metros-en-funciones}{%
\subsection{Sobre uso de Parámetros en
Funciones}\label{sobre-uso-de-paruxe1metros-en-funciones}}

Una función se puede pensar como una caja cerrada o una fábrica. La
función tiene dos puertas: una de entrada y una de salida.\\
La puerta de entrada son los \texttt{parámetros} y la de salida es el
\texttt{output} (el resultado).

Cuando se llama o invoca a la función, la puerta de entrada se abre,
permitiéndonos enviarle (pasarle) cero, uno o más parámetros a la
función (según cómo esté definida). Los parámetros son datos que la
función necesida para funcionar, y como ya dijimos, se le pasan a la
misma entre los paréntesis de la llamada.\\

\begin{quote}
\textbf{Ejemplo:} \texttt{saludar(nombre)},
\texttt{imprimir\_elementos(lista)}, \texttt{sumar(numero1,\ numero2)},
etc.
\end{quote}

Una vez que la función se empieza a ejecutar, ambas puertas se cierran.
Esto quiere decir que, mientras la función se está ejecutando, nada
entra y nada sale de la misma.\\
La función debería trabajar únicamente con los datos que se le hayan
pasado por parámetro o que se le pidan al usuario dentro de ella, pero
no debería utilizar nada que esté por fuera de la misma.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{¡Cuidado!}, rightrule=.15mm, toprule=.15mm, left=2mm]

Python nos deja usar cosas por fuera de la función y sin recibir los
datos por parámetro, porque es un lenguaje muy benevolente. Pero está
mal usar cosas que no se hayan recibido por parámetro: es una mala
práctica.

\end{tcolorbox}

Una vez que la función terminó de ejecutarse, el o los valores de salida
(resultados) se devuelven por el output. Una función puede retornar uno
o más elementos, o podría simplemente no retornar nada.\\
\texttt{return\ suma}, \texttt{return\ numero1,\ numero2},
\texttt{return}, etc.

Podemos ver la diferencia entre enviar algo por parámetro y usarlo por
fuera de la función a continuación:

Esto está mal

Esto está bien

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ saludar():}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Hola, "} \OperatorTok{+}\NormalTok{ nombre }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}

\NormalTok{nombre }\OperatorTok{=} \StringTok{"Manuela"}
\NormalTok{saludar()}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ saludar(persona):}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Hola, "} \OperatorTok{+}\NormalTok{ persona }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}

\NormalTok{nombre }\OperatorTok{=} \StringTok{"Manuela"}
\NormalTok{saludar(nombre)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, rightrule=.15mm, toprule=.15mm, left=2mm]

Como podemos observar los nombres de los argumentos cuando se invoca y
en la definición de la firma pueden ser los mismos o distintos. En este
caso, la función sabe que está recibiendo algo como parámetro, y sabe
que dentro de su cuerpo a este dato lo va a identificar como
\texttt{persona}, pero no hace falta que la variable que nosotros le
pasamos como parámetro también se llame \texttt{persona}: en este caso
se llama \texttt{nombre}.\\

\end{tcolorbox}

\hypertarget{tipos-de-datos}{%
\section{Tipos de Datos}\label{tipos-de-datos}}

\hypertarget{datos-simples}{%
\subsection{Datos Simples}\label{datos-simples}}

Los programas trabajan con una gran variedad de datos. Los datos más
simples son los que ya vimos: números enteros, números de punto flotante
y cadenas.\\
Pero dependiendo de la naturaleza o el \textbf{tipo} de información,
cabrá la posibilidad de realizar distintas transformaciones aplicando
\textbf{operadores}. Por eso, a la hora de representar información no
sólo es importante que identifiquemos al dato y podamos conocer su
valor, sino saber qué tipo de tratamiento podemos darle.

Todos los lenguajes tienen tipos predefinidos de datos. Se llaman
predefinidos porque el lenguaje ya los conoce: sabe cómo guardarlos en
memoria y qué transformaciones puede aplicarles.

En Python, tenemos los siguientes tipos de datos:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Tipo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Descripción
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{int} & Números enteros & \texttt{5}, \texttt{0}, \texttt{-5},
\texttt{10000} \\
\texttt{float} & Números de punto flotante o reales & \texttt{3.14159},
\texttt{1.0}, \texttt{0.0} \\
\texttt{complex} & Números complejos & \texttt{(1,\ 2j)},
\texttt{(1.0,-2.0j)}, \texttt{(0,1j)}. La componente con \texttt{j} es
la parte imaginaria. \\
\texttt{bool} & Valores booleanos o valores lógicos & \texttt{True},
\texttt{False} \\
\texttt{str} & Cadenas de caracteres & \texttt{"Hola"},
\texttt{"Python"}, \texttt{"¡Hola,\ mundo!"}, \texttt{""} (cadena vacía,
no contiene ningún caracter) \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{¿Por qué se llaman ``cadenas de caracteres''?}, rightrule=.15mm, toprule=.15mm, left=2mm]

Porque son una cadena de caracteres, es decir, una secuencia de
caracteres. Por ejemplo, la cadena ``Hola'' está formada por los
caracteres ``H'', ``o'', ``l'' y ``a''.~Esto nos permite acceder a cada
uno de los caracteres de la cadena por separado si quisiéramos, o a
porciones de una cadena, como vamos a ver más adelante.\\
Más aún, podemos ver que el texto ``hola'' no será igual a ``aloh'' ni a
``Holá'', porque son cadenas distintas.\\
Un string permite almacenar cualquier tipo de caracter unicode dentro
(letras, números, símbolos, emojis, etc.).

\end{tcolorbox}

\hypertarget{operadores-numuxe9ricos}{%
\subsection{Operadores Numéricos}\label{operadores-numuxe9ricos}}

Los operadores son símbolos que representan una operación. Por ejemplo,
el operador \texttt{+} representa la suma.\\

Para transformar datos numéricos, emplearemos los siguientes operadores:

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
Símbolo & Definición & Ejemplo \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+} & Suma & \texttt{5\ +\ 3} \\
\texttt{-} & Resta & \texttt{5\ -\ 3} \\
\texttt{*} & Producto & \texttt{5\ *\ 3} \\
\texttt{**} & Potencia & \texttt{5\ **\ 2} \\
\texttt{/} & División & \texttt{5\ /\ 3} \\
\texttt{//} & División entera & \texttt{5\ //\ 3} \\
\texttt{\%} & Módulo o Resto & \texttt{5\ \%\ 3} \\
\texttt{+=} & Suma abreviada & \texttt{x\ =\ 0}\texttt{x\ +=\ 3} \\
\texttt{-=} & Resta abreviada & \texttt{x\ =\ 0}\texttt{x\ -=\ 3} \\
\texttt{*=} & Producto abreviado & \texttt{x\ =\ 0}\texttt{x\ *=\ 3} \\
\texttt{/=} & División abreviada & \texttt{x\ =\ 0}\texttt{x\ /=\ 3} \\
\texttt{//=} & División entera abreviada &
\texttt{x\ =\ 0}\texttt{x\ //=\ 3} \\
\texttt{\%=} & Módulo o Resto abreviado &
\texttt{x\ =\ 0}\texttt{x\ \%=\ 3} \\
\end{longtable}

Como pasa en matemática, para alterar cualquier precedencia (prioridad
de operadores) se pueden usar paréntesis.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{5} \OperatorTok{+} \DecValTok{3}\NormalTok{) }\OperatorTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{+}\NormalTok{ (}\DecValTok{3} \OperatorTok{*} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
11
\end{verbatim}

El orden de prioridad de ejecución para los operadores va a ser el mismo
que en matemática.

\hypertarget{operadores-de-texto}{%
\subsection{Operadores de Texto}\label{operadores-de-texto}}

Para transformar datos de texto, emplearemos los siguientes operadores:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Símbolo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Definición
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+} & Concatenación & \texttt{"Hola"\ +\ "\ "\ +\ "Mundo"} \\
\texttt{*} & Repetición & \texttt{"Hola"\ *\ 3} \\
\texttt{+=} & Concatenación abreviada &
\texttt{x\ =\ "Hola"}\texttt{x\ +=\ "\ Mundo"} \\
\texttt{*=} & Repetición abreviada &
\texttt{x\ =\ "Hola"}\texttt{x\ *=\ 3} \\
{[}k{]} o {[}-k{]} & Acceso a un caracter &
\texttt{"Hola"{[}0{]}}\texttt{"Hola"{[}-1{]}} \\
{[}k1:k2{]} & Acceso a una porción &
\texttt{"Hola"{[}0:2{]}}\texttt{"Hola"{[}1:{]}}\texttt{"Hola"{[}:2{]}}\texttt{"Hola"{[}:{]}} \\
\end{longtable}

De nuevo, para alterar precedencias, se deben usar \texttt{()}.

\hypertarget{manipulando-strings}{%
\subsubsection{Manipulando Strings}\label{manipulando-strings}}

Si bien esto se va a ahondar en la siguiente sesión de la materia, es
importante saber que los strings, como se dijo más arriba, son un
conjunto de caracteres. Pero no sólo un conjunto, sino un
\textbf{conjunto ordenado}. Esto quiere decir que cada caracter tiene
una posición dentro de la cadena, y que esa posición es importante.\\

Por ejemplo, la cadena \texttt{"Hola"} tiene 4 caracteres: \texttt{"H"},
\texttt{"o"}, \texttt{"l"} y \texttt{"a"}.\\
La posición de cada caracter es la siguiente:

\begin{longtable}[]{@{}ccccc@{}}
\toprule\noalign{}
Posición & 0 & 1 & 2 & 3 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Caracter & ``H'' & ``o'' & ``l'' & ``a'' \\
\end{longtable}

Entonces, si queremos acceder al caracter \texttt{"H"}, tenemos que usar
la posición 0. Si queremos acceder al caracter \texttt{"a"}, tenemos que
usar la posición 3.\\

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, rightrule=.15mm, toprule=.15mm, left=2mm]

Para acceder a un caracter de una cadena, usamos los corchetes
(\texttt{{[}{]}}) y dentro de ellos la posición del caracter que
queremos acceder.\\

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letra }\OperatorTok{=} \StringTok{"Hola"}\NormalTok{[}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(letra)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
H
\end{verbatim}

Pero no sólo puedo obtener los caracteres en las posicione de la
palabra, sino que puedo obtener \emph{slices} o \emph{porciones} de la
misma, usando algo que vemos por primera vez: los \textbf{rangos}.

Un rango tiene tres partes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[start : end : step]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{start} es el índice de inicio del rango. Si no se especifica,
  se toma el índice 0. El caracter en la posición de inicio siempre se
  incluye.
\item
  \texttt{end} es el índice de fin del rango. Si no se especifica, se
  toma el índice final de la cadena. El caracter en la posición de fin
  nunca se incluye.
\item
  \texttt{step} es el tamaño del paso. Si no se especifica, se toma el
  valor 1.
\end{itemize}

\begin{quote}
\textbf{Ejemplos:}
\end{quote}

\hypertarget{input-y-casteo}{%
\subsection{Input y Casteo}\label{input-y-casteo}}

Cuando usamos la función \texttt{input}, el valor que devuelve es
siempre una cadena. Esto es porque el usuario puede ingresar cualquier
cosa, y no sabemos qué tipo de dato es.\\

Por ejemplo, si le pedimos al usuario que ingrese un número, el usuario
puede ingresar un número entero, un número de punto flotante, un número
complejo, o incluso un texto. Entonces, el valor que devuelve
\texttt{input} es siempre una cadena, y nosotros tenemos que
transformarla al tipo de dato que necesitemos.\\

Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{edad }\OperatorTok{=} \BuiltInTok{input}\NormalTok{(}\StringTok{"Indique su edad:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Su edad es:"}\NormalTok{, edad\_nueva)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Imprimiendo Strings y Variables (Iterpolación de Cadenas)}, rightrule=.15mm, toprule=.15mm, left=2mm]

Existen muchas formas de concatenar variables con texto.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Usando el operador \texttt{+}: \texttt{"Su\ edad\ es:\ "\ +\ edad}
\item
  Usando el método \texttt{fstring}: \texttt{f"Su\ edad\ es:\ \{edad\}"}
\item
  Usando el caracter \texttt{,}: \texttt{print("Su\ edad\ es:",\ edad)}
\end{enumerate}

La forma más recomendada es la segunda, usando \texttt{fstring}. Pero
dependerá de cada caso.

\end{tcolorbox}

El problema es que, si bien nuestro código anterior funciona, no podemos
operar \texttt{edad} como si fuese un número, porque es un string.\\
El siguiente código va a fallar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{edad }\OperatorTok{=} \BuiltInTok{input}\NormalTok{(}\StringTok{"Indique su edad:"}\NormalTok{)}
\NormalTok{edad\_nueva }\OperatorTok{=}\NormalTok{ edad }\OperatorTok{+} \DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Edad siguiente:"}\NormalTok{, edad\_nueva)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/error_input1.png}

}

\caption{Ejecución del bloque de código}

\end{figure}

Como vemos, la consola nos arroja un error, o en términos simples
decimos que ``explotó''.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{¿Qué es un error?}, rightrule=.15mm, toprule=.15mm, left=2mm]

Los errores son información que nos da la consola para que podamos
corregir nuestro código.

\end{tcolorbox}

En este caso, nos dice que no se puede concatenar un string con un
int.\\
¿Por qué nos dice eso? Porque \texttt{edad} es un string: \texttt{"25"},
y estamos tratando de sumarle 1, que es un int: \texttt{1}.\\

Para poder operar con \texttt{edad} como si fuese un número, tenemos que
transformarla a un número. Esto se llama \textbf{castear}.\\

Para castear un valor a un tipo de dato, usamos el nombre del tipo de
dato, seguido de paréntesis y el valor que queremos castear.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{int}\NormalTok{(}\StringTok{"25"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

De esta forma, podemos modificar nuestro código anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{edad }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\StringTok{"Indique su edad:"}\NormalTok{)) }\CommentTok{\# Le agregamos int}
\NormalTok{edad\_nueva }\OperatorTok{=}\NormalTok{ edad }\OperatorTok{+} \DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Edad siguiente:"}\NormalTok{, edad\_nueva)}
\end{Highlighting}
\end{Shaded}

Y obtenemos un código que funciona correctamente.

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/error_input2.png}

}

\caption{Ejecución del bloque de código}

\end{figure}

De esta forma, podemos castear a varios tipos de datos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero\_entero }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\StringTok{"Ingrese un número"}\NormalTok{))}
\NormalTok{punto\_flotante }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\StringTok{"Ingrese un número"}\NormalTok{))}

\NormalTok{punto\_flotante2 }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(numero\_entero)}

\NormalTok{numero\_en\_str }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(numero\_entero)}
\end{Highlighting}
\end{Shaded}

Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nombre\_menor }\OperatorTok{=} \BuiltInTok{input}\NormalTok{(}\StringTok{\textquotesingle{}Ingresá el nombre de un conocido/a:\textquotesingle{}}\NormalTok{)}
\NormalTok{edad\_menor }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}Ingresá la edad de }\SpecialCharTok{\{}\NormalTok{ nombre\_menor }\SpecialCharTok{\}}\SpecialStringTok{ \textquotesingle{}}\NormalTok{))}
\NormalTok{nombre\_mayor }\OperatorTok{=} \BuiltInTok{input}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}Cómo se llama el hermano/a mayor de }\SpecialCharTok{\{}\NormalTok{nombre\_menor}\SpecialCharTok{\}}\SpecialStringTok{? \textquotesingle{}}\NormalTok{)}
\NormalTok{diferencia }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}Cuántos años más grande es }\SpecialCharTok{\{}\NormalTok{nombre\_mayor}\SpecialCharTok{\}}\SpecialStringTok{?  \textquotesingle{}}\NormalTok{))}

\NormalTok{edad\_mayor }\OperatorTok{=}\NormalTok{ edad\_menor }\OperatorTok{+}\NormalTok{ diferencia}

\BuiltInTok{print}\NormalTok{(nombre\_menor,}\StringTok{\textquotesingle{}tiene\textquotesingle{}}\NormalTok{,edad\_menor,}\StringTok{\textquotesingle{}años\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(nombre\_mayor,}\StringTok{\textquotesingle{}es mayor y tiene\textquotesingle{}}\NormalTok{, edad\_mayor, }\StringTok{\textquotesingle{}años\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{./imgs/unidad_2/ejemplo_casteo.png}

}

\caption{Ejecución del bloque de código}

\end{figure}

\hypertarget{bonus-track-algunas-funciones-predefinidas-de-python}{%
\section{Bonus Track: Algunas Funciones Predefinidas de
Python}\label{bonus-track-algunas-funciones-predefinidas-de-python}}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Recomendación}, rightrule=.15mm, toprule=.15mm, left=2mm]

Te recomendamos que te animes a probar estas funciones, para ver qué
hacen y terminar de entenderlas.

\end{tcolorbox}

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Función
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Definición
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo de uso
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{print()} & Imprime un mensaje o valor en la consola &
\texttt{print("Hello,\ world!")} \\
\texttt{input()} & Lee una entrada de texto desde el usuario &
\texttt{name\ =\ input("Enter\ your\ name:\ ")} \\
\texttt{abs()} & Devuelve el valor absoluto de un número &
\texttt{abs(-5)} \\
\texttt{round()} & Redondea un número al entero más cercano &
\texttt{round(3.7)} \\
\texttt{int()} & Convierte un valor en un entero &
\texttt{x\ =\ int("5")} \\
\texttt{float()} & Convierte un valor en un número de punto flotante &
\texttt{y\ =\ float("3.14")} \\
\texttt{str()} & Convierte un valor en una cadena de texto &
\texttt{message\ =\ str(42)} \\
\texttt{bool()} & Convierte un valor en un booleano &
\texttt{is\_valid\ =\ bool(1)} \\
\texttt{len()} & Devuelve la longitud (número de elementos) de un objeto
& \texttt{length\ =\ len("Hello")} \\
\texttt{max()} & Devuelve el valor máximo entre varios elementos o una
secuencia & \texttt{max(4,\ 9,\ 2)} \\
\texttt{min()} & Devuelve el valor mínimo entre varios elementos o una
secuencia & \texttt{min(4,\ 9,\ 2)} \\
\texttt{pow()} & Calcula la potencia de un número &
\texttt{result\ =\ pow(2,\ 3)} \\
\texttt{range()} & Genera una secuencia de números &
\texttt{numbers\ =\ range(1,\ 5)} \\
\texttt{type()} & Devuelve el tipo de un objeto &
\texttt{data\_type\ =\ type("Hello")} \\
\texttt{round()} & Redondea un número a un número de decimales
específico & \texttt{rounded\_num\ =\ round(3.14159,\ 2)} \\
\texttt{isinstance()} & Verifica si un objeto es una instancia de una
clase específica & \texttt{is\_instance\ =\ isinstance(5,\ int)} \\
\texttt{replace()} & Reemplaza todas las apariciones de un substring por
otro &
\texttt{text\ =\ "Hello,\ World!"}\texttt{new\_text\ =\ text.replace("Hello",\ "Hi")} \\
\texttt{eval(\textless{}expr\textgreater{})} & Evalúa una expresión &
\texttt{eval("2\ +\ 2")} \\
\end{longtable}

\bookmarksetup{startatroot}

\hypertarget{estructuras-de-control}{%
\chapter{Estructuras de Control}\label{estructuras-de-control}}

\hypertarget{decisiones}{%
\section{Decisiones}\label{decisiones}}

\begin{quote}
\textbf{Ejemplo} Leer un número y, si el número es positivo, imprimir en
pantalla ``Número positivo''.
\end{quote}

Necesitamos \emph{decidir} de alguna forma si nuestro número \(x\) es
positivo (\textgreater0) o no. Para resolver este problema, introducimos
una nueva instrucción, llamada \emph{condicional}: \texttt{if}.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{expresion}\OperatorTok{\textgreater{}}\NormalTok{:}
    \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Donde \texttt{if} es una palabra reservada,
\texttt{\textless{}expresion\textgreater{}} es una \emph{condición} y
\texttt{\textless{}cuerpo} es un bloque de código que se ejecuta sólo si
la condición es verdadera.

Por lo tanto, antes de seguir explicando sobre la instrucción
\texttt{if}, debemos entender qué es una \emph{condición}. Estas
expresiones tendrán valores del tipo \emph{sí} o \emph{no}.

\hypertarget{expresiones-booleanas}{%
\subsection{Expresiones Booleanas}\label{expresiones-booleanas}}

Las expresiones booleanas forman parte de la lógica binomial, es decir,
sólo pueden tener dos valores: \texttt{True} o \texttt{False}. Estos
valores no tienen elementos en común, por lo que no se pueden comparar
entre sí. Por ejemplo, \texttt{True\ \textgreater{}\ False} no tiene
sentido. Y además, son complementarios: algo que \textbf{no} es True, es
False; y algo que \textbf{no} es False, es True. Son las únicas dos
opciones posibles.

Python, además de los tipos numéricos como \texttt{int}y \texttt{float},
y de las cadenas de caracteres \texttt{str}, tiene un tipo de datos
llamado \texttt{bool}. Este tipo de datos sólo puede tener dos valores:
\texttt{True} o \texttt{False}. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{3} \CommentTok{\# n es de tipo \textquotesingle{}int\textquotesingle{} y tiene valor 3}
\NormalTok{b }\OperatorTok{=} \VariableTok{True} \CommentTok{\# b es de tipo \textquotesingle{}bool\textquotesingle{} y tiene valor True}
\end{Highlighting}
\end{Shaded}

\hypertarget{expresiones-de-comparaciuxf3n}{%
\subsection{Expresiones de
Comparación}\label{expresiones-de-comparaciuxf3n}}

Las expresiones booleanas se pueden construir usando los operadores de
comparación: sirven para comparar valores entre sí, y permiten construir
una pregunta en forma de código.

Por ejemplo, si quisiéramos saber si \texttt{5} es mayor a \texttt{3},
podemos construir la expresión:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

Como 5 es en efecto mayor a 3, esta expresión, al ser evaluada, nos
devuelve el valor \texttt{True}.

Si quisiéramos saber si \texttt{5} es menor a \texttt{3}, podemos
construir la expresión:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textless{}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

Como 5 no es menor a 3, esta expresión, al ser evaluada, nos devuelve el
valor \texttt{False}.

Las expresiones booleanas de comparación que ofrece Python son:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Expresión & Significado \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{a\ ==\ b} & \texttt{a} es igual a \texttt{b} \\
\texttt{a\ !=\ b} & \texttt{a} es distinto de \texttt{b} \\
\texttt{a\ \textless{}\ b} & \texttt{a} es menor que \texttt{b} \\
\texttt{a\ \textgreater{}\ b} & \texttt{a} es mayor que \texttt{b} \\
\texttt{a\ \textless{}=\ b} & \texttt{a} es menor o igual que
\texttt{b} \\
\texttt{a\ \textgreater{}=\ b} & \texttt{a} es mayor o igual que
\texttt{b} \\
\end{longtable}

Veamos algunos ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{==} \DecValTok{5}

\DecValTok{5} \OperatorTok{!=} \DecValTok{5}

\DecValTok{5} \OperatorTok{\textless{}} \DecValTok{5}

\DecValTok{5} \OperatorTok{\textgreater{}=} \DecValTok{5}

\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{4}

\DecValTok{5} \OperatorTok{\textless{}=} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, rightrule=.15mm, toprule=.15mm, left=2mm]

Te recomendamos probar estas expresiones para ver qué valores devuelven.
Podés hacerlo de dos formas:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Guardando el resultado de la expresión en una variable, para luego
  imprimirla:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resultado }\OperatorTok{=} \DecValTok{5} \OperatorTok{==} \DecValTok{5}
\BuiltInTok{print}\NormalTok{(resultado)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Imprimiendo directamente el resultado de la expresión:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{5} \OperatorTok{==} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\hypertarget{operadores-luxf3gicos}{%
\subsection{Operadores Lógicos}\label{operadores-luxf3gicos}}

Además de los operadores de comparación, Python también tiene operadores
lógicos, que permiten combinar expresiones booleanas para construir
expresiones más complejas. Por ejemplo, quizás no sólo queremos saber si
\texttt{5} es mayor a \texttt{3}, sino que también queremos saber si
\texttt{5} es menor que \texttt{10}. Para esto, podemos usar el operador
\texttt{and}:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{3} \KeywordTok{and} \DecValTok{5} \OperatorTok{\textless{}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

Python tiene tres operadores lógicos: \texttt{and}, \texttt{or} y
\texttt{not}. Veamos qué hacen:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4348}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5652}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operador
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Significado
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{a\ and\ b} & El resultado es \texttt{True}solamente si
\texttt{a}es \texttt{True}\textbf{y} \texttt{b}es \texttt{True}. Ambos
deben ser \texttt{True}, de lo contrario devuelve \texttt{False}. \\
\texttt{a\ or\ b} & El resultado es \texttt{True}si \texttt{a}es
\texttt{True} \textbf{o} \texttt{b}es \texttt{True} (o ambos). Si ambos
son \texttt{False}, devuelve \texttt{False}. \\
\texttt{not\ a} & El resultado es \texttt{True} si \texttt{a}es
\texttt{False}, y viceversa. \\
\end{longtable}

Algunos ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2} \KeywordTok{and} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2} \KeywordTok{or} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2} \KeywordTok{and} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2} \KeywordTok{or} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{not} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{not} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-caution-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-caution-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-caution-color}{\faFire}\hspace{0.5em}{Prioridad de Operadores}, rightrule=.15mm, toprule=.15mm, left=2mm]

Las expresiones lógicas complejas (con más de un operador), se resuelven
al igual que en matemáticas: respetando precedencias y de izquierda a
derecha. También admiten el uso de \texttt{()} para alterar las
precedencias.

Sin embargo, si no tenemos precedencias explícitas con \texttt{()},
Python prioriza resolver primero los \texttt{and}, luego los \texttt{or}
y por último los \texttt{not}.

Ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{True} \KeywordTok{or} \VariableTok{False} \KeywordTok{and} \VariableTok{False}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

Por la prioridad del \texttt{and}, primero se resuelve
\texttt{False\ and\ False}, que da \texttt{False}. Luego, se resuelve
\texttt{True\ or\ False}, que da \texttt{True}.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{True} \KeywordTok{or} \VariableTok{False} \KeywordTok{or} \VariableTok{False}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

Como no hay \texttt{and}, se resuelve de izquierda a derecha. Primero se
resuelve \texttt{True\ or\ False}, que da \texttt{True}. Luego, se
resuelve \texttt{True\ or\ False}, que da \texttt{True}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\VariableTok{True} \KeywordTok{or} \VariableTok{False}\NormalTok{) }\KeywordTok{and} \VariableTok{False}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

Como hay paréntesis, se resuelve primero lo que está dentro de los
paréntesis. \texttt{True\ or\ False} da \texttt{True}. Luego,
\texttt{True\ and\ False} da \texttt{False}.

\end{tcolorbox}

\hypertarget{comparaciones-simples}{%
\subsection{Comparaciones Simples}\label{comparaciones-simples}}

Volvamos al problema inicial: Queremos saber, dado un número \(x\), si
es positivo o no, e imprimir un mensaje en consecuencia.\\
Recordemos la instrucción \texttt{if} que acabamos de introducir y que
sirve para tomar decisiones simples. Esta instrucción tiene la siguiente
estructura:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{expresion}\OperatorTok{\textgreater{}}\NormalTok{:}
    \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

donde:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{\textless{}expresion\textgreater{}}debe ser una expresión
  lógica.
\item
  \texttt{\textless{}cuerpo\textgreater{}}es un bloque de código que se
  ejecuta sólo si la expresión es verdadera.
\end{enumerate}

\begin{figure}

{\centering \includegraphics{imgs/unidad_3/if.png}

}

\caption{Diagrama de Flujo para la instrucción \texttt{if}}

\end{figure}

Como ahora ya sabemos cómo construir condiciones de comparación, vamos a
comparar si nuestro número \texttt{x} es mayor a \texttt{0}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_si\_positivo(x):}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número positivo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Podemos probarlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imprimir\_si\_positivo(}\DecValTok{5}\NormalTok{)}
\NormalTok{imprimir\_si\_positivo(}\OperatorTok{{-}}\DecValTok{5}\NormalTok{)}
\NormalTok{imprimir\_si\_positivo(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Número positivo
\end{verbatim}

Como vemos, si el número es positivo, se imprime el mensaje. Pero si el
número no es positivo, no se imprime nada. Necesitamos además agregar un
mensaje ``Número no positivo'', si es que la condición no se cumple.

Modifiquemos el diseño: 1. Si \(x>0\), se imprime ``Número positivo''.
2. En caso contrario, se imprime ``Número no positivo''.

Podríamos probar con el siguiente código:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_si\_positivo(x):}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número positivo"}\NormalTok{)}
  \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número no positivo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Otra solución posible es:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_si\_positivo(x):}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número positivo"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número no positivo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ambas están bien. Si lo probamos, vemos que funciona:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imprimir\_si\_positivo(}\DecValTok{5}\NormalTok{)}
\NormalTok{imprimir\_si\_positivo(}\OperatorTok{{-}}\DecValTok{5}\NormalTok{)}
\NormalTok{imprimir\_si\_positivo(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Número positivo
Número no positivo
Número no positivo
\end{verbatim}

Sin embargo, hay una mejor forma de hacer esta función. Existe una
condición alternativa para la estructura de decisión \texttt{if}, que
tiene la forma:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{expresion}\OperatorTok{\textgreater{}}\NormalTok{:}
    \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\ControlFlowTok{else}\NormalTok{:}
    \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

donde \texttt{if} y \texttt{else} son palabras reservadas. Su efecto es
el siguiente:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Se evalúa la \texttt{\textless{}expresion\textgreater{}}.
\item
  Si la \texttt{\textless{}expresion\textgreater{}} es verdadera, se
  ejecuta el \texttt{\textless{}cuerpo\textgreater{}} del \texttt{if}.
\item
  Si la \texttt{\textless{}expresion\textgreater{}} es falsa, se ejecuta
  el \texttt{\textless{}cuerpo\textgreater{}} del \texttt{else}.
\end{enumerate}

\begin{figure}

{\centering \includegraphics{imgs/unidad_3/if-else.png}

}

\caption{Diagrama de Flujo para la instrucción \texttt{if-else}}

\end{figure}

Por lo tanto, podemos reescribir nuestra función de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_si\_positivo\_o\_no(x): }\CommentTok{\# le cambiamos el nombre}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número positivo"}\NormalTok{)}
  \ControlFlowTok{else}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número no positivo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Probemos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imprimir\_si\_positivo\_o\_no(}\DecValTok{5}\NormalTok{)}
\NormalTok{imprimir\_si\_positivo\_o\_no(}\OperatorTok{{-}}\DecValTok{5}\NormalTok{)}
\NormalTok{imprimir\_si\_positivo\_o\_no(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Número positivo
Número no positivo
Número no positivo
\end{verbatim}

¡Sigue funcionando!

Lo importante a destacar es que, si la condición del \texttt{if} es
verdadera, se ejecuta el \texttt{\textless{}cuerpo\textgreater{}} del
\texttt{if} y \textbf{no} se ejecuta el
\texttt{\textless{}cuerpo\textgreater{}} del \texttt{else}. Y viceversa:
si la condición del \texttt{if} es falsa, se ejecuta el
\texttt{\textless{}cuerpo\textgreater{}} del \texttt{else} y \textbf{no}
se ejecuta el \texttt{\textless{}cuerpo\textgreater{}} del \texttt{if}.
Nunca se ejecutan ambos casos, porque son caminos paralelos que no se
cruzan, como vimos en el diagrama de flujo más arriba.

\hypertarget{muxfaltiples-decisiones-consecutivas.}{%
\subsection{Múltiples decisiones
consecutivas.}\label{muxfaltiples-decisiones-consecutivas.}}

Supongamos que ahora queremos imprimir un mensaje distinto si el número
es positivo, negativo o cero. Podríamos hacerlo con dos decisiones
consecutivas:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_si\_positivo\_negativo\_o\_cero(x):}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número positivo"}\NormalTok{) }\CommentTok{\# cuerpo del primer if}
  \ControlFlowTok{else}\NormalTok{:}
      \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{0}\NormalTok{:                      }\CommentTok{\#}
          \BuiltInTok{print}\NormalTok{(}\StringTok{"Número cero"}\NormalTok{)        }\CommentTok{\#}
      \ControlFlowTok{else}\NormalTok{:                           }\CommentTok{\#}
          \BuiltInTok{print}\NormalTok{(}\StringTok{"Número negativo"}\NormalTok{)    }\CommentTok{\# todo esto es el cuerpo del primer else}
\end{Highlighting}
\end{Shaded}

A esto se le llama \emph{anidar}, y es donde dentro de unas ramas de la
decisión (en este caso, la del \texttt{else}), se anida una nueva
decisión. Pero no es la única forma de implementarlo. Podríamos hacerlo
de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_si\_positivo\_negativo\_o\_cero(x):}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número positivo"}\NormalTok{)}
  \ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número cero"}\NormalTok{)}
  \ControlFlowTok{else}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Número negativo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La estructura \texttt{elif} es una abreviatura de \texttt{else\ if}. Es
decir, es un \texttt{else} que tiene una condición. Su efecto es el
siguiente:

\begin{figure}

{\centering \includegraphics{imgs/unidad_3/if-elif-else.png}

}

\caption{Diagrama de Flujo para la instrucción \texttt{if-elif-else} del
ejemplo}

\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Se evalúa la \texttt{\textless{}expresion\textgreater{}} del
  \texttt{if}.
\item
  Si la \texttt{\textless{}expresion\textgreater{}} es verdadera, se
  ejecuta el \texttt{\textless{}cuerpo\textgreater{}} del \texttt{if}.
\item
  Si la \texttt{\textless{}expresion\textgreater{}} es falsa, se evalúa
  la \texttt{\textless{}expresion\textgreater{}} del \texttt{elif}.
\item
  Si la \texttt{\textless{}expresion\textgreater{}} del \texttt{elif} es
  verdadera, se ejecuta su \texttt{\textless{}cuerpo\textgreater{}}.
\item
  Si la \texttt{\textless{}expresion\textgreater{}} del \texttt{elif} es
  falsa, se ejecuta el \texttt{\textless{}cuerpo\textgreater{}} del
  \texttt{else}.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Sabías que\ldots{} ?}, rightrule=.15mm, toprule=.15mm, left=2mm]

En Python se consideran \emph{verdaderos} (True) también todos los
valores numéricos distintos de 0, las cadenas de caracteres que no sean
vacías, y cualquier valor que no sea vacío en general. Los valores nulos
o vacíos son \emph{falsos}.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\end{Highlighting}
\end{Shaded}

es equivalente a:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ x:}
\end{Highlighting}
\end{Shaded}

Y además, existe el valor especial \textbf{\texttt{None}}, que
representa la ausencia de valor, y es considerado \emph{falso}. Podemos
preguntar si una variable tiene el valor \texttt{None} usando el
operador \texttt{is}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
\end{Highlighting}
\end{Shaded}

o también:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ x:}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-important-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Ejercicio Desafío}, rightrule=.15mm, toprule=.15mm, left=2mm]

Debemos calcular el pago de una persona empleada en nuestra empresa. El
cálculo debe hacerse por la cantidad de horas trabajadas, y se le debe
pedir al usuario la cantidad de horas y cuánto vale cada hora.\\
Adicionalmente, se abona un plus fijo de guardería a todo empleado/a con
infantes a su cargo. Y se paga un 10\% de incentivo a todo empleado/a
que haya trabajado 30 horas o más y \textbf{no} reciba el plus por
guardería.\\

Pista: pensar los distintos tipos de liquidación:\\
a) Empleado/a con menos de 30 horas y sin infantes a cargo.\\
b) Empleado/a con 30 horas o más y sin infantes a cargo.\\
c) Empleado/a con menos de 30 horas y con infantes a cargo.\\
d) Empleado/a con 30 horas o más y con infantes a cargo.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Ayuda: Flujo de la resolución}, rightrule=.15mm, toprule=.15mm, left=2mm]

\begin{figure}[H]

{\centering \includegraphics{imgs/unidad_3/flujo-desafio.png}

}

\caption{Diagrama de Flujo para el desafío}

\end{figure}

\end{tcolorbox}

\end{tcolorbox}

\hypertarget{ciclos-y-rangos}{%
\section{Ciclos y Rangos}\label{ciclos-y-rangos}}

Supongamos que en una fábrica se nos pide hacer un procedimiento para
entrenar al personal nuevo. Para comenzar se nos encarga la descripción
de uno muy simple: descarga de cajas de material del camión del
proveedor y almacenamiento en el depósito. Así que aplicamos lo que
venimos aprendiendo hasta ahora sobre algoritmos y describimos la
operación para la descarga de 3 cajas:

\begin{verbatim}
1 Abrir la puerta del depósito y encender luces 
2 Ir al garage o playón donde estacionó el camión 
3 Abrir las puertas traseras de la caja del transporte

4 Tomar una caja con ambas manos, asegurándola para no tirarla 
5 Caminar sosteniendo la caja hasta el depósito 
6 Colocar la caja sobre el piso en el sector correspondiente 
7 Ir al garage o playón donde estacionó el camión

8 Tomar OTRA caja con ambas manos, asegurándola para no tirarla 
9 Caminar sosteniendo la caja hasta el depósito 
10 Colocar la caja sobre la caja anterior 
11 Ir al garage o playón donde estacionó el camión

12 Tomar OTRA caja con ambas manos, asegurándola para no tirarla 
13 Caminar sosteniendo la caja hasta el depósito 
14 Colocar la caja sobre la caja anterior

15 Apagar luces y cerrar puerta del depósito 
16 Ir al garage o playón donde estacionó el camión 
17 Cerrar y trabar puertas del camión 
18 Avisar fin de descarga al transportista
\end{verbatim}

Ya lo tenemos. Ahora el jefe dice que en el camión suelen venir entre 5
y 15 cajas de material y nos pide que definas el mismo procedimiento
para todos los casos posibles. Notemos que se repiten las instrucciones
2, 3, 4, 5 y 6 para cada caja ¿Qué hacemos? ¿Vamos a seguir copiando y
pegando las instrucciones para cada caja? ¿Y si algún día vienen más de
15 o menos de 5? ¿Vamos a tener una lista de instrucciones distinta para
cada cantidad de cajas que puedan venir? Parece ser necesario hacer algo
más genérico que le facilite la vida a todos. Una nueva versión:

\begin{verbatim}
1 Abrir la puerta del depósito y encender luces 
2 Ir al garage o playón donde estacionó el camión 
3 Abrir las puertas traseras de la caja del transporte 
4 Tomar una caja con ambas manos, asegurándola para no tirarla 
5 Caminar sosteniendo la caja hasta el depósito 
6 Si es la primera caja, colocarla sobre el piso en el sector correspondiente;
si no, apilarla sobre la anterior;
salvo que ya haya 3 apiladas,
en ese caso colocarla a la derecha sobre el piso 
7 Ir al garage o playón donde estacionó el camión 

8 Repetir 4,5,6,7 mientras queden cajas para descargar 

9 Cerrar y trabar puertas del camión 
10 Avisar fin de descarga al transportista 
11 Volver a depósito 
12 Apagar luces y cerrar puerta del depósito
\end{verbatim}

Esta descripción es bastante más compacta y cubre todas las posibles
cantidades de cajas en un envío (habituales y excepcionales), de modo
que con una única página en el manual de procedimientos será suficiente.

Sin embargo, los algoritmos que venimos escribiendo se parecen más al
primer procedimiento que al segundo. ¿Cómo podemos mejorarlos?

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Ciclos}, rightrule=.15mm, toprule=.15mm, left=2mm]

El \textbf{ciclo}, \textbf{bucle} o \textbf{sentencia iterativa} es una
instrucción que permite ejecutar un bloque de código varias veces. En
Python, existen dos tipos de ciclos: \texttt{while} y \texttt{for}.

\end{tcolorbox}

\hypertarget{ciclo-for}{%
\subsection{\texorpdfstring{Ciclo
\texttt{for}}{Ciclo for}}\label{ciclo-for}}

La instrucción \texttt{for} nos indica que queremos repetir un bloque de
código una cierta cantidad de veces. Por ejemplo, si queremos imprimir
los números del 1 al 10, podemos hacerlo de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
4
5
6
7
8
9
10
\end{verbatim}

El ciclo \texttt{for} incluye una línea de \emph{inicialización} y una
línea de \texttt{\textless{}cuerpo\textgreater{}}, que puede tener una o
más instrucciones. El ciclo definido es de la forma:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{\textless{}}\NormalTok{nombre}\OperatorTok{\textgreater{}} \KeywordTok{in} \OperatorTok{\textless{}}\NormalTok{expresion}\OperatorTok{\textgreater{}}\NormalTok{:}
    \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

El ciclo se dice \emph{definido} porque una vez evaluada la
\texttt{\textless{}expresion\textgreater{}}, se sabe cuántas veces se va
a ejecutar el \texttt{\textless{}cuerpo\textgreater{}}: tantas veces
como elementos tenga la \texttt{\textless{}expresion\textgreater{}}.

La expresión puede indicarse con \texttt{range}:

\begin{itemize}
\tightlist
\item
  \texttt{range(n)} devuelve una secuencia de números desde 0 hasta
  \texttt{n-1}.
\item
  \texttt{range(a,\ b)} devuelve una secuencia de números desde
  \texttt{a} hasta \texttt{b-1}.
\item
  \texttt{range(a,\ b,\ c)} devuelve una secuencia de números desde
  \texttt{a} hasta \texttt{b-1}, de a \texttt{c} en \texttt{c}.
\end{itemize}

Se podría decir que el \texttt{range} puede recibir 3 valores:
\texttt{range(start,\ end,\ step)} o
\texttt{range(inicio,\ fin,\ paso)}, donde:

\begin{itemize}
\tightlist
\item
  \texttt{start} o \texttt{inicio} es el valor inicial de la secuencia.
  Por defecto es 0.
\item
  \texttt{end} o \texttt{fin} es el valor final de la secuencia.
  \textbf{No} se incluye en la secuencia.
\item
  \texttt{step} o \texttt{paso} es el incremento entre cada elemento de
  la secuencia. Por defecto es 1.
\end{itemize}

Si le pasamos un sólo parámetro, lo toma como \texttt{end}.\\
Si le pasamos dos, los toma como \texttt{start} y \texttt{end}.\\
Y si le pasamos tres, los toma como \texttt{start}, \texttt{end} y
\texttt{step}.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, rightrule=.15mm, toprule=.15mm, left=2mm]

¿Te suena quizás a algo que ya vimos? Quizás\ldots{} ¿los \emph{slices}
de las cadenas de caracteres?

\end{tcolorbox}

Además, la variable \texttt{\textless{}nombre\textgreater{}} va a ir
tomando el valor de cada elemento de la
\texttt{\textless{}expresion\textgreater{}} en cada iteración. En
nuestro ejemplo de imprimir los números del 1 al 10, vemos que i toma
los valores 1, 2, 3, 4, 5, 6, 7, 8, 9 y 10, en ese orden.\\

\begin{quote}
\textbf{Ejemplo}\\
Se pide una función que imprima todos los números pares entre dos
números dados \texttt{a} y \texttt{b}. Se considera que \texttt{a} y
\texttt{b} son siempre números enteros positivos, y que \texttt{a} es
menor que \texttt{b}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_pares(a, b):}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(a, b):}
    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{: }\CommentTok{\# si el resto de dividir por 2 es cero, es par}
      \BuiltInTok{print}\NormalTok{(i)}

\NormalTok{imprimir\_pares(}\DecValTok{1}\NormalTok{,}\DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
4
6
8
10
12
14
\end{verbatim}

\hfill\break

\begin{quote}
\textbf{Ejemplo}\\
Se pide una función que imprima todos los números del 1 al 10, en orden
inverso.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ imprimir\_inverso():}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
      \BuiltInTok{print}\NormalTok{(i)}

\NormalTok{imprimir\_inverso()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
9
8
7
6
5
4
3
2
1
\end{verbatim}

\hfill\break

\hypertarget{iterables}{%
\subsubsection{Iterables}\label{iterables}}

Como dijimos más arriba, la expresión del \texttt{for} puede ser
cualquier expresión que devuelva una secuencia de valores. A estas
expresiones se las llama \emph{iterables}.

Un ciclo \texttt{for} también podría iterar sobre elementos de una lista
(tema que vamos a ver más adelante), o sobre caracteres de una palabra.
Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ num }\KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{]:}
    \BuiltInTok{print}\NormalTok{(num)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
3
7
5
2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ c }\KeywordTok{in} \StringTok{"Hola"}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(c)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
H
o
l
a
\end{verbatim}

\hypertarget{ciclo-while}{%
\subsection{\texorpdfstring{Ciclo
\texttt{while}}{Ciclo while}}\label{ciclo-while}}

La instrucción \texttt{while} nos indica que queremos repetir un bloque
de código \emph{mientras} se cumpla una condición. Por ejemplo, si
queremos imprimir los números del 1 al 10, podemos hacerlo de la
siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{11}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(i)}
\NormalTok{    i }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
4
5
6
7
8
9
10
\end{verbatim}

El ciclo \texttt{while} incluye una línea de \emph{inicialización} y una
línea de \texttt{\textless{}cuerpo\textgreater{}}, que puede tener una o
más instrucciones. El ciclo definido es de la forma:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{expresion}\OperatorTok{\textgreater{}}\NormalTok{:}
    \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

El ciclo se dice \emph{indefinido} porque una vez evaluada la
\texttt{\textless{}expresion\textgreater{}}, \textbf{no} se sabe cuántas
veces se va a ejecutar el \texttt{\textless{}cuerpo\textgreater{}}: se
ejecuta mientras la \texttt{\textless{}expresion\textgreater{}} sea
verdadera.

Para usar la instrucción \texttt{while}, tenemos cuatro aspectos para
armar y afinar correctamente:

\begin{itemize}
\tightlist
\item
  Cuerpo
\item
  Condición
\item
  Estado Previo
\item
  Paso
\end{itemize}

Antes, para la instrucción \texttt{for}, sólo considerábamos el cuerpo y
la condición. Ahora, además, tenemos que considerar el estado previo y
el paso.

El \textbf{cuerpo} es la porción de código que se repetirá mientras la
condición sea verdadera.\\
La \textbf{condición} es la expresión booleana que se evalúa para
decidir si se ejecuta el cuerpo o no.\\
El \textbf{estado previo} es el estado de las variables antes de
ejecutar el cuerpo. En general, se refiere al estado de las variables
que participan de la condición.\\
El \textbf{paso} es la porción de código que modifica el estado previo.
En general, se refiere a la modificación de las variables que participan
de la condición.\\

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, rightrule=.15mm, toprule=.15mm, left=2mm]

Con los ciclos \texttt{while} hay que tener mucho cuidado de no caer en
un loop infinito. Esto sucede cuando la condición siempre es verdadera,
y el cuerpo no modifica el estado previo. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \VariableTok{True}\NormalTok{: }\CommentTok{\# más adelante sobre el uso de \textasciigrave{}while True\textasciigrave{}}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hola"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

o bien:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(i) }\CommentTok{\# el valor de i nunca cambia}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\begin{quote}
\textbf{Ejercicio}\\
Repetir el ejercicio 7.b de la guía 2 usando un ciclo \texttt{while}.
Repetir usando un ciclo \texttt{for}. ¿Qué diferencias hay entre ambos?
~
\end{quote}

\hypertarget{break-continue-y-return}{%
\subsection{Break, Continue y Return}\label{break-continue-y-return}}

\texttt{break} y \texttt{continue}son dos palabras clave en Python que
se utilizan en bucles (tanto \texttt{for} como \texttt{while}) para
alterar el flujo de ejecución del bucle.

\hypertarget{break}{%
\subsubsection{Break}\label{break}}

La declaración \texttt{break} se usa para salir inmediatamente de un
bucle antes de que se complete su iteración normal. Cuando se encuentra
una declaración \texttt{break} dentro de un bucle, el bucle \texttt{for}
o \texttt{while} se detiene inmediatamente y continúa con la ejecución
de las instrucciones que están después del mismo.

Por ejemplo, supongamos que queremos encontrar al primer número múltiplo
de 3 entre 10 y 30:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{10}
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}=} \DecValTok{30}\NormalTok{:}
  \ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{\%} \DecValTok{3} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"El primer número múltiplo de 3 es:"}\NormalTok{, numero)}
      \ControlFlowTok{break}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El primer número múltiplo de 3 es: 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ numero }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{31}\NormalTok{):}
  \ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{\%} \DecValTok{3} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"El primer número múltiplo de 3 es:"}\NormalTok{, numero)}
      \ControlFlowTok{break}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El primer número múltiplo de 3 es: 12
\end{verbatim}

\hypertarget{continue}{%
\subsubsection{Continue}\label{continue}}

La declaración \texttt{continue} se usa para omitir el resto del código
dentro de una iteración actual del bucle y continuar con la siguiente
iteración. Cuando se encuentra una declaración \texttt{continue} dentro
de un bucle, el bucle \texttt{for} o \texttt{while} salta a la siguiente
iteración del bucle sin ejecutar las instrucciones que están después del
\texttt{continue}.

Por ejemplo, supongamos que queremos imprimir todos los números entre 1
y 20, excepto los múltiplos de 4:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}=} \DecValTok{20}\NormalTok{:}
  \ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{\%} \DecValTok{4} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{      numero }\OperatorTok{+=} \DecValTok{1}
      \ControlFlowTok{continue}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
5
6
7
9
10
11
13
14
15
17
18
19
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ numero }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{):}
  \ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{\%} \DecValTok{4} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
      \ControlFlowTok{continue}
  \BuiltInTok{print}\NormalTok{(numero)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
5
6
7
9
10
11
13
14
15
17
18
19
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, rightrule=.15mm, toprule=.15mm, left=2mm]

Notemos que tanto para el uso de \texttt{break} como de
\texttt{continue}, si el código se encuentra con uno de ellos en la
ejecución, no ejecuta nada posterior a ellos: en el caso de
\texttt{break}, corta o interrumpe la ejecución del bucle; en el case de
\texttt{continue}, saltea el resto del código de esa iteración y pasa a
la siguiente, volviendo a evaluar la condición si el bucle es
\texttt{while}.

\end{tcolorbox}

\hypertarget{return}{%
\subsubsection{Return}\label{return}}

Cuando estamos dentro de una función, la instrucción \texttt{return} nos
permite devolver un valor y salir de la función. Ahora, si además
estamos dentro de un ciclo, también nos permite salir del mismo sin
ejecutar el resto del código.

Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ obtener\_primer\_par\_desde(n):}
  \ControlFlowTok{for}\NormalTok{ num }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n, n}\OperatorTok{+}\DecValTok{10}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Analizando si el número }\SpecialCharTok{\{}\NormalTok{num}\SpecialCharTok{\}}\SpecialStringTok{ es par"}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ num }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
      \ControlFlowTok{return}\NormalTok{ num}
  \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{obtener\_primer\_par\_desde(}\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Analizando si el número 9 es par
Analizando si el número 10 es par
\end{verbatim}

\begin{verbatim}
10
\end{verbatim}

Como vemos, la función \texttt{obtener\_primer\_par\_desde} recibe un
número \texttt{n}, y devuelve el primer número par que encuentra a
partir de \texttt{n}. Si no encuentra ningún número par, devuelve
\texttt{None}.\\
Si encuentra un número par, no sigue analizando el resto de los números.
Usa \texttt{return} para salir del ciclo y devuelve el número
encontrado.

\hypertarget{consideraciones-del-while}{%
\subsection{Consideraciones del While}\label{consideraciones-del-while}}

Es importante \textbf{no} ser redundantes con el código y no ``hacer
preguntas'' que ya sabemos.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{condicion}\OperatorTok{\textgreater{}}\NormalTok{:}
  \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}

\OperatorTok{\textless{}}\NormalTok{codigo cuando ya no se cumple la condición}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Veamos un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}

\ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{==} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"El número es 3"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"El número no es 3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

El output va a ser siempre el mismo:

\begin{verbatim}
1
2
3
El número es 3
\end{verbatim}

¿Por qué? Porque nuestra condición del while es lo que dice
\emph{``mientras esto se cumpla, yo repito el bloque del código de
adentro''}. Nuestra condición es que \texttt{numero\ \textless{}\ 3}. En
el momento en que \texttt{numero} llega a 3, el bucle
\texttt{while}\textbf{deja} de cumplir con la condición, y la ejecución
se corta, se termina con el bucle.

Es decir, el bloque

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{==} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"El número es 3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

siempre se ejecuta.

Y el bloque

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"El número no es 3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

nunca se ejecuta.

Por lo tanto, podemos reescribir el código de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}

\BuiltInTok{print}\NormalTok{(}\StringTok{"El número es 3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hfill\break
De la misma forma, no tendría sentido hacer algo así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{0} 
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}
  \ControlFlowTok{continue}

  \ControlFlowTok{if}\NormalTok{ numero }\OperatorTok{==} \DecValTok{3}\NormalTok{:}
    \ControlFlowTok{break}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{if\ numero\ ==\ 3} está absolutamente de más. Si
  \texttt{numero} es 3, el bucle \texttt{while} \textbf{no} se ejecuta,
  por lo que nunca se va a llegar a esa línea de código. No es necesario
  ``re-chequear'' la condición del while dentro del mismo, porque
  asumimos que si llegamos a esa línea de código, es porque la condición
  se cumplió. Por lo tanto, podemos reescribir el código de la siguiente
  forma:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{0} 
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}
  \ControlFlowTok{continue}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Ahora, el continue está de más también, porque se usa cuando nosotros
  queremos \emph{forzar} a que el ciclo pase a la siguiente iteración.
  Pero en este caso, el ciclo ya va a pasar a la siguiente iteración,
  porque estamos en la última línea del cuerpo.
\end{enumerate}

Este es nuestro código final, escrito de forma correcta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numero }\OperatorTok{=} \DecValTok{0} 
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\hypertarget{while-true}{%
\subsubsection{While True}\label{while-true}}

La instrucción \texttt{while} está hecha para que se ejecute mientras la
condición sea verdadera. Pero, ¿qué pasa si usamos \texttt{while\ True}?
Lo que pasa al usar \texttt{while\ True} es que nuestro código se vuelve
más propenso al error: si no tenemos cuidado, podemos caer en un loop
infinito.\\

Como no tenemos una condición a evaluar ni modificar en cada iteración,
el bucle se ejecuta infinitamente. Dependería de nosotros, como
programadores, que el bucle se corte en algún momento. Es decir,
dependería de que nos acordemos de poner dentro del \texttt{while}
alguna decisión que haga que el bucle se corte. Y si por alguna razón no
nos acordamos, el bucle se ejecutaría infinitamente, dejando al programa
``congelado'' o ``colgado'', sin responder, y usando todos los recursos
de la computadora.

En pocas palabras, podemos afirmar que el uso de \texttt{while\ True} en
Python es una mala práctica de programación, y recomendamos evitarla
fuertemente.

\hypertarget{modificando-la-condiciuxf3n}{%
\subsubsection{Modificando la
Condición}\label{modificando-la-condiciuxf3n}}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{condicion}\OperatorTok{\textgreater{}}\NormalTok{:}
  \OperatorTok{\textless{}}\NormalTok{cuerpo}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

La mejor decisión que se puede tomar para el de un bloque \texttt{while}
es asumir que, durante toda su ejecución exceptuando la última línea, la
condición se cumple. Es decir, que el cuerpo del bucle se ejecuta
mientras la condición sea verdadera. Por lo tanto, si queremos modificar
la condición, debemos hacerlo en la última línea del cuerpo.

Por ejemplo, esto no es correcto:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Se deben imprimir los números 0, 1, 2}
\NormalTok{numero }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}     \CommentTok{\# actualización de la condición}
  \BuiltInTok{print}\NormalTok{(numero)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
\end{verbatim}

Como vemos, se imprimen los números 1, 2, 3; pero no el 0. Esto es
porque estamos modificando la condición ni bien empieza el bucle, y no
en la última línea del cuerpo.

La forma correcta de hacerlo sería:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Se deben imprimir los números 0, 1, 2}
\NormalTok{numero }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(numero)}
\NormalTok{  numero }\OperatorTok{+=} \DecValTok{1}     \CommentTok{\# actualización de la condición}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
1
2
\end{verbatim}

De esta forma, todo lo que se encuentre antes de la última línea del
cuerpo se ejecuta mientras la condición sea verdadera. Y la última línea
del cuerpo es la que modifica la condición.

\hfill\break
\hfill\break

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Ejercicio Desafío}, rightrule=.15mm, toprule=.15mm, left=2mm]

Escribir un programa que pida al usuario un número entero positivo y
muestre por pantalla todos los números pares desde 1 hasta ese número.\\
Resolver primero usando un ciclo \texttt{while} y luego usando un ciclo
\texttt{for}.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Ejercicio Desafío}, rightrule=.15mm, toprule=.15mm, left=2mm]

Escribir un programa que pida al usuario un número par. Mientras el
usuario ingrese números que no cumplan con lo pedido, se lo debe volver
a solicitar.\\
Pista: resolver usando \texttt{while}.

\end{tcolorbox}

\bookmarksetup{startatroot}

\hypertarget{tipos-de-estructuras-de-datos}{%
\chapter{Tipos de Estructuras de
Datos}\label{tipos-de-estructuras-de-datos}}

\hypertarget{introducciuxf3n-secuencias}{%
\section{Introducción: Secuencias}\label{introducciuxf3n-secuencias}}

Una secuencia es una serie de elementos ordenados que se suceden unos a
otros.

Una secuencia en Python es un grupo de elementos con una organización
interna, que se alojan de manera contigua en memoria.

Las secuencias son tipos de datos que pueden ser iterados, y que tienen
un orden definido. Las secuencias más comunes son los rangos, las
cadenas de caracteres, las listas y las tuplas. En este capítulo vamos a
ver las características de cada una de ellas y cómo podemos
manipularlas.

\hypertarget{rangos}{%
\section{Rangos}\label{rangos}}

Los rangos ya los hemos visto antes, pero lo que no habíamos definido es
que son secuencias. Los rangos representan específicamente una secuencia
de números inmutable.

Los rangos se definen con la función \texttt{range()}, que recibe como
parámetros el inicio, el fin y el paso. El inicio es opcional y por
defecto es 0, el paso también es opcional y por defecto es 1.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, rightrule=.15mm, toprule=.15mm, left=2mm]

Para más información de los rangos, ver la
\protect\hyperlink{ciclo-for}{unidad 3}.

\end{tcolorbox}

\hypertarget{cadenas-de-caracteres}{%
\section{Cadenas de Caracteres}\label{cadenas-de-caracteres}}

Un \texttt{string} es un tipo de secuencia que sólo admite caracteres
como elementos. Los strings son inmutables, es decir, no se pueden
modificar una vez creados.

Internamente, cada uno de los caracteres se almacenará de forma contigua
en memoria. Es por esto que podemos acceder a cada uno de los caracteres
de un string a través de su índice haciendo uso de \texttt{{[}{]}}.

\begin{longtable}[]{@{}lllllllllll@{}}
\toprule\noalign{}
Índice & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Letra & H & o & l & a & & M & u & n & d & o \\
\end{longtable}

Hasta ahora, vimos que:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Las cadenas de caracteres pueden ser concatenadas con el operador
  \texttt{+}:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola"}
\NormalTok{despedida }\OperatorTok{=} \StringTok{"Chau"}
\BuiltInTok{print}\NormalTok{(saludo }\OperatorTok{+}\NormalTok{ despedida)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
HolaChau
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Las cadenas de caracteres pueden ser \emph{sliceadas} o incluso
  acceder a un único elemento usando \texttt{{[}{]}}:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola Mundo"}
\BuiltInTok{print}\NormalTok{(saludo[}\DecValTok{0}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(saludo[}\DecValTok{5}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hola
M
\end{verbatim}

Podemos agregar también que:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Las cadenas de caracteres pueden ser multiplicadas por un número
  entero (y el resultado es la concatenación de la cadena consigo misma
  esa cantidad de veces):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola"}
\BuiltInTok{print}\NormalTok{(saludo }\OperatorTok{*} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
HolaHolaHola
\end{verbatim}

Adicional a esas 3 operaciones, las cadenas de caracteres tienen una
gran cantidad de métodos que nos permiten manipularlas. Veamos algunos
de ellos.

\hypertarget{muxe9todos-de-cadenas-de-caracteres}{%
\subsection{Métodos de Cadenas de
Caracteres}\label{muxe9todos-de-cadenas-de-caracteres}}

Todos los métodos de las cadenas de caracteres devuelven una nueva
cadena de caracteres o un valor, y no modifican la cadena original (ya
que las cadenas de caracteres son inmutables).

\hypertarget{longitud-de-una-cadena}{%
\subsubsection{Longitud de una Cadena}\label{longitud-de-una-cadena}}

Se puede averiguar la cantidad de caracteres que conforman una cadena
utilizando la función predefinida \texttt{len()}:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(}\StringTok{"Pensamiento Computacional"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
25
\end{verbatim}

Existe también una cadena especial, la cadena vacía (ya la hemos visto
antes), que es la cadena que no contiene ningún caracter entre las
comillas. La longitud de la cadena vacía es 0.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip: Len e Índices de la Cadena}, rightrule=.15mm, toprule=.15mm, left=2mm]

Es interesante notar lo siguiente: si tenemos una cadena de caracteres
de longitud \texttt{n}, los índices de la cadena van desde \texttt{0}
hasta \texttt{n-1}. Esto es porque el índice \texttt{n} no existe, ya
que el primer índice es \texttt{0} y el último es \texttt{n-1}.

Veámoslo con un ejemplo: tenemos el caracter \texttt{Hola}.

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Índice & 0 & 1 & 2 & 3 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Letra & H & o & l & a \\
\end{longtable}

La longitud de la cadena es 4, pero el último índice es 3. Si intentamos
acceder al índice 4, nos dará un error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola"}
\BuiltInTok{print}\NormalTok{(saludo[}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{IndexError: string index out of range}
\end{Highlighting}
\end{Shaded}

Lo que nos indica el error es que el índice está fuera del rango de la
cadena. Esto es porque el índice \texttt{4} no existe, ya que el último
índice es \texttt{3}. El largo de la cadena es \texttt{4}, y el último
índice disponible es \texttt{4-1=3}.

\begin{itemize}
\tightlist
\item
  Los índices positivos (entre \texttt{0} y \texttt{len(s)\ -\ 1}) son
  los caracteres de la cadena del primero al último.
\item
  Los índices negativos (entre \texttt{-len(s)} y \texttt{-1}) proveen
  una notación que hace más fácil indicar cuál es el último caracter de
  la cadena: \texttt{s{[}-1{]}} es el último caracter,
  \texttt{s{[}-2{]}} es el penúltimo, y así sucesivamente.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola"}
\BuiltInTok{print}\NormalTok{(saludo[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(saludo[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(saludo[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(saludo[}\OperatorTok{{-}}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
a
l
o
H
\end{verbatim}

Además, el uso de índices negativos también es válido para
\emph{slices}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola"}
\BuiltInTok{print}\NormalTok{(saludo[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ol
\end{verbatim}

Al usar índices negativos, es importante no salirse del rango de los
índices permitidos.

\end{tcolorbox}

\hypertarget{recorriendo-cadenas-de-caracteres}{%
\subsubsection{Recorriendo Cadenas de
Caracteres}\label{recorriendo-cadenas-de-caracteres}}

Dijimos que los strings son secuencias, y por lo tanto podemos iterar
sobre ellos. Esto significa que podemos recorrerlos con un ciclo
\texttt{for}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola Mundo"}
\ControlFlowTok{for}\NormalTok{ caracter }\KeywordTok{in}\NormalTok{ saludo:}
    \BuiltInTok{print}\NormalTok{(caracter)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
H
o
l
a
 
M
u
n
d
o
\end{verbatim}

Si bien esto ya lo habíamos nombrado en la sección anterior como una
posibilidad, ahora sabemos por qué: todas las secuencias son iterables,
y por lo tanto, podemos recorrerlas.

\hypertarget{buscando-subcadenas}{%
\subsubsection{Buscando Subcadenas}\label{buscando-subcadenas}}

El operador \texttt{in} nos permite saber si una subcadena se encuentra
dentro de otra cadena. En la guía de la unidad 3 te pedimos que
investigues acerca del operador \texttt{in} y \texttt{not\ in} para el
ejercicio de vocales y consonantes.

\texttt{a\ in\ b} es una expresión (¿qué era una expresión?, repasar de
ser necesario la \protect\hyperlink{expresiones-booleanas}{unidad 3})
que devuelve \texttt{True} si \texttt{a} es una subcadena de \texttt{b},
y \texttt{False} en caso contrario.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( }\StringTok{"Hola"} \KeywordTok{in} \StringTok{"Hola Mundo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

Al ser una expresión booleana, se puede usar como condición tanto de un
\texttt{if} como de un \texttt{while}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \StringTok{"Hola"} \KeywordTok{in} \StringTok{"Hola Mundo"}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Se encontró una subcadena!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Se encontró una subcadena!
\end{verbatim}

\begin{quote}
\textbf{Ejercicio}\\
1. Investigar, para un string dado \(s\), cuál es el resultado del slice
\texttt{s{[}:{]}}\\
2. Investigar, para un string dado \(s\), cuál es el resultado del slice
\texttt{s{[}j:{]}} con \(j\) un número entero negativo.
\end{quote}

\hypertarget{inmutabilidad}{%
\subsubsection{Inmutabilidad}\label{inmutabilidad}}

Las cadenas son inmutables. Esto significa que no se pueden modificar
una vez creadas. Por ejemplo, si queremos cambiar un caracter de una
cadena, no podemos hacerlo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola Mundo"}
\NormalTok{saludo[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \StringTok{"h"}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TypeError: \textquotesingle{}str\textquotesingle{} object does not support item assignment}
\end{Highlighting}
\end{Shaded}

Si queremos realizar una modificación sobre una cadena, lo que tenemos
que hacer es crear una nueva cadena con la modificación que queremos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saludo }\OperatorTok{=} \StringTok{"Hola Mundo"}
\NormalTok{saludo }\OperatorTok{=} \StringTok{"h"} \OperatorTok{+}\NormalTok{ saludo[}\DecValTok{1}\NormalTok{:]}
\BuiltInTok{print}\NormalTok{(saludo)}
\end{Highlighting}
\end{Shaded}

\hypertarget{otros-muxe9todos-de-cadenas-de-caracteres}{%
\subsubsection{Otros Métodos de Cadenas de
Caracteres}\label{otros-muxe9todos-de-cadenas-de-caracteres}}

Las cadenas de caracteres tienen una gran cantidad de métodos que nos
permiten manipularlas. Algunos ya los vimos, como \texttt{len()},
\texttt{in} y \texttt{not\ in}. Veamos otros.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Método
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descripción
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Ejemplo
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{capitalize()} & Devuelve una copia de la cadena con el primer
caracter en mayúscula y el resto en minúscula &
\texttt{"hola\ mundo".capitalize()} devuelve \texttt{"Hola\ mundo"} \\
\texttt{count(subcadena)} & Devuelve la cantidad de veces que aparece la
subcadena en la cadena & \texttt{"Hola\ mundo".count("o")} devuelve
\texttt{2} \\
\texttt{find(subcadena)} & Devuelve el índice de la primera aparición de
la subcadena en la cadena, o \texttt{-1} si no se encuentra. Cada vez
que se llama, devuelve la siguiente aparición &
\texttt{"Hola\ mundo".find("mundo")} devuelve \texttt{5} \\
\texttt{upper()} & Devuelve una copia de la cadena con todos los
caracteres en mayúscula & \texttt{"Hola\ mundo".upper()} devuelve
\texttt{"HOLA\ MUNDO"} \\
\texttt{lower()} & Devuelve una copia de la cadena con todos los
caracteres en minúscula & \texttt{"Hola\ mundo".lower()} devuelve
\texttt{"hola\ mundo"} \\
\texttt{strip()} & Devuelve una copia de la cadena sin los espacios en
blanco al principio y al final & \texttt{"\ Hola\ mundo\ ".strip()}
devuelve \texttt{"Hola\ mundo"}. \\
\texttt{strip(subcadena)} & Devuelve una copia de la cadena sin los
caracteres de la subcadena al principio y al final. Sólo funciona para
quitar elementos de los extremos del string &
\texttt{"Hola\ mundo".strip("do")} devuelve \texttt{"Hola\ mun"} \\
\texttt{replace(subcadena1,\ subcadena2)} & Devuelve una copia de la
cadena reemplazando todas las apariciones de la subcadena1 por la
subcadena2 & \texttt{"Hola\ mundo".replace("mundo",\ "amigos")} devuelve
\texttt{"Hola\ amigos"} \\
\texttt{split()} & Devuelve una lista de subcadenas separando la cadena
por los espacios en blanco & \texttt{"Hola\ mundo\ \ ".split()} devuelve
\texttt{{[}"Hola",\ "mundo"{]}} \\
\texttt{split(separador)} & Devuelve una lista de subcadenas separando
la cadena por el separador & \texttt{"Hola,\ mundo".split(",\ ")}
devuelve \texttt{{[}"Hola",\ "mundo"{]}} \\
\texttt{isdigit()} & Devuelve \texttt{True} si todos los caracteres de
la cadena son dígitos, \texttt{False} en caso contrario &
\texttt{"123".isdigit()} devuelve \texttt{True} \\
\texttt{isalpha()} & Devuelve \texttt{True} si todos los caracteres de
la cadena son letras, \texttt{False} en caso contrario &
\texttt{"Hola".isalpha()} devuelve \texttt{True} \\
\texttt{isalnum()} & Devuelve \texttt{True} si todos los caracteres de
la cadena son letras o dígitos, \texttt{False} en caso contrario &
\texttt{"Hola123".isalnum()} devuelve \texttt{True} \\
\texttt{capitalize()} & Devuelve una copia de la cadena con el primer
caracter en mayúscula y el resto en minúscula &
\texttt{"hola\ mundo".capitalize()} devuelve \texttt{"Hola\ mundo"} \\
\texttt{index(subcadena)} & Devuelve el índice de la primera aparición
de la subcadena en la cadena, o produce un error si no se encuentra &
\texttt{"Hola\ mundo".index("mundo")} devuelve \texttt{5} \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Recomendación}, rightrule=.15mm, toprule=.15mm, left=2mm]

Te recomendamos que te animes a probar estas funciones, para ver qué
hacen y terminar de entenderlas.

\end{tcolorbox}

\hypertarget{tuplas}{%
\section{Tuplas}\label{tuplas}}

Las tuplas son una secuencia de elementos inmutable. Esto significa que
no se pueden modificar una vez creadas. En Python, el tipo de dato
asociado a las tuplas se llama \texttt{tuple} y se definen con
paréntesis \texttt{()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Las tuplas pueden tener elementos de cualquier tipo, es decir, pueden
ser heterogéneas. Por ejemplo, podemos tener una tupla con un número, un
string y un booleano:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\StringTok{"Hola"}\NormalTok{, }\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Una tupla de un sólo elemento (unitaria) debe definirse de la siguiente
manera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{,)}
\end{Highlighting}
\end{Shaded}

La coma al final es necesaria para diferenciar una tupla de un número
entre paréntesis \texttt{(1)}.\\

Ejemplos de tuplas podrían ser:

\begin{itemize}
\tightlist
\item
  Una fecha, representada como una tupla de 3 elementos: día, mes y año:
  \texttt{(1,\ 1,\ 2020)}
\item
  Datos de una persona: \texttt{(nombre,\ edad,\ dni)}:
  \texttt{("Carla",\ 30,\ 12345678)}
\end{itemize}

Incluso es posible anidar tuplas, como por ejemplo guardar, para una
persona, la fecha de nacimiento:
\texttt{("Carla",\ 30,\ 12345678,\ (1,\ 1,\ 1990))}

\hypertarget{tuplas-como-secuencias}{%
\subsection{Tuplas como Secuencias}\label{tuplas-como-secuencias}}

Como las tuplas son secuencias, al igual que las cadenas, podemos
utilizar la misma notación de índices para obtener cada uno de sus
elementos y, de la misma forma que las cadenas, los elementos comienzan
a enumerarse en su posición desde el \texttt{0}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fecha }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{2020}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fecha[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

También podemos usar la notación de rangos, o \emph{slices}, para
obtener subconjuntos de la tupla. Esto es algo típico de las secuencias:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fecha }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{2020}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fecha[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(1, 12)
\end{verbatim}

\hypertarget{tuplas-como-inmutables}{%
\subsection{Tuplas como Inmutables}\label{tuplas-como-inmutables}}

Al igual que con las cadenas, las componentes de las tuplas no pueden
ser modificadas. Es decir, no puedo cambiar los valores de una tupla una
vez creada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fecha }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{2020}\NormalTok{)}
\NormalTok{fecha[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TypeError: \textquotesingle{}tuple\textquotesingle{} object does not support item assignment}
\end{Highlighting}
\end{Shaded}

\hypertarget{longitud-de-una-tupla}{%
\subsection{Longitud de una Tupla}\label{longitud-de-una-tupla}}

La longitud de una tupla se puede obtener con la función predefinida
\texttt{len()}, que devuelve la cantidad de elementos o componentes que
tiene esa tupla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fecha }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{2020}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(fecha))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

Una tupla vacía es una tupla que no tiene elementos: \texttt{()}. La
longitud de una tupla vacía es 0.

\begin{quote}
\textbf{Ejercicio} Calcular la longitud de la tupla anidada
\texttt{("Carla",\ 30,\ 12345678,\ (1,\ 1,\ 1990))}. ¿Cuántos elementos
tiene?
\end{quote}

\hypertarget{empaquetado-y-desempaquetado-de-tuplas}{%
\subsection{Empaquetado y desempaquetado de
tuplas}\label{empaquetado-y-desempaquetado-de-tuplas}}

Si a una variable se le asigna una secuencia de valores separados por
comas, el valor de esa variable será la tupla formada por esos valores.
Ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{1}
\NormalTok{b }\OperatorTok{=} \DecValTok{2}
\NormalTok{c }\OperatorTok{=} \DecValTok{3}
\NormalTok{d }\OperatorTok{=}\NormalTok{ a, b, c}

\BuiltInTok{print}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(1, 2, 3)
\end{verbatim}

A esto se le llama \emph{empaquetado}.\\

De forma similar, si se tiene una tupla de largo \(k\), se puede asignar
cada uno de los elementos de la tupla a \(k\) variables distintas. Esto
se llama \emph{desempaquetado}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{a, b, c }\OperatorTok{=}\NormalTok{ d}

\BuiltInTok{print}\NormalTok{(a)}
\BuiltInTok{print}\NormalTok{(b)}
\BuiltInTok{print}\NormalTok{(c)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{¡Cuidado!}, rightrule=.15mm, toprule=.15mm, left=2mm]

Si estamos desempaquetando una tupla de largo \(k\) pero lo hacemos en
una cantidad de variables menor a \(k\), se producirá un error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{a, b }\OperatorTok{=}\NormalTok{ d}
\end{Highlighting}
\end{Shaded}

Obtendremos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ValueError: too many values to unpack}
\NormalTok{o}
\NormalTok{ValueError: not enough values to unpack}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\hypertarget{listas}{%
\section{Listas}\label{listas}}

Las listas, al igual que las tuplas, también pueden usarse para modelar
datos compuestos, pero cuya cantidad y valor varían a lo largo del
tiempo. Son secuencias \emph{mutables}, y vienen dotadas de una variedad
de operaciones muy útiles.

La notación para lista es una secuencia de valores entre corchetes y
separados por comas.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}

\NormalTok{lista\_vacia }\OperatorTok{=}\NormalTok{ []}
\end{Highlighting}
\end{Shaded}

\hypertarget{longitud-de-una-lista}{%
\subsection{Longitud de una Lista}\label{longitud-de-una-lista}}

La longitud de una lista se puede obtener con la función predefinida
\texttt{len()}, que devuelve la cantidad de elementos que tiene esa
lista:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(lista))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\hypertarget{listas-como-secuencias}{%
\subsection{Listas como Secuencias}\label{listas-como-secuencias}}

De la misma forma que venimos haciendo con las cadenas y las tuplas,
podremos acceder a los elementos de una lista a través de su índice,
\emph{slicear} y recorrerla con un ciclo \texttt{for}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(lista[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"Civil"}\NormalTok{, }\StringTok{"Informática"}\NormalTok{, }\StringTok{"Química"}\NormalTok{, }\StringTok{"Industrial"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(lista[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Informática', 'Química']
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"Civil"}\NormalTok{, }\StringTok{"Informática"}\NormalTok{, }\StringTok{"Química"}\NormalTok{, }\StringTok{"Industrial"}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ elemento }\KeywordTok{in}\NormalTok{ lista:}
    \BuiltInTok{print}\NormalTok{(elemento)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Civil
Informática
Química
Industrial
\end{verbatim}

\hypertarget{listas-como-mutables}{%
\subsection{Listas como Mutables}\label{listas-como-mutables}}

A diferencia de las tuplas, las listas son mutables. Esto significa que
podemos modificar sus elementos una vez creadas.

\begin{itemize}
\tightlist
\item
  Para cambiar un elemento de una lista, se usa la notación de índices:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{4}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[4, 2, 3]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Para agregar un elemento al final de una lista, se usa el método
  \texttt{append()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista.append(}\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Para agregar un elemento en una posición específica de una lista, se
  usa el método \texttt{insert()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista.insert(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[4, 1, 2, 3]
\end{verbatim}

El método ingresa el número \texttt{4} en la posición \texttt{0} de la
lista, y desplaza el resto de los elementos hacia la derecha.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista.insert(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 3, 2, 3]
\end{verbatim}

El método ingresa el número \texttt{3} en la posición \texttt{1} de la
lista, y desplaza el resto de los elementos hacia la derecha.

Las listas no controlan si se insertan elementos repetidos, por lo que
si queremos exigir unicidad, debemos hacerlo mediante otras herramientas
en nuestro código.

\begin{itemize}
\tightlist
\item
  Para eliminar un elemento de una lista, se usa el método
  \texttt{remove()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista.remove(}\DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 3]
\end{verbatim}

Remove busca el elemento \texttt{2} en la lista y lo elimina. Si el
elemento no existe, se produce un error.

Si el valor está repetido, se eliminará la primera aparición del
elemento, empezando por la izquierda.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\NormalTok{lista.remove(}\DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 3, 2]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Para quitar el último elemento de una lista, se usa el método
  \texttt{pop()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista.pop()}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2]
\end{verbatim}

El método \texttt{pop()} devuelve el elemento que se eliminó de la
lista. Si la lista está vacía, se produce un error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{elemento }\OperatorTok{=}\NormalTok{ lista.pop()}
\BuiltInTok{print}\NormalTok{(elemento)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Para quitar un elemento de una lista en una posición específica, se
  usa el método \texttt{pop()} con un índice:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista.pop(}\DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 3]
\end{verbatim}

Al igual que antes, el método \texttt{pop()} devuelve el elemento que se
eliminó de la lista. Si la lista está vacía, se produce un error.

\begin{itemize}
\tightlist
\item
  \texttt{extend()} agrega los elementos de una lista al final de otra.
  Es lo mismo que concatenar dos listas con el operador \texttt{+}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{lista2 }\OperatorTok{=}\NormalTok{ [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]}
\NormalTok{lista1.extend(lista2)}
\BuiltInTok{print}\NormalTok{(lista1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4, 5, 6]
\end{verbatim}

\hypertarget{referencias-de-listas}{%
\subsection{Referencias de Listas}\label{referencias-de-listas}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{]}
\NormalTok{b }\OperatorTok{=}\NormalTok{ a}
\NormalTok{a.pop()}

\BuiltInTok{print}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3]
\end{verbatim}

Se dice que \texttt{b} es una referencia a \texttt{a}. Esto significa
que \texttt{b} no es una copia de \texttt{a}, sino que es \texttt{a}
misma. Por lo tanto, si modificamos \texttt{a}, también modificamos
\texttt{b}.

Una forma de crear una copia de una lista es usando el método
\texttt{copy()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{]}
\NormalTok{b }\OperatorTok{=}\NormalTok{ a.copy()}
\NormalTok{a.pop()}

\BuiltInTok{print}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4]
\end{verbatim}

\hypertarget{buxfasqueda-de-elementos-en-una-lista}{%
\subsection{Búsqueda de Elementos en una
Lista}\label{buxfasqueda-de-elementos-en-una-lista}}

\begin{itemize}
\tightlist
\item
  Para saber si un elemento se encuentra en una lista, se puede utilizar
  el operador \texttt{in}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\DecValTok{2} \KeywordTok{in}\NormalTok{ lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

Como vemos, el operador \texttt{in} es válido para todas las secuencias,
incluyendo tuplas y cadenas.

\begin{itemize}
\tightlist
\item
  Para averiguar la posición de un valor dentro de una lista, usaremos
  el método \texttt{index()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"t"}\NormalTok{, }\StringTok{"z"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(lista.index(}\StringTok{"t"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

Si el valor no se encuentra en la lista, se produce un error.\\
Si el valor se encuentra repetido, se devuelve la posición de la primera
aparición del elemento, empezando por la izquierda.

\hypertarget{iterando-sobre-listas}{%
\subsection{Iterando sobre Listas}\label{iterando-sobre-listas}}

Las listas son secuencias, y por lo tanto podemos iterar sobre ellas.
Esto significa que podemos recorrerlas con un ciclo \texttt{for}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ elemento }\KeywordTok{in}\NormalTok{ lista:}
    \BuiltInTok{print}\NormalTok{(elemento)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
\end{verbatim}

Esta forma de recorrer elementos usando \texttt{for} es utilizable con
todos los tipos de secuencias.

\hypertarget{ordenando-listas}{%
\subsection{Ordenando Listas}\label{ordenando-listas}}

Nos puede interesar que los elementos de una lista estén ordenados según
algún criterio. Python provee dos operaciones para obtener una lista
ordenada a partir de la desordenada.

\begin{itemize}
\tightlist
\item
  \texttt{sorted(s)} devuelve una lista ordenada con los elementos de la
  secuencia \texttt{s}. La secuencia \texttt{s} no se modifica.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\NormalTok{lista\_nueva }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(lista)}

\BuiltInTok{print}\NormalTok{(lista)}
\BuiltInTok{print}\NormalTok{(lista\_nueva)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[3, 1, 2]
[1, 2, 3]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{s.sort()} ordena la lista \texttt{s} en el lugar. Es decir,
  modifica la lista \texttt{s} y no devuelve nada.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\NormalTok{lista.sort()}

\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3]
\end{verbatim}

Tanto el método \texttt{sort()} como el método \texttt{sorted()} ordenan
la lista en orden ascendente. Si queremos ordenarla en orden
descendente, podemos usar el parámetro \texttt{reverse}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\NormalTok{lista.sort(reverse}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[3, 2, 1]
\end{verbatim}

Existe un método \texttt{reverse} (no disponible en Replit) que invierte
la lista sin ordenarla. Una forma de reemplazarlo es usando
\emph{slices}, como ya vimos: \texttt{lista{[}::-1{]}}.

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-warning-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-warning-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{¡Cuidado con los Ordenamientos!}, rightrule=.15mm, toprule=.15mm, left=2mm]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Todos los elementos de la secuencia deben ser comparables entre sí. Si
  no lo son, se producirá un error. Por ejemplo, no se puede ordenar una
  lista que contenga números y strings.
\item
  Al ordenar, las letras en minúscula no valen lo mismo que las letras
  en mayúscula. Si queremos ordenar ``hola'' y ``HOLA'' (por ejemplo),
  tenemos que compararlas convirtiendo todo a minúscula o todo a
  mayúscula.\\
  De lo contrario, se ordena poniendo las mayúsculas primero y luego las
  minúsculas. Es decir, para una lista con los valores
  \texttt{{[}"hola",\ "HOLA"{]}}, el ordenamiento será
  \texttt{{[}"HOLA",\ "hola"{]}}.
\end{enumerate}

¿Existe una forma mejor de hacerlo? Sí. Usando \emph{keys} de
ordenamiento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"hola"}\NormalTok{, }\StringTok{"HOLA"}\NormalTok{]}
\NormalTok{lista.sort(key}\OperatorTok{=}\BuiltInTok{str}\NormalTok{.lower)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['hola', 'HOLA']
\end{verbatim}

Lo importante de momento es que sepas que existe esta forma de ordenar.
A \emph{key} se le puede pasar una función que se va a aplicar a cada
elemento de la lista antes de ordenar. En este caso, la función
\texttt{str.lower} convierte todo a minúscula antes de intentar ordenar.

\end{tcolorbox}

\hypertarget{listas-por-comprensiuxf3n}{%
\subsection{Listas por Comprensión}\label{listas-por-comprensiuxf3n}}

Las listas por comprensión son una forma de crear listas de forma
concisa y elegante.

Por ejemplo, si queremos crear una lista con los números del 1 al 10,
podemos hacerlo de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numeros }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{):}
\NormalTok{    numeros.append(i)}
\BuiltInTok{print}\NormalTok{(numeros)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
\end{verbatim}

Sin embargo, podemos hacerlo de forma más concisa usando una lista por
comprensión:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numeros }\OperatorTok{=}\NormalTok{ [i }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)]}
\BuiltInTok{print}\NormalTok{(numeros)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
\end{verbatim}

La sintaxis de una lista por comprensión es la siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\OperatorTok{\textless{}}\NormalTok{expresión}\OperatorTok{\textgreater{}} \ControlFlowTok{for} \OperatorTok{\textless{}}\NormalTok{elemento}\OperatorTok{\textgreater{}} \KeywordTok{in} \OperatorTok{\textless{}}\NormalTok{secuencia}\OperatorTok{\textgreater{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

La expresión se evalúa para cada elemento de la secuencia, y el
resultado de esa evaluación se agrega a la lista.

\hypertarget{listas-anidadas}{%
\subsection{Listas anidadas}\label{listas-anidadas}}

Las listas también puede estar anidadas, es decir, una lista puede
contener a otras listas. Por ejemplo, podemos tener una lista de listas
de números:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valores }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Aquía \(valores\) es una lista que contiene 3 elementos, que a su vez
son también listas. Entonces, \texttt{valores{[}0{]}} sería la lista
\texttt{{[}1,2,3{]}}. Si quisiéramos, por ejemplo, acceder al número
\texttt{2} de dicha lista, tendríamos que volver a acceder al índice
\texttt{1} de la lista \texttt{valores{[}0{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{valores }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{]]}
\NormalTok{numero }\OperatorTok{=}\NormalTok{ valores[}\DecValTok{0}\NormalTok{][}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(numero)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Generalización}, rightrule=.15mm, toprule=.15mm, left=2mm]

Este concepto de listas anidadas se puede generalizar a cualquier
secuencia anidada. Por ejemplo, una tupla de tuplas, o una lista de
tuplas, o una tupla de listas, etc.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=}\NormalTok{ ((}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), (}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), (}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{))}
\NormalTok{numero }\OperatorTok{=}\NormalTok{ tupla[}\DecValTok{1}\NormalTok{][}\DecValTok{2}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(numero)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), (}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), (}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{)]}
\NormalTok{numero }\OperatorTok{=}\NormalTok{ lista[}\DecValTok{2}\NormalTok{][}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(numero)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=}\NormalTok{ ([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{])}
\NormalTok{numero }\OperatorTok{=}\NormalTok{ tupla[}\DecValTok{0}\NormalTok{][}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(numero)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

Incluso se puede reemplazar un elemento anidado por otro:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=}\NormalTok{ ([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{])}
\NormalTok{tupla[}\DecValTok{0}\NormalTok{][}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(tupla)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
([1, 10, 3], [4, 5, 6], [7, 8, 9])
\end{verbatim}

Esto es válido siempre y cuando el \emph{elemento} a reemplazar esté
dentro de una secuencia \emph{mutable}. En el caso de arriba, estamos
cambiando el valor de una lista, que se encuentra dentro de la tupla. La
tupla no cambia: sigue teniendo 3 listas guardadas.

Si quisiéramos editar una tupla guardada dentro de una lista, no
funcionaría:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{), (}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), (}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{)]}
\NormalTok{lista[}\DecValTok{0}\NormalTok{][}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TypeError: \textquotesingle{}tuple\textquotesingle{} object does not support item assignment}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

Las listas anidadas suelen usarse para representar matrices. Para ello,
se puede pensar que cada lista representa una fila de la matriz, y cada
elemento de la lista representa un elemento de la fila. Por ejemplo, la
matriz:

\[
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
\]

se puede representar como la lista de listas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matriz }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-important-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Ejercicio Desafío}, rightrule=.15mm, toprule=.15mm, left=2mm]

Escribir una función que reciba una cantidad de filas y una cantidad de
columnas y devuelva una matriz de ceros de ese tamaño. Usar listas por
comprensión.\\
Ejemplo: \texttt{matrix(2,3)} devuelve
\texttt{{[}{[}0,\ 0,\ 0{]},\ {[}0,\ 0,\ 0{]}{]}}

\end{tcolorbox}

\hfill\break

\begin{quote}
\textbf{Ejemplo} Dada una lista de tuplas de dos elementos (precio,
producto), desempaquetar la lista en dos listas separadas: una con los
precios y otra con los productos.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [(}\DecValTok{100}\NormalTok{, }\StringTok{"Coca Cola"}\NormalTok{), (}\DecValTok{200}\NormalTok{, }\StringTok{"Pepsi"}\NormalTok{), (}\DecValTok{300}\NormalTok{, }\StringTok{"Sprite"}\NormalTok{)]}

\NormalTok{precios }\OperatorTok{=}\NormalTok{ []}
\NormalTok{productos }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{for}\NormalTok{ precio, producto }\KeywordTok{in}\NormalTok{ lista: }\CommentTok{\# Acá estamos desempaquetando: precio, producto}
\NormalTok{    precios.append(precio)}
\NormalTok{    productos.append(producto)}

\BuiltInTok{print}\NormalTok{(precios)}
\BuiltInTok{print}\NormalTok{(productos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[100, 200, 300]
['Coca Cola', 'Pepsi', 'Sprite']
\end{verbatim}

\hypertarget{listas-y-cadenas}{%
\section{Listas y Cadenas}\label{listas-y-cadenas}}

Vimos que las cadenas tienen el método \texttt{split}, que nos permite
separar una cadena en una lista de subcadenas. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cadena }\OperatorTok{=} \StringTok{"Esta es una      cadena con    espacios   varios"}
\NormalTok{lista }\OperatorTok{=}\NormalTok{ cadena.split()}

\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Esta', 'es', 'una', 'cadena', 'con', 'espacios', 'varios']
\end{verbatim}

También podemos hacer lo contrario: podemos unir una lista de subcadenas
en una cadena usando el método \texttt{join}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"Esta"}\NormalTok{, }\StringTok{"es"}\NormalTok{, }\StringTok{"una"}\NormalTok{, }\StringTok{"cadena"}\NormalTok{, }\StringTok{"con"}\NormalTok{, }\StringTok{"espacios"}\NormalTok{, }\StringTok{"varios"}\NormalTok{]}
\NormalTok{cadena }\OperatorTok{=} \StringTok{" "}\NormalTok{.join(lista)}

\BuiltInTok{print}\NormalTok{(cadena)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Esta es una cadena con espacios varios
\end{verbatim}

La sintaxis del método join es:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textless{}}\NormalTok{separador}\OperatorTok{\textgreater{}}\NormalTok{.join(}\OperatorTok{\textless{}}\NormalTok{lista}\OperatorTok{\textgreater{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

El separador es el caracter que se va a usar para unir los elementos de
la lista. En el ejemplo, el separador es un espacio \texttt{"\ "}, pero
puede ser cualquier caracter. La lista contiene a las subcadenas que se
van a unir.

\hypertarget{operaciones-de-las-secuencias}{%
\section{Operaciones de las
Secuencias}\label{operaciones-de-las-secuencias}}

Tanto las cadenas, como las tuplas y las listas son secuencias, y por lo
tanto comparten una serie de operaciones que podemos realizar sobre
ellas.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operación
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descripción
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{x\ in\ s} & Devuelve \texttt{True} si el elemento \texttt{x} se
encuentra en la secuencia \texttt{s}, \texttt{False} en caso
contrario~ \\
\texttt{s\ +\ t} & Concatena las secuencias \texttt{s} y \texttt{t} \\
\texttt{s\ *\ n} & Repite la secuencia \texttt{s} \texttt{n} veces \\
\texttt{s{[}i{]}} & Devuelve el elemento de la secuencia \texttt{s} en
la posición \texttt{i} \\
\texttt{s{[}i:j:k{]}} & Devuelve un \emph{slice} de la secuencia
\texttt{s} desde la posición \texttt{i} hasta la posición \texttt{j} (no
incluída), con pasos de a \texttt{k} \\
\texttt{len(s)} & Devuelve la cantidad de elementos de la secuencia
\texttt{s} \\
\texttt{min(s)} & Devuelve el elemento mínimo de la secuencia
\texttt{s} \\
\texttt{max(s)} & Devuelve el elemento máximo de la secuencia
\texttt{s} \\
\texttt{sum(s)} & Devuelve la suma de los elementos de la secuencia
\texttt{s} \\
\texttt{enumerate(s)} & Devuelve una secuencia de tuplas de la forma
\texttt{(i,\ s{[}i{]})} para cada elemento de la secuencia \texttt{s} \\
\texttt{count(x)} & Devuelve la cantidad de veces que aparece el
elemento \texttt{x} en la secuencia \texttt{s} \\
\texttt{index(x)} & Devuelve el índice de la primera aparición del
elemento \texttt{x} en la secuencia \texttt{s} \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, rightrule=.15mm, toprule=.15mm, left=2mm]

Te recomendamos que pruebes cada una de estas operaciones con las
distintas secuencias que vimos en este capítulo.

\end{tcolorbox}

Además, es posible crear una lista o tupla a partir de cualquier otra
secuencia, usando las funciones \texttt{list} y \texttt{tuple}
respectivamente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\StringTok{"Hola"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['H', 'o', 'l', 'a']
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupla }\OperatorTok{=} \BuiltInTok{tuple}\NormalTok{(}\StringTok{"Hola"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(tupla)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
('H', 'o', 'l', 'a')
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lista }\OperatorTok{=} \BuiltInTok{list}\NormalTok{( (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{) ) }\CommentTok{\# Convertimos una tupla en una lista}
\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3]
\end{verbatim}

Esta última es particularmente útil cuando necesitamos trabajar con una
tupla, pero como son inmutables, la convertimos a lista para manipularla
sin problemas.

\begin{quote}
\textbf{Ejercicio} Escribir una función que le pida al usuario que
ingrese números enteros positivos, los vaya agregando a una lista, y que
cuando el usuario ingrese un 0, devuelva la lista de números ingresados.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ ingresar\_numeros():}
\NormalTok{    numeros }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    numero }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\StringTok{"Ingrese un número: "}\NormalTok{))}

    \ControlFlowTok{while}\NormalTok{ numero }\OperatorTok{!=} \DecValTok{0}\NormalTok{:}
\NormalTok{        numeros.append(numero)}
\NormalTok{        numero }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\StringTok{"Ingrese un número: "}\NormalTok{))}
    \ControlFlowTok{return}\NormalTok{ numeros}
\end{Highlighting}
\end{Shaded}

\hfill\break

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hfill\break

\begin{quote}
\textbf{Ejemplo} Escribir una función que cuente la cantidad de letras
que tiene una cadena de caracteres, y devuelva su valor.\\
Luego, usar esa función como \emph{key} para ordenar la siguiente lista:
\texttt{{[}"Año",\ "Onomatopeya",\ "Murcielago",\ "Arañas",\ "Messi",\ "Camiseta"{]}}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ contar\_letras(cadena):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(cadena)}

\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"Año"}\NormalTok{, }\StringTok{"Onomatopeya"}\NormalTok{, }\StringTok{"Murcielago"}\NormalTok{, }\StringTok{"Arañas"}\NormalTok{, }\StringTok{"Messi"}\NormalTok{, }\StringTok{"Camiseta"}\NormalTok{]}
\NormalTok{lista.sort(key}\OperatorTok{=}\NormalTok{contar\_letras)}

\BuiltInTok{print}\NormalTok{(lista)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Año', 'Messi', 'Arañas', 'Camiseta', 'Murcielago', 'Onomatopeya']
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-important-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Ejercicio Desafío}, rightrule=.15mm, toprule=.15mm, left=2mm]

Escribir una función que cuente la cantidad de vocales que tiene una
cadena de caracteres, y devuelva su valor. Debe considerar mayúsculas y
minúsculas. Pista: podés usar la función para saber si una letra es
vocal que hiciste en la unidad 3.

Luego, usar esa función como \emph{key} para ordenar la siguiente lista:
\texttt{{[}"Año",\ "Onomatopeya",\ "Murcielago",\ "Arañas",\ "Messi",\ "Camiseta"{]}}.\\

\end{tcolorbox}

\hfill\break

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hfill\break

\hypertarget{map}{%
\subsection{Map}\label{map}}

La función \texttt{map} aplica una función a cada uno de los elementos
de una secuencia, y devuelve una nueva secuencia con los resultados.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ obtener\_cuadrado(x):}
  \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}

\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\NormalTok{lista\_cuadrados }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{map}\NormalTok{(obtener\_cuadrado, lista))}
\BuiltInTok{print}\NormalTok{(lista\_cuadrados)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 4, 9, 16]
\end{verbatim}

La sintaxis es:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{map}\NormalTok{(}\OperatorTok{\textless{}}\NormalTok{funcion}\OperatorTok{\textgreater{}}\NormalTok{, }\OperatorTok{\textless{}}\NormalTok{secuencia}\OperatorTok{\textgreater{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La función \texttt{map} devuelve un objeto de tipo \texttt{map}, por lo
que en general lo vamos a convertir a una lista usando \texttt{list()}.
Sin embargo, el tipo \texttt{map} es iterable, por lo que podríamos
recorrerlo con un ciclo \texttt{for}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ lista\_cuadrados:}
  \BuiltInTok{print}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
4
9
16
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, rightrule=.15mm, toprule=.15mm, left=2mm]

Las funciones a pasar como parámetro a \texttt{map} devuelven
\emph{valores transformados} del elemento original. Lo que hace
\texttt{map} es aplicar la función a cada uno de los elementos de la
secuencia original.

\end{tcolorbox}

\hypertarget{filter}{%
\subsection{Filter}\label{filter}}

La función \texttt{filter} aplica una función a cada uno de los
elementos de una secuencia, y devuelve una nueva secuencia con los
elementos para los cuales la función devuelve \texttt{True}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ es\_par(x):}
  \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}

\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\NormalTok{lista\_pares }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{filter}\NormalTok{(es\_par, lista))}
\BuiltInTok{print}\NormalTok{(lista\_pares)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[2, 4]
\end{verbatim}

La sintaxis es:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{filter}\NormalTok{(}\OperatorTok{\textless{}}\NormalTok{funcion}\OperatorTok{\textgreater{}}\NormalTok{, }\OperatorTok{\textless{}}\NormalTok{secuencia}\OperatorTok{\textgreater{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La función \texttt{filter} devuelve un objeto de tipo \texttt{filter},
por lo que en general lo vamos a convertir a una lista usando
\texttt{list()}. Sin embargo, el tipo \texttt{filter} es iterable, por
lo que podríamos recorrerlo con un ciclo \texttt{for}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ lista\_pares:}
  \BuiltInTok{print}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
4
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip}, rightrule=.15mm, toprule=.15mm, left=2mm]

Las funciones a pasar como parámetro a \texttt{filter} devuelven
\emph{valores booleanos} del elemento original. Lo que hace
\texttt{filter} es filtrar la secuencia original y quedarse sólo con los
valores para los cuales la función devuelve \texttt{True}.

\end{tcolorbox}

\begin{quote}
\textbf{Ejemplo} Escribir una función que reciba una lista de números y
devuelva una lista con los números positivos de la lista original.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ es\_positivo(x):}
  \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}

\KeywordTok{def}\NormalTok{ quitar\_negativos\_o\_cero(lista):}
  \ControlFlowTok{return} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{filter}\NormalTok{(es\_positivo, lista))}

\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\OperatorTok{{-}}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OperatorTok{{-}}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{]}
\NormalTok{lista\_positivos }\OperatorTok{=}\NormalTok{ quitar\_negativos\_o\_cero(lista)}
\BuiltInTok{print}\NormalTok{(lista\_positivos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 3, 5]
\end{verbatim}

\begin{quote}
\textbf{Ejemplo} Escribir una función que reciba una lista de nombres y
devuelva una lista con los mismos nombres pero con la primer letra en
mayúscula.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ capitalizar\_nombre(nombre):}
  \ControlFlowTok{return}\NormalTok{ nombre.capitalize()}

\KeywordTok{def}\NormalTok{ capitalizar\_lista(lista):}
  \ControlFlowTok{return} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{map}\NormalTok{(capitalizar\_nombre, lista))}

\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\StringTok{"pilar"}\NormalTok{, }\StringTok{"barbie"}\NormalTok{, }\StringTok{"violeta"}\NormalTok{]}
\NormalTok{lista\_capitalizada }\OperatorTok{=}\NormalTok{ capitalizar\_lista(lista)}
\BuiltInTok{print}\NormalTok{(lista\_capitalizada)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Pilar', 'Barbie', 'Violeta']
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, rightrule=.15mm, toprule=.15mm, left=2mm]

Tanto \texttt{map} como \texttt{filter} son aplicables a cualquiera de
las secuencias vistas (rangos, cadena de caracteres, listas, tuplas).

\end{tcolorbox}

\hfill\break

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hfill\break

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-important-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-important-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Ejercicio Desafío}, rightrule=.15mm, toprule=.15mm, left=2mm]

Se está procesando una base de datos para entrenar un modelo de Machine
Learning. La base de datos contiene información de personas, y cada
persona está representada por una tupla de 2 elementos: nombre, edad.\\
Escribir una función que reciba una lista de estas tuplas. La función
debe devolver la lista ordenada por edad; y filtrada de forma que sólo
queden los nombres de las personas mayores de edad (\textgreater18).
Además, los nombres deben estar en mayúscula.\\
Ejemplo:\\
Si se tiene
\texttt{{[}("sol",\ 40),\ ("priscila",\ 15),\ ("agostina",\ 30){]}}\\
una vez ejecutada, la función debe devolver:
\texttt{{[}("AGOSTINA",30),\ ("SOL",40){]}}

\end{tcolorbox}

\bookmarksetup{startatroot}

\hypertarget{entrada-y-salida-de-informaciuxf3n}{%
\chapter{Entrada y Salida de
Información}\label{entrada-y-salida-de-informaciuxf3n}}

\hypertarget{subtitle}{%
\section{Subtitle}\label{subtitle}}

\bookmarksetup{startatroot}

\hypertarget{bibliotecas}{%
\chapter{Bibliotecas}\label{bibliotecas}}

\hypertarget{subtitle-1}{%
\section{Subtitle}\label{subtitle-1}}

\bookmarksetup{startatroot}

\hypertarget{referencias}{%
\chapter*{Referencias}\label{referencias}}
\addcontentsline{toc}{chapter}{Referencias}

\markboth{Referencias}{Referencias}

\hypertarget{refs}{}
\begin{CSLReferences}{0}{0}
\end{CSLReferences}

\bookmarksetup{startatroot}

\hypertarget{guuxeda-de-ejercicios}{%
\chapter*{Guía de Ejercicios}\label{guuxeda-de-ejercicios}}
\addcontentsline{toc}{chapter}{Guía de Ejercicios}

\markboth{Guía de Ejercicios}{Guía de Ejercicios}

\hypertarget{recomendaciones-al-realizar-las-guuxedas}{%
\section*{Recomendaciones al realizar las
guías}\label{recomendaciones-al-realizar-las-guuxedas}}
\addcontentsline{toc}{section}{Recomendaciones al realizar las guías}

\markright{Recomendaciones al realizar las guías}

\begin{itemize}
\tightlist
\item
  Prestá atención al leer el enunciado. En particular:

  \begin{itemize}
  \tightlist
  \item
    Si se pide una función que \emph{devuelva} o \emph{calcule} un
    valor, la función debe tener una función \texttt{return}.
  \item
    Si se pide una función que \emph{imprima} un valor, la función debe
    tener un \texttt{print}.
  \item
    Si se pide una función que \emph{pida} o \emph{pregunte} algo al
    usuario, la función debe tener un \texttt{input}.
  \item
    A menos que se diga específicamente ``pedirle al usuario'', no es
    necesario que el programa contenga \texttt{input}. En todo caso,
    hacer que la función reciba el o los datos por parámetro.
  \end{itemize}
\item
  Cada ejercicio puede tener muchas soluciones posibles. Una vez que
  encuentres una solución, en lugar de pasar al siguiente ejercicio,
  pensá si se te ocurre una solución cuya codificación sea más simple.
\item
  Es muy importante que el código sea lo más claro y legible posible.

  \begin{itemize}
  \tightlist
  \item
    En particular, nombres de funciones y variables deben ser
    descriptivos.
  \item
    También prestá atención a los espacios en blanco y a la indentación.
  \end{itemize}
\item
  No documentes en exceso, pero tampoco ahorres documentación necesaria.
\item
  Probá siempre que el código cumpla con lo solicitado.
\end{itemize}

\hypertarget{guuxeda-1-introducciuxf3n-a-la-algoritmia-y-la-programaciuxf3n}{%
\section*{Guía 1: Introducción a la Algoritmia y la
Programación}\label{guuxeda-1-introducciuxf3n-a-la-algoritmia-y-la-programaciuxf3n}}
\addcontentsline{toc}{section}{Guía 1: Introducción a la Algoritmia y la
Programación}

\markright{Guía 1: Introducción a la Algoritmia y la Programación}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Recomendación}, rightrule=.15mm, toprule=.15mm, left=2mm]

En esta guía nos dedicaremos a introducirnos en los conceptos de
programación y algoritmo. Para los primeros seis ejercicios, te
recomendamos ver \href{https://www.youtube.com/watch?v=cDA3_5982h8}{este
video} para recordar cómo entiende la computadora nuestras
instrucciones.

\end{tcolorbox}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Se tiene que explicar a una máquina exactamente cómo servir un vaso de
  jugo (de los que vienen en cartón) de la heladera. Recordando la
  definición de algoritmo, hacer una descripción paso a paso de lo que
  se tiene que hacer y usar para lograr el objetivo. Pista: No vas a
  necesitar nada de código en este ejercicio, sólo nombrar los pasos.
\item
  Se tiene que explicar a una máquina exactamente cómo hacer una tostada
  con queso, pensá qué ingredientes se necesitan con sus cantidades,
  cómo tiene que ser el espacio de trabajo y los elementos que va a
  necesitar usar. Recordando la definición de algoritmo, hacer una
  descripción paso a paso de lo que se tiene que hacer y usar para hacer
  una tostada con queso. Pista: No vas a necesitar nada de código en
  este ejercicio, sólo nombrar los pasos.
\item
  Se te pide que organices una colecta de alimentos no perecederos por
  la Ciudad de Buenos Aires. Contamos con algunos automóviles y
  camionetas de voluntarios, un listado de donaciones, listado de los
  alimentos a donar, la disponibilidad horaria y la dirección en la cual
  se dejan los alimentos. La colecta se realiza en un solo día. ¿Cómo la
  organizarías? Pista: No vas a necesitar nada de código en este
  ejercicio, sólo nombrar los pasos.
\item
  Tenés que enviar invitaciones personalizadas para tu cumpleaños. Cada
  invitación tiene que mencionar el nombre de la persona y la relación
  que tiene con vos. Contamos con una impresora a la que le das el texto
  a enviar, un listado con los nombres de los invitados y la relación
  que cada uno tiene con vos. ¿Cómo redactarías el texto de la
  invitación? Pista: No vas a necesitar nada de código en este
  ejercicio, sólo nombrar los pasos.
\item
  Se te encargó definir qué datos son necesarios para el registro de
  estudiantes en un curso de inglés. ¿Qué datos crees que deberían ser
  obligatorios y cuáles opcionales? ¿Y si el curso es de cocina? Pista:
  No vas a necesitar nada de código en este ejercicio, sólo nombrar los
  pasos.
\item
  Contás con un listado de cosas a comprar y tenes que ir a un
  supermercado que cuenta con distintas góndolas o pasillos. Cada
  góndola o pasillo puede contar con varios, uno o ninguno de los
  productos de tu lista. ¿Cuál sería el listado de instrucciones para
  poder terminar lo más rápido posible? Pista: No vas a necesitar nada
  de código en este ejercicio, sólo nombrar los pasos.
\item
  Con el anexo de Replit de la Unidad 1, realizá tu primer programa:
  hacé que se imprima por pantalla un \texttt{“¡Hola\ mundo!”}.
\end{enumerate}

\hypertarget{guuxeda-2-tipos-de-datos-expresiones-y-funciones}{%
\section*{Guía 2: Tipos de Datos, Expresiones y
Funciones}\label{guuxeda-2-tipos-de-datos-expresiones-y-funciones}}
\addcontentsline{toc}{section}{Guía 2: Tipos de Datos, Expresiones y
Funciones}

\markright{Guía 2: Tipos de Datos, Expresiones y Funciones}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Guardar el texto ``Hola, Mundo!'' en una variable e imprimirla por
  pantalla.
\item
  Guardar los números 1, 2 y 3 en tres variables distintas e imprimirlos
  por pantalla.
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Guardar los números 1, 2 y 3 en tres variables distintas y luego
    sumarlos e imprimir el resultado por pantalla.\\
  \item
    Repetir con las distintas operaciones disponibles que se vieron en
    la unidad 2: resta, multiplicación, división, división entera,
    resto, potencia; combinando los números entre sí.
  \end{enumerate}
\item
  Crear un programa que le solicite al usuario:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Su nombre y lo imprima por pantalla.
  \item
    Su edad y la imprima por pantalla.
  \item
    Su edad, le sume 1, y la imprima por pantalla.
  \end{enumerate}
\item
  Crear un programa que le solicite al usuario un número, y que devuelva
  el resto obtenido de dividirlo por 2.\\
  ¿Qué operador vimos para obtener el resto?
\item
  Escribir un programa que le pida al usuario su año de nacimiento, y
  que le diga qué edad tiene en el año actual.
\item
  Crear un programa que le solicite al usuario 5 enteros y que muestre
  por pantalla el promedio de ellos. Hacerlo de dos formas:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Primero, usando 5 variables para cada entero.
  \item
    Después, usando una sola variable para almacenar la suma de los 5
    enteros. ¿Cómo se te ocurre que podrías hacer?
  \end{enumerate}
\item
  Crear una \textbf{función} que reciba un número y que devuelva el
  valor absoluto.
\item
  Crear una \textbf{función} que reciba un número y que devuelva
  \texttt{True} si es par, y \texttt{False} si es impar.
\item
  Crear una \textbf{función} que reciba un número y un string, y que
  devuelva ambos concatenados dentro de un nuevo string.
\item
  Crear una \textbf{función} que reciba dos enteros y que devuelva el
  resto y el cociente entre ellos.
\item
  Crear una función que le pida al usuario su nombre y apellido, e los
  imprima con el siguiente formato: ``Apellido, Nombre''.
\item
  Hacer una \textbf{función} que reciba una palabra y devuelva la
  cantidad de letras que tiene.
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Hacer una \textbf{función} que reciba una palabra y que imprima los
    primeros 5 caracteres únicamente. Ejemplo: Si se recibe
    ``pensamiento'' se debe imprimir ``pensa''.
  \item
    Hacer una \textbf{función} que reciba una palabra y que imprima sólo
    los caracteres ubicados en posiciones pares. Ejemplo: Si se recibe
    ``pensamiento'' se debe imprimir ``pnaino''.
  \item
    Hacer una \textbf{función} que reciba una palabra y que imprima la
    palabra dada vuelta. Ejemplo: Si se recibe ``materia'' se debe
    imprimir ``airetam''.
  \end{enumerate}
\item
  Hacer una \textbf{funcion} que reciba una palabra, le borre todas las
  letras ``a'' e imprima el resultado por pantalla. Pista: usar una
  función predefinida de Python. Ejemplo: Si se recibe ``casa'' se debe
  imprimir ``cs''. Pista: usar \emph{slices}.
\item
  Analizar qué tipo de dato (o error) se obtiene al hacer las siguientes
  operaciones:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    \texttt{5\ /\ 2}
  \item
    \texttt{5\ //\ 2}
  \item
    \texttt{5\ \%\ 2}
  \item
    \texttt{5\ **\ 2}
  \item
    \texttt{5.0\ /\ 2}
  \item
    \texttt{5.0\ //\ 2}
  \item
    \texttt{5.0\ \%\ 2}
  \item
    \texttt{5.0\ **\ 2}
  \item
    \texttt{5\ /\ 2.0}
  \item
    \texttt{5\ //\ 2.0}
  \item
    \texttt{5\ \%\ 2.0}
  \item
    \texttt{5\ **\ 2.0}
  \item
    \texttt{5.0\ /\ 2.0}
  \item
    \texttt{5.0\ //\ 2.0}
  \item
    \texttt{5.0\ \%\ 2.0}
  \item
    \texttt{5.0\ **\ 2.0}
  \item
    \texttt{"Hola"\ *\ 2}
  \item
    \texttt{"Hola"\ +\ 2}
  \item
    \texttt{"Hola"\ +\ "2"}
  \item
    \texttt{x\ =\ "Hola"}\strut \\
    \texttt{x\ +=\ "\ mundo"}
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Escribir una función que convierta un valor dado en grado Celcius, a
    Fahrenheit. Recordar que la fórmula para la conversión es:
    \texttt{F\ =\ 9/5\ *\ C\ +\ 32}.
  \item
    Escribir una función que convierta un valor dado en grados
    Fahrenheit, a Celcius. Usar la misma fórmula anterior.
  \end{enumerate}
\item
  Escribir una función que calcule el área de un triángulo recibiendo
  como parámetros su base y su altura.
\item
  Siendo el cálculo de la norma de un vector \(v\) en \(R^3\):\\
  \[||v|| = \sqrt{v_1^2 + v_2^2 + v_3^2}\]\\
  Escribir una función que calcule la norma de un vector en R3
  recibiendo como parámetros las 3 componentes \(v_1\), \(v_2\) y
  \(v_3\) del mismo.
\item
  \textbf{Desafío} (no obligatorio): Calcular el área de un rectángulo
  (alineado con los ejes \(x\) e \(y\)), dadas sus coordenadas \(x_1\),
  \(x_2\), \(y_1\) e \(y_2\).
\end{enumerate}

\hypertarget{guuxeda-3-estructuras-de-control}{%
\section*{Guía 3: Estructuras de
Control}\label{guuxeda-3-estructuras-de-control}}
\addcontentsline{toc}{section}{Guía 3: Estructuras de Control}

\markright{Guía 3: Estructuras de Control}

\hypertarget{decisiones-1}{%
\subsection*{1. Decisiones}\label{decisiones-1}}
\addcontentsline{toc}{subsection}{1. Decisiones}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Escribir una función que, dado un número entero \(n\), calcule si es
  impar o no.
\item
  Escribir una implementación propia de la función \(abs\), que devuelva
  el valor absoluto de cualquier valor que reciba. Ejemplo:
  \texttt{mi\_abs(5)} devuelve \texttt{5} y \texttt{mi\_abs(-5)}
  devuelve \texttt{5}. Pista: No se puede usar la función predefinida
  \texttt{abs}.
\item
  Escribir una función que reciba un número y devuelva \texttt{True} si
  es entero y \texttt{False} si no lo es. Pista: no se puede usar la
  función \texttt{isinstance}.
\item
  Escribir una función para determinar si una letra recibida es vocal o
  no. La misma debe devolver un valor booleano. Luego, escribir una
  función para determinar si una letra es consonante o no.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Resolver \emph{sin} el uso de \texttt{in} ni \texttt{not\ in}.
  \item
    Resolver \emph{usando} \texttt{in} y \texttt{not\ in}.
  \item
    Resolver para que la función identifique tanto mayúsculas como
    minúsculas. Pista: investigar los métodos \texttt{lower} y
    \texttt{upper} de string.
  \end{enumerate}
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-tip-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-tip-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip: \texttt{in} y \texttt{not\ in}}, rightrule=.15mm, toprule=.15mm, left=2mm]

¿Conocés el uso de \texttt{in}?

Para saber si un elemento está en una lista o en un string, podemos usar
\texttt{in} y \texttt{not\ in}. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}a\textquotesingle{}} \KeywordTok{in} \StringTok{\textquotesingle{}hola\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}w\textquotesingle{}} \KeywordTok{in} \StringTok{\textquotesingle{}hola\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}w\textquotesingle{}} \KeywordTok{not} \KeywordTok{in} \StringTok{\textquotesingle{}hola\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}casa\textquotesingle{}} \KeywordTok{in}\NormalTok{ [}\StringTok{\textquotesingle{}cama\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}mesa\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}silla\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\end{tcolorbox}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Escribir funciones que resuelvan los siguientes problemas:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Dado un año, que devuelva si es bisiesto. Nota: un año es bisiesto
    si es un número divisible por 4, pero no si es divisible por 100,
    excepto que también sea divisible por 400.
  \item
    Dado un mes y un año, que devuelva la cantidad de días
    correspondientes.
  \item
    Pedirle al usuario su día y mes de cumpleaños. El programa debe
    imprimir un mensaje indicando a qué signo corresponde el usuario.
  \end{enumerate}

\begin{verbatim}
Aries: 21 de marzo al 20 de abril.
Tauro: 21 de abril al 20 de mayo.
Geminis: 21 de mayo al 21 de junio.
Cancer: 22 de junio al 23 de julio.
Leo: 24 de julio al 23 de agosto.
Virgo: 24 de agosto al 23 de septiembre.
Libra: 24 de septiembre al 22 de octubre.
Escorpio: 23 de octubre al 22 de noviembre.
Sagitario: 23 de noviembre al 21 de diciembre.
Capricornio: 22 de diciembre al 20 de enero.
Acuario: 21 de enero al 19 de febrero.
Piscis: 20 de febrero al 20 de marzo.
\end{verbatim}
\item
  Piedra, papel o tijera: escribir un programa de ``Piedra, papel o
  tijera'' tal que sea imposible que el usuario gane. El usuario debe
  ingresar \textbf{R} (piedra), \textbf{P} (papel), o \textbf{T}
  (tijera) y la computadora debe siempre ganarle. Ejemplo:

\begin{verbatim}
¡Piedra (R), papel (P) o tijera (T)!
Ingrese jugada: R
¡Papel! ¡Gané!
\end{verbatim}

\begin{verbatim}
¡Piedra (R), papel (P) o tijera (T)!
Ingrese jugada: P
¡Tijera! ¡Gané!
\end{verbatim}

\begin{verbatim}
¡Piedra (R), papel (P) o tijera (T)!
Ingrese jugada: T
¡Piedra! ¡Gané!
\end{verbatim}

\begin{verbatim}
¡Piedra (R), papel (P) o tijera (T)!
Ingrese jugada: M
Esa jugada no está disponible.
\end{verbatim}
\item
  Suponiendo que el primer día del año fue lunes, escribir una función
  que reciba un número con el día del año (de 1 a 366) y devuelva el día
  de la semana que le toca. Por ejemplo: si se recibe `3', debe devolver
  ``miércoles'', y si se recibe `9', debe devolver ``martes''.
\end{enumerate}

\hypertarget{ciclos-1}{%
\subsection*{2. Ciclos}\label{ciclos-1}}
\addcontentsline{toc}{subsection}{2. Ciclos}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Escribir función que:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Imprima por pantalla todos los números entre 10 y 20.
  \item
    Salude a todas las personas de esta lista
    \texttt{{[}Flaminia,\ Iara,\ Agostina,\ Priscila,\ Sol,\ Lucía{]}}
    con el mensaje
    \texttt{"Hola\ \textless{}nombre\textgreater{}!\ Vamos\ a\ aprender\ a\ programar"}.
  \item
    Le pida al usuario que ingrese 5 números y le muestre la suma total
    de todos ellos.
  \item
    Imprima por pantalla todos los números entre 100 y 199 que sean
    divisibles por 7.
  \item
    Reciba dos números, y recorra todos los números entre ellos,
    imprimiendo en pantalla si es par o impar. Por ejemplo, recibiendo 1
    y 3, debe imprimir:
  \end{enumerate}

\begin{verbatim}
1 es impar
2 es par
3 es impar
\end{verbatim}
\item
  Se quiere hacer un programa para enseñar a los niños las tablas de
  multiplicar del 1 al 10. Crear una función que reciba un número e
  imprima por pantalla la tabla de multiplicar de ese número. Ejemplo:

\begin{verbatim}
mostrar_tablas_para(1)
\end{verbatim}

  debe imprimir:

\begin{verbatim}
1 x 1 = 1
1 x 2 = 2
1 x 3 = 3
1 x 4 = 4
1 x 5 = 5
1 x 6 = 6
1 x 7 = 7
1 x 8 = 8
1 x 9 = 9
1 x 10 = 10
\end{verbatim}

\begin{verbatim}
mostrar_tablas_para(-2)
\end{verbatim}

  debe imprimir:

\begin{verbatim}
Error: El número debe ser positivo y estar entre 1 y 10
\end{verbatim}
\item
  Crear una función que cante el feliz cumpleaños. Dado un entero, debe
  imprimir `Que los cumplas feliz' en distintas líneas por esa cantidad
  de veces.
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Necesitamos escribir un programa de cobro en el supermercado. La
    función debe recibir un número entero que representa el monto a
    pagar y debe permitir al usuario que ingrese valores, hasta que el
    pago se haya realizado en su totalidad. Además, le debe ir indicando
    cuánto le queda por pagar. El programa no da vuelto.
  \end{enumerate}

  Ejemplo:
  \texttt{Su\ total\ a\ pagar\ es:\ 500\ \ Ingrese\ el\ monto\ a\ pagar:\ 100\ \ Pendientes:\ 400.\ Ingrese\ el\ monto\ a\ pagar:\ 200\ \ Pendientes:\ 200.\ Ingrese\ el\ monto\ a\ pagar:\ 200\ \ Pendientes:\ 0.\ Gracias\ por\ su\ compra.}

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \tightlist
  \item
    Hacer que el programa anterior dé vuelto:
  \end{enumerate}

  Ejemplo:
  \texttt{Su\ total\ a\ pagar\ es:\ 500\ \ Ingrese\ el\ monto\ a\ pagar:\ 100\ \ Pendientes:\ 400.\ Ingrese\ el\ monto\ a\ pagar:\ 200\ \ Pendientes:\ 200.\ Ingrese\ el\ monto\ a\ pagar:\ 300\ \ Pendientes:\ 0.\ Su\ vuelto\ es:\ 100.\ Gracias\ por\ su\ compra.}
\item
  Escribir un programa que le pida al usuario que ingrese un número.
  Para ese número, se imprime la tabla de multiplicar del 1 al 10.
  Luego, se le vuelve a pedir otro número. Si el usuario ingresa ``X'',
  el programa debe terminar. El usuario debe poder ingresar números
  indefinidamente hasta que ingrese ``X''. Se puede reutilizar la
  función del ejercicio 9 de esta guía.

  Ejemplo:
  \texttt{Hola!\ Esto\ es\ Tablas\ de\ Multiplicar\ \ Ingrese\ un\ número\ o\ "X"\ para\ salir:\ 1\ \ 1\ x\ 1\ =\ 1\ \ 1\ x\ 2\ =\ 2\ \ 1\ x\ 3\ =\ 3\ \ 1\ x\ 4\ =\ 4\ \ 1\ x\ 5\ =\ 5\ \ 1\ x\ 6\ =\ 6\ \ 1\ x\ 7\ =\ 7\ \ 1\ x\ 8\ =\ 8\ \ 1\ x\ 9\ =\ 9\ \ 1\ x\ 10\ =\ 10\ \ Ingrese\ un\ número\ o\ "X"\ para\ salir:\ -2\ \ Error:\ El\ número\ debe\ ser\ positivo\ y\ estar\ entre\ 1\ y\ 10\ \ Ingrese\ un\ número\ o\ "X"\ para\ salir:\ X\ \ ¡Adios!}
\item
  \textbf{Manejo de contraseñas}

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Escribir un programa que contenga una constraseña inventada, que le
    pregunte al usuario la contraseña, y no le permita continuar hasta
    que la haya ingresado correctamente.
  \item
    Modificar el programa anterior para que solamente permita una
    cantidad fija de intentos.
  \item
    Modificar el programa anterior para que sea una función que devuelva
    si el usuario ingresó o no la contraseña correctamente, mediante un
    valor booleano (\texttt{True} o \texttt{False}).
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Hacer una función que reciba un número del 1 al 10, y luego permita
    al usuario poder adivinar ese número, ingresando valores
    repetidamente. Para cada ingreso del usuario, el programa debe
    indicarle si su numero es menor o mayor al número a adivinar. Una
    vez que el usuario ingresa el número correcto, lo felicita y
    termina.
  \item
    Repetir permitiendo únicamente 3 intentos.
  \item
    Repetir generando el número aleatoriamente de la siguiente forma
    dentro de la función, sin recibirlo por parámetro:
  \end{enumerate}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}
\NormalTok{numero\_a\_adivinar }\OperatorTok{=}\NormalTok{ random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(numero\_a\_adivinar)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, colback=white, coltitle=black, colframe=quarto-callout-note-color-frame, leftrule=.75mm, bottomtitle=1mm, arc=.35mm, breakable, opacitybacktitle=0.6, bottomrule=.15mm, colbacktitle=quarto-callout-note-color!10!white, toptitle=1mm, opacityback=0, titlerule=0mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Tip: Librerías}, rightrule=.15mm, toprule=.15mm, left=2mm]

¿Sabías que Python tiene muchas librerías que podés usar para hacer
cosas más complejas? Por ejemplo, la librería \texttt{random} tiene
funciones para generar números aleatorios. También hay otras librerías
como \texttt{Pandas} para trabajar con datos, \texttt{Matplotlib} para
hacer gráficos, \texttt{Numpy} para trabajar con matrices, y muchas más.
Vamos a estar viendo estas tres en la última unidad de la materia.

Una librería es un conjunto de funciones que alguien más escribió y que
podemos usar en nuestros programas. Para usar una librería, primero
tenemos que importarla. Por ejemplo, para usar la librería
\texttt{random}, tenemos que poner \texttt{import\ random} al principio
de nuestro programa (arriba de todo en nuestro archivo). Luego, podemos
usar las funciones de la librería, como \texttt{random.randint(1,\ 10)}.

\end{tcolorbox}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Queremos modelar una máquina de sacar juguetes. Debemos hacer una
    función que reciba un número que representa la cantidad de fichas
    \(x\) que necesita la máquina para funcionar. Se debe imprimir un
    mensaje en pantalla que indique ``Ingresá \(x\) fichas para
    comenzar''. El usuario deberá ingresar entonces letras ``F'', que
    representan a las fichas. Notar que si se ingresa algo distinto a
    ``F'', se ignora.
  \end{enumerate}

  Se debe seguir solicitando fichas siempre que no se haya alcanzado la
  cantidad necesaria para funcionar. Cuando se haya alcanzado la
  cantidad necesaria, se debe imprimir un mensaje que indique ``¡A
  jugar!''. Ejemplo:

\begin{verbatim}
Ingresá 2 fichas para comenzar: F
Ingresá 2 fichas para comenzar: B
Ingresá 2 fichas para comenzar: Hola
Ingresá 2 fichas para comenzar: F
¡A jugar!
\end{verbatim}

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \tightlist
  \item
    Modificar el programa anterior para que vaya mostrando la cantidad
    de fichas que faltan para comenzar a jugar. Ejemplo:
  \end{enumerate}

\begin{verbatim}
Ingresá 2 fichas para comenzar: F
Ingresá 1 fichas para comenzar: B
Ingresá 1 fichas para comenzar: ficha
Ingresá 1 fichas para comenzar: F
¡A jugar!
\end{verbatim}
\item
  Crear una función que calcule si un número es primo o no. Un número es
  primo cuando solamente es divisible por sí mismo y por 1. Pista: usar
  el operador módulo \texttt{\%}.
\item
  \textbf{Desafío} (obligatorio): Crear una función que reciba un número
  entero e imprima los números primos entre 0 y el número ingresado.
\item
  \textbf{Desafío} (obligatorio):

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Crear una función que reciba dos números, y devuelva la suma de
    todos los números múltiplos de 7 entre esos dos números. Por
    ejemplo, si recibe 3 y 25, debe devolver 7 + 14 + 21 = 42. Si recibe
    3 y 4, debe devolver 0, ya que no hay múltiplos de 7 entre esos dos
    números.
  \item
    Repetir calculando el promedio en vez de la suma.
  \item
    Repetir calculando únicamente el promedio entre los primeros 3
    múltiplos de 7 encontrados. Pista: usar \texttt{break}.
  \item
    Repetir calculando únicamente el promedio entre los múltiplos de 7
    encontrados que no sean múltiplos de 2. Pista: usar
    \texttt{continue}.
  \end{enumerate}
\item
  \textbf{Desafío} (obligatorio):

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Escribir una función que dada la cantidad de ejercicios de un
    examen, y el porcentaje de ejercicios bien resueltos necesario para
    aprobar dicho examen, revise un grupo de exámenes.
  \end{enumerate}

  Para ello, en cada paso debe preguntarle al usuario la cantidad de
  ejercicios resueltos por el alumno, o pedirle que ingrese ``*'' para
  salir. Debe mostrar por pantalla el porcentaje correspondiente a la
  cantidad de ejercicios resueltos respecto a la cantidad de ejercicios
  del examen y una leyenda que indique si aprobó o no.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \tightlist
  \item
    Adicional al punto anterior: imprimir un mensaje informándole al
    usuario la cantidad de ejercicios y el \% de aprobación.\\
    Validar que el usuario siempre ingrese números positivos y menor o
    iguales a la cantidad de ejercicios del examen, o ``*``. De lo
    contrario, mostrar un mensaje de error y volver a pedirle el dato al
    usuario.
  \end{enumerate}
\end{enumerate}

\hypertarget{guuxeda-4-tipos-de-estructuras-de-datos}{%
\section*{Guía 4: Tipos de Estructuras de
Datos}\label{guuxeda-4-tipos-de-estructuras-de-datos}}
\addcontentsline{toc}{section}{Guía 4: Tipos de Estructuras de Datos}

\markright{Guía 4: Tipos de Estructuras de Datos}

\hypertarget{cadenas-de-caracteres-1}{%
\subsection*{Cadenas de caracteres}\label{cadenas-de-caracteres-1}}
\addcontentsline{toc}{subsection}{Cadenas de caracteres}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Escribir funciones que dada una cadena y un caracter:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Inserte el caracter entre cada letra de la cadena. Ejemplo:
    \texttt{\textquotesingle{}separar\textquotesingle{}} y
    \texttt{\textquotesingle{}-\textquotesingle{}} debería devolver
    \texttt{\textquotesingle{}s-e-p-a-r-a-r\textquotesingle{}}.\\
  \item
    Reemplace todos los espacios por el caracter. Ejemplo:
    \texttt{\textquotesingle{}mi\ archivo\ de\ texto.txt\textquotesingle{}}
    y \texttt{\textquotesingle{}\_}' debería devolver
    \texttt{\textquotesingle{}mi\_archivo\_de\_texto.txt\textquotesingle{}}.\\
  \item
    Reemplace todos los dígitos de la cadena por el caracter. Ejemplo:
    \texttt{\textquotesingle{}su\ clave\ es:\ 1540\textquotesingle{}} y
    \texttt{\textquotesingle{}*\textquotesingle{}} debería devolver
    \texttt{\textquotesingle{}su\ clave\ es:\ ****\textquotesingle{}}.\\
  \item
    Inserte el caracter cada 3 dígitos en la cadena. Ejemplo:
    \texttt{\textquotesingle{}2552552550\textquotesingle{}} y
    \texttt{\textquotesingle{}.\textquotesingle{}} debería devolver `'
  \item
    Modificar todas las anteriores para que, adicionalmente, reciba un
    parámetro que indique la cantidad máxima de reemplazos o inserciones
    a realizar. Ejemplo:
    \texttt{\textquotesingle{}su\ clave\ es:\ 1540\textquotesingle{}},
    \texttt{\textquotesingle{}*\textquotesingle{}} y \texttt{3} debería
    devolver
    \texttt{\textquotesingle{}su\ clave\ es:\ ***0\textquotesingle{}}.
  \end{enumerate}
\item
  Escribir una función que reciba una cadena que contiene un largo
  número entero y devuelva una cadena con el número y las separaciones
  de miles. Por ejemplo, si recibe \texttt{1234567890}, debe devolver
  \texttt{1.234.567.890}. Cuidado: no es lo mismo \texttt{123.456.789.0}
  que \texttt{1.234.567.890}. Tienen que ser separaciones de miles y
  quedar un número válido.
\item
  Escribir funciones que dada una cadena de caracteres:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Devuelva la primera letra de cada palabra. Ejemplo: si se recibe
    \texttt{Ciclo\ Básico\ Común} se debe devolver \texttt{CBC}.
  \item
    Indique si se trata de un palíndromo. Por ejemplo,
    \texttt{anita\ lava\ la\ tina} es un palíndromo (se lee igual de
    izquierda a derecha que de derecha a izquierda).
  \end{enumerate}
\item
  Escribir funciones que dadas dos cadenas de caracteres:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Indique si la segunda cadena es subcadena de la primera. Por
    ejemplo, \texttt{\textquotesingle{}compu\textquotesingle{}} es
    subcadena de
    \texttt{\textquotesingle{}computacional\textquotesingle{}}.
  \item
    Devuelva la que sea anterior en orden alfábetico. Por ejemplo, si
    recibe \texttt{\textquotesingle{}kde\textquotesingle{}} y
    \texttt{\textquotesingle{}gnome\textquotesingle{}} debe devolver
    \texttt{\textquotesingle{}gnome\textquotesingle{}}.
  \end{enumerate}
\item
  Escribir una función que, dada una cadena de caracteres, devuelva una
  lista con cada uno de los caracteres que la componen en mayúscula.
  Ejemplo: \texttt{\textquotesingle{}Hola\textquotesingle{}} debe
  devolver
  \texttt{{[}\textquotesingle{}H\textquotesingle{},\ \textquotesingle{}O\textquotesingle{},\ \textquotesingle{}L\textquotesingle{},\ \textquotesingle{}A\textquotesingle{}{]}}.
  Restricción: no se permite el uso de ciclos for/while.
\item
  Escribir una función que, dada una cadena de caracteres, devuelva una
  tupla con cada uno de los caracteres que no es una vocal. Ejemplo:
  \texttt{\textquotesingle{}Algoritmos\textquotesingle{}} debe devolver
  \texttt{(\textquotesingle{}l\textquotesingle{},\ \textquotesingle{}g\textquotesingle{},\ \textquotesingle{}r\textquotesingle{},\ \textquotesingle{}t\textquotesingle{},\ \textquotesingle{}m\textquotesingle{},\ \textquotesingle{}s\textquotesingle{})}.
  Restricción: no se permite el uso de ciclos for/while.
\item
  Escribir una función que, dada una cadena de caracteres, devuelva el
  número de índice del último caracter. Por ejemplo, para la cadena
  \texttt{\textquotesingle{}Hola\textquotesingle{}} debe devolver
  \texttt{3}. Restricción: no se permite el uso de ciclos for/while.
\item
  ** Desafío** (obligatorio):

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Se quiere implementar un buscador dentro de un editor de texto, que
    permita encontrar todas las ocurrencias de una palabra en un texto.
    Para ello, se debe implementar una función que reciba como parámetro
    una palabra y un texto, y que devuelva una lista con las posiciones
    de inicio de cada ocurrencia de la palabra dentro del texto.
    Ejemplo: si se busca \texttt{\textquotesingle{}al\textquotesingle{}}
    en
    \texttt{\textquotesingle{}calcule\ el\ precio\ al\ valor\ actual\textquotesingle{}},
    debe devolver \texttt{{[}1,\ 18,\ 22,\ 31{]}}. Pista: \texttt{index}
    devolverá un error si la subcadena no se encuentra. ¿Qué otro método
    tenemos disponible para buscar subcadenas?
  \item
    Modificar la función anterior para que devuelva la cantidad de
    ocurrencias encontradas. Ejemplo: si se busca
    \texttt{\textquotesingle{}al\textquotesingle{}} en
    \texttt{\textquotesingle{}calcule\ el\ precio\ al\ valor\ actual\textquotesingle{}},
    debe devolver \texttt{4}. Restricción: No se puede usar el método
    \texttt{len}.
  \end{enumerate}
\item
  \textbf{Desafío} (no obligatorio): Escribir una función que reciba dos
  cadenas de caracteres y devuelva una lista con todos los caracteres
  que no tienen en común. Ejemplo:
  \texttt{\textquotesingle{}Python\textquotesingle{}} y
  \texttt{\textquotesingle{}Hola\textquotesingle{}} debería devolver el
  conjunto de letras
  \texttt{{[}\textquotesingle{}P\textquotesingle{},\ \textquotesingle{}y\textquotesingle{},\ \textquotesingle{}t\textquotesingle{},\ \textquotesingle{}l\textquotesingle{},\ \textquotesingle{}a\textquotesingle{},\ \textquotesingle{}n\textquotesingle{}{]}},
  indiferentemente del orden y de si está en mayúscula o minúscula.
  Nota: para que un caracter esté en la lista, no es necesario que esté
  en la misma posición. Restricción: no se permite el uso de ciclos
  for/while. Pista: investigar cómo usar \texttt{lambda}.
\end{enumerate}

\hypertarget{rangos-tuplas-y-listas}{%
\subsection*{Rangos, Tuplas y Listas}\label{rangos-tuplas-y-listas}}
\addcontentsline{toc}{subsection}{Rangos, Tuplas y Listas}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Usar un rango para:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Imprimir los números del 10 al 50 inclusive, saltando de 5 en 5.
  \item
    Imprimir los números del 40 al 20 en orden decreciente, saltando de
    2 en 2.
  \item
    Imprimir los números pares del 2 al 100 inclusive, saltando de 2 en
    2.
  \item
    Crear una lista con los números del 4 al 10. Luego, acceder con el
    \emph{índice} a los elementos que contienen a los números 4, 6 y 9 e
    impimirlos por pantalla. Pista: recordar que los índices comienzan
    en 0.
  \end{enumerate}
\item
  Escribir una función que reciba una lista y devuelva \texttt{True} si
  su longitud es par y \texttt{False} si su longitud es impar.
\item
  Escribir una función que reciba una lista de números cualesquiera y
  devuelva el elemento máximo y el mínimo.
\item
  Escribir una función que reciba una lista de números y devuelva otra
  lista con los mismos números ordenados de menor a mayor. Por ejemplo,
  si recibe \texttt{{[}5,\ 10,\ 7,\ 3{]}} debe devolver
  \texttt{{[}3,\ 5,\ 7,\ 10{]}}.
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Escribir una función que reciba una lista de nombres y un número,
    que representa el cupo. La función debe devolver en una lista a los
    nombres que no pudieron entrar al curso por falta de cupo. Ejemplo:
    \texttt{chequear\_cupo({[}\textquotesingle{}Agustina\textquotesingle{},\ \textquotesingle{}Iara\textquotesingle{},\ \textquotesingle{}Priscila\textquotesingle{},\ \textquotesingle{}Sol\textquotesingle{},\ \textquotesingle{}Lucía\textquotesingle{}{]},\ 3)}
    debe devolver
    \texttt{{[}\textquotesingle{}Sol\textquotesingle{},\ \textquotesingle{}Lucía\textquotesingle{}{]}}.
  \item
    Modificar la función anterior para que devuelva únicamente a la
    última persona de la lista de la gente que pudo entrar. Ejemplo:
    \texttt{chequear\_cupo({[}\textquotesingle{}Agustina\textquotesingle{},\ \textquotesingle{}Iara\textquotesingle{},\ \textquotesingle{}Priscila\textquotesingle{},\ \textquotesingle{}Sol\textquotesingle{},\ \textquotesingle{}Lucía\textquotesingle{}{]},\ 3)}
    debe devolver \texttt{\textquotesingle{}Priscila\textquotesingle{}},
    porque es la última que tuvo cupo.
  \end{enumerate}
\item
  Dada la lista de tuplas
  \texttt{{[}("Argentina",\ 3),\ ("España",1),\ ("Uruguay",\ 2),\ ("Francia",2){]}},
  donde cada tupla contiene un país y la cantidad de mundiales que
  ganaron:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Hacer una función que la lista por parámetro e imprima la
    información de cada país con el siguiente formato:
  \end{enumerate}

\begin{verbatim}
País: <nombre> - Copas: <cantidad>
\end{verbatim}

  Si y sólo si el país es ``Argentina'', se debe imprimir el nombre con
  3 estrellas: \texttt{"Argentina⭐⭐⭐"}. Usar el operador \texttt{+=}.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \item
    Hacer una función que reciba la lista por parámetro y devuelva la
    cantidad de mundiales que ganaron entre todos los países. Ejemplo:
    \texttt{contar\_mundiales({[}("Argentina",\ 3),\ ("España",1),\ ("Uruguay",\ 2),\ ("Francia",2){]})}
    debe devolver \texttt{8}.
  \item
    Hacer una función que reciba la lista por parámetro y la devuelva,
    ordenada por cantidad de copas ganadas.
  \item
    Hacer una función que reciba la lista por parámetro y devuelva una
    lista con los países que tienen más de una copa ganada.
  \end{enumerate}
\item
  Escribir una función que reciba dos fichas de dominó y determine si
  \emph{encajan} o no entre sí.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Resolver teniendo en cuenta que las fichas se reciben con formato de
    tuplas. Ejemplo: \texttt{(3,4)} y \texttt{(5,4)}.
  \item
    Resolver teniendo en cuenta que las fichas se reciben con formato de
    string. Ejemplo: \texttt{\textquotesingle{}3-4\textquotesingle{}} y
    \texttt{\textquotesingle{}5-4\textquotesingle{}}.
  \end{enumerate}
\item
  Escribir una función que reciba dos vectores y devuelva su producto
  escalar. El producto escalar se calcula como:
  \(v1 \cdot v2 = (v1_1 \cdot v2_1) + (v1_2 \cdot v2_2) + ... + (v1_n \cdot v2_n)\).
  Si los vectores no tienen las mismas dimensiones, la función debe
  devolver \texttt{None}.
\item
  Se tiene una base de datos con nombres de libros de la siguiente forma
  \texttt{{[}"La\ Noche\ de\ la\ Usina",\ "La\ Pregunta\ de\ sus\ Ojos",\ "Ser\ Feliz\ era\ Esto",...{]}},
  y se quiere saber cuántos libros repetidos tienen. Escribir una
  función que reciba la base de datos y devuelva, para cada uno de los
  títulos, cuántos ejemplares hay. La lista no tiene un tamaño fijo, y
  puede contener muchos títulos repetidos.
\item
  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Escribir una función que reciba una tupla, un índice, y un nuevo
    valor. La función debe modificar la tupla, cambiando el valor en la
    posición dada por el índice, por el nuevo valor pasado como
    parámetro. Devolver la tupla modificada.
  \item
    Repetir el ejercicio anterior, pero con una lista.
  \end{enumerate}
\item
  Escribir una función que reciba una lista y un valor, y devuelva la
  lista con dicho valor eliminado de sus elementos. Si la lista no
  contiene al valor, se devuelve tal cual se recibió.
\item
  Escribir una función que reciba una lista y un número \(n\). Para
  dicho número \(n\), debe imprimir los últimos \(n\) elementos de la
  lista en orden inverso, y luego devolver la lista sin ellos. Ejemplo:
  Si se recibe \texttt{{[}1,\ 2,\ 3,\ 4,\ 5{]}} y \texttt{n\ =\ 2}, debe
  imprimir \texttt{5}, \texttt{4} y devolver \texttt{{[}1,\ 2,\ 3{]}}.
\item
  Escribir una función que reciba una lista de números y devuelva la
  misma lista en orden inverso.
\item
  Escribir una función que dado un valor \(n\), devuelva una lista con
  los números del 1 a \(n\). Restricción: usar listas por comprensión.
\item
  Escribir una función que devuelva una matriz y una tupla (fila,
  columna), y devuelva el valor ubicado en esa posición de la matriz.
  Ejemplo: si se recibe la matriz
  \texttt{{[}{[}1,\ 2{]},\ {[}3,\ 4{]}{]}} y la tupla \texttt{(0,\ 1)},
  debe devolver \texttt{2}.
\item
  \textbf{Desafio} (obligatorio): Escribir una función que reciba un
  tamaño y devuelva una matriz con 1 en la diagonal principal y 0 en el
  resto. Ejemplo: si recibe 4, debe devolver la matriz identidad de
  tamaño 4x4. \[$
  \begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 1 \\
  \end{bmatrix}
  \]\$
\item
  \textbf{Desafio} (obligatorio): Escribir una función que reciba una
  matriz y devuelva su transpuesta. Ejemplo: si recibe la matriz
  \texttt{{[}{[}1,\ 2,\ 3{]},\ {[}4,\ 5,\ 6{]}{]}}, debe devolver
  \texttt{{[}{[}1,\ 4{]},\ {[}2,\ 5{]},\ {[}3,\ 6{]}{]}}. \$\$\$

  \begin{bmatrix}
  1 & 2 & 3  \\
  4 & 5 & 6  \\
  \end{bmatrix}
\end{enumerate}

\implies
\begin{bmatrix}
1 & 4 \\
2 & 5 \\
3 & 6 \\
\end{bmatrix}

\$\$\$



\end{document}
